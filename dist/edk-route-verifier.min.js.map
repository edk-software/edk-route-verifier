{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/loglevel/lib/loglevel.js","webpack:///./node_modules/@turf/helpers/index.js","webpack:///./node_modules/lodash/isArray.js","webpack:///./node_modules/lodash/_root.js","webpack:///./node_modules/@turf/invariant/index.js","webpack:///./node_modules/lodash/_getNative.js","webpack:///./node_modules/lodash/_baseGetTag.js","webpack:///./node_modules/lodash/isObjectLike.js","webpack:///./node_modules/lodash/isArrayLike.js","webpack:///./node_modules/lodash/isObject.js","webpack:///./node_modules/lodash/isSymbol.js","webpack:///./node_modules/lodash/identity.js","webpack:///./node_modules/lodash/_Symbol.js","webpack:///./node_modules/lodash/eq.js","webpack:///./node_modules/lodash/keys.js","webpack:///./node_modules/lodash/_baseIteratee.js","webpack:///./node_modules/@turf/distance/index.js","webpack:///./node_modules/lodash/isArguments.js","webpack:///./node_modules/lodash/_ListCache.js","webpack:///./node_modules/lodash/_assocIndexOf.js","webpack:///./node_modules/lodash/_nativeCreate.js","webpack:///./node_modules/lodash/_getMapData.js","webpack:///./node_modules/lodash/_arrayMap.js","webpack:///./node_modules/lodash/_toKey.js","webpack:///./node_modules/lodash/_isPrototype.js","webpack:///./node_modules/lodash/_Map.js","webpack:///./node_modules/lodash/isLength.js","webpack:///./node_modules/lodash/isBuffer.js","webpack:///./node_modules/lodash/isTypedArray.js","webpack:///./node_modules/lodash/_baseIsEqual.js","webpack:///./node_modules/lodash/_MapCache.js","webpack:///./node_modules/lodash/_isIndex.js","webpack:///./node_modules/lodash/_baseEach.js","webpack:///./node_modules/lodash/get.js","webpack:///./node_modules/lodash/_isKey.js","webpack:///./node_modules/lodash/toString.js","webpack:///./node_modules/lodash/_baseRest.js","webpack:///./node_modules/lodash/_isIterateeCall.js","webpack:///./node_modules/lodash/isEmpty.js","webpack:///./node_modules/lodash/_baseKeys.js","webpack:///./node_modules/lodash/_overArg.js","webpack:///./node_modules/lodash/_getTag.js","webpack:///./node_modules/lodash/isFunction.js","webpack:///./node_modules/lodash/_freeGlobal.js","webpack:///./node_modules/lodash/_toSource.js","webpack:///(webpack)/buildin/module.js","webpack:///./node_modules/lodash/_baseUnary.js","webpack:///./node_modules/lodash/isEqual.js","webpack:///./node_modules/lodash/_Stack.js","webpack:///./node_modules/lodash/_equalArrays.js","webpack:///./node_modules/lodash/_arrayPush.js","webpack:///./node_modules/lodash/_arrayFilter.js","webpack:///./node_modules/lodash/_arrayLikeKeys.js","webpack:///./node_modules/lodash/isNull.js","webpack:///./node_modules/lodash/filter.js","webpack:///./node_modules/lodash/_isStrictComparable.js","webpack:///./node_modules/lodash/_matchesStrictComparable.js","webpack:///./node_modules/lodash/_baseGet.js","webpack:///./node_modules/lodash/_castPath.js","webpack:///./node_modules/lodash/find.js","webpack:///./node_modules/lodash/forEach.js","webpack:///./node_modules/lodash/map.js","webpack:///./node_modules/lodash/_baseMap.js","webpack:///./node_modules/lodash/min.js","webpack:///./node_modules/lodash/sortBy.js","webpack:///./node_modules/lodash/_apply.js","webpack:///./node_modules/lodash/_defineProperty.js","webpack:///./node_modules/lodash/template.js","webpack:///./node_modules/lodash/_baseAssignValue.js","webpack:///./node_modules/lodash/isError.js","webpack:///./node_modules/lodash/_reInterpolate.js","webpack:///./node_modules/togeojson/togeojson.js","webpack:///./node_modules/@turf/length/index.js","webpack:///./node_modules/@turf/nearest-point-on-line/index.js","webpack:///./node_modules/@turf/point-to-line-distance/index.js","webpack:///./node_modules/lodash/_nativeKeys.js","webpack:///./node_modules/lodash/_DataView.js","webpack:///./node_modules/lodash/_baseIsNative.js","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/lodash/_getRawTag.js","webpack:///./node_modules/lodash/_objectToString.js","webpack:///./node_modules/lodash/_isMasked.js","webpack:///./node_modules/lodash/_coreJsData.js","webpack:///./node_modules/lodash/_getValue.js","webpack:///./node_modules/lodash/_Promise.js","webpack:///./node_modules/lodash/_Set.js","webpack:///./node_modules/lodash/_WeakMap.js","webpack:///./node_modules/lodash/_baseIsArguments.js","webpack:///./node_modules/lodash/stubFalse.js","webpack:///./node_modules/lodash/_baseIsTypedArray.js","webpack:///./node_modules/lodash/_nodeUtil.js","webpack:///./node_modules/lodash/_baseIsEqualDeep.js","webpack:///./node_modules/lodash/_listCacheClear.js","webpack:///./node_modules/lodash/_listCacheDelete.js","webpack:///./node_modules/lodash/_listCacheGet.js","webpack:///./node_modules/lodash/_listCacheHas.js","webpack:///./node_modules/lodash/_listCacheSet.js","webpack:///./node_modules/lodash/_stackClear.js","webpack:///./node_modules/lodash/_stackDelete.js","webpack:///./node_modules/lodash/_stackGet.js","webpack:///./node_modules/lodash/_stackHas.js","webpack:///./node_modules/lodash/_stackSet.js","webpack:///./node_modules/lodash/_mapCacheClear.js","webpack:///./node_modules/lodash/_Hash.js","webpack:///./node_modules/lodash/_hashClear.js","webpack:///./node_modules/lodash/_hashDelete.js","webpack:///./node_modules/lodash/_hashGet.js","webpack:///./node_modules/lodash/_hashHas.js","webpack:///./node_modules/lodash/_hashSet.js","webpack:///./node_modules/lodash/_mapCacheDelete.js","webpack:///./node_modules/lodash/_isKeyable.js","webpack:///./node_modules/lodash/_mapCacheGet.js","webpack:///./node_modules/lodash/_mapCacheHas.js","webpack:///./node_modules/lodash/_mapCacheSet.js","webpack:///./node_modules/lodash/_SetCache.js","webpack:///./node_modules/lodash/_setCacheAdd.js","webpack:///./node_modules/lodash/_setCacheHas.js","webpack:///./node_modules/lodash/_arraySome.js","webpack:///./node_modules/lodash/_cacheHas.js","webpack:///./node_modules/lodash/_equalByTag.js","webpack:///./node_modules/lodash/_Uint8Array.js","webpack:///./node_modules/lodash/_mapToArray.js","webpack:///./node_modules/lodash/_setToArray.js","webpack:///./node_modules/lodash/_equalObjects.js","webpack:///./node_modules/lodash/_getAllKeys.js","webpack:///./node_modules/lodash/_baseGetAllKeys.js","webpack:///./node_modules/lodash/_getSymbols.js","webpack:///./node_modules/lodash/stubArray.js","webpack:///./node_modules/lodash/_baseTimes.js","webpack:///./node_modules/lodash/_baseFilter.js","webpack:///./node_modules/lodash/_baseForOwn.js","webpack:///./node_modules/lodash/_baseFor.js","webpack:///./node_modules/lodash/_createBaseFor.js","webpack:///./node_modules/lodash/_createBaseEach.js","webpack:///./node_modules/lodash/_baseMatches.js","webpack:///./node_modules/lodash/_baseIsMatch.js","webpack:///./node_modules/lodash/_getMatchData.js","webpack:///./node_modules/lodash/_baseMatchesProperty.js","webpack:///./node_modules/lodash/_stringToPath.js","webpack:///./node_modules/lodash/_memoizeCapped.js","webpack:///./node_modules/lodash/memoize.js","webpack:///./node_modules/lodash/_baseToString.js","webpack:///./node_modules/lodash/hasIn.js","webpack:///./node_modules/lodash/_baseHasIn.js","webpack:///./node_modules/lodash/_hasPath.js","webpack:///./node_modules/lodash/property.js","webpack:///./node_modules/lodash/_baseProperty.js","webpack:///./node_modules/lodash/_basePropertyDeep.js","webpack:///./node_modules/lodash/_createFind.js","webpack:///./node_modules/lodash/findIndex.js","webpack:///./node_modules/lodash/_baseFindIndex.js","webpack:///./node_modules/lodash/toInteger.js","webpack:///./node_modules/lodash/toFinite.js","webpack:///./node_modules/lodash/toNumber.js","webpack:///./node_modules/lodash/_arrayEach.js","webpack:///./node_modules/lodash/_castFunction.js","webpack:///./node_modules/lodash/_baseExtremum.js","webpack:///./node_modules/lodash/_baseLt.js","webpack:///./node_modules/lodash/_baseFlatten.js","webpack:///./node_modules/lodash/_isFlattenable.js","webpack:///./node_modules/lodash/_baseOrderBy.js","webpack:///./node_modules/lodash/_baseSortBy.js","webpack:///./node_modules/lodash/_compareMultiple.js","webpack:///./node_modules/lodash/_compareAscending.js","webpack:///./node_modules/lodash/_overRest.js","webpack:///./node_modules/lodash/_setToString.js","webpack:///./node_modules/lodash/_baseSetToString.js","webpack:///./node_modules/lodash/constant.js","webpack:///./node_modules/lodash/_shortOut.js","webpack:///./node_modules/lodash/assignInWith.js","webpack:///./node_modules/lodash/_copyObject.js","webpack:///./node_modules/lodash/_assignValue.js","webpack:///./node_modules/lodash/_createAssigner.js","webpack:///./node_modules/lodash/keysIn.js","webpack:///./node_modules/lodash/_baseKeysIn.js","webpack:///./node_modules/lodash/_nativeKeysIn.js","webpack:///./node_modules/lodash/attempt.js","webpack:///./node_modules/lodash/isPlainObject.js","webpack:///./node_modules/lodash/_getPrototype.js","webpack:///./node_modules/lodash/_baseValues.js","webpack:///./node_modules/lodash/_customDefaultsAssignIn.js","webpack:///./node_modules/lodash/_escapeStringChar.js","webpack:///./node_modules/lodash/templateSettings.js","webpack:///./node_modules/lodash/escape.js","webpack:///./node_modules/lodash/_escapeHtmlChar.js","webpack:///./node_modules/lodash/_basePropertyOf.js","webpack:///./node_modules/lodash/_reEscape.js","webpack:///./node_modules/lodash/_reEvaluate.js","webpack:///./node_modules/process/browser.js","webpack:///./node_modules/@turf/length/node_modules/@turf/meta/index.js","webpack:///./node_modules/@turf/nearest-point-on-line/node_modules/@turf/bearing/index.js","webpack:///./node_modules/@turf/nearest-point-on-line/node_modules/@turf/destination/index.js","webpack:///./node_modules/@turf/line-intersect/index.js","webpack:///./node_modules/@turf/line-segment/index.js","webpack:///./node_modules/@turf/line-segment/node_modules/@turf/meta/index.js","webpack:///./node_modules/@turf/line-intersect/node_modules/@turf/meta/index.js","webpack:///./node_modules/geojson-rbush/index.js","webpack:///./node_modules/rbush/index.js","webpack:///./node_modules/quickselect/quickselect.js","webpack:///./node_modules/geojson-rbush/node_modules/@turf/meta/index.js","webpack:///./node_modules/@turf/bbox/index.js","webpack:///./node_modules/@turf/bbox/node_modules/@turf/meta/index.js","webpack:///./node_modules/@turf/nearest-point-on-line/node_modules/@turf/meta/index.js","webpack:///./node_modules/@turf/point-to-line-distance/node_modules/@turf/meta/index.js","webpack:///./node_modules/@turf/rhumb-distance/index.js","webpack:///./src/utils/LogBuffer.js","webpack:///./src/Context.js","webpack:///./src/lang/Lang.js","webpack:///./src/Controls.js","webpack:///./node_modules/@turf/meta/node_modules/@turf/helpers/main.es.js","webpack:///./node_modules/@turf/meta/main.es.js","webpack:///./node_modules/@turf/flatten/node_modules/@turf/helpers/main.es.js","webpack:///./node_modules/@turf/flatten/main.es.js","webpack:///./src/utils/helpers.js","webpack:///./src/PathElevation.js","webpack:///./node_modules/@turf/line-slice-along/node_modules/@turf/helpers/main.es.js","webpack:///./node_modules/@turf/line-slice-along/node_modules/@turf/invariant/main.es.js","webpack:///./node_modules/@turf/line-slice-along/node_modules/@turf/bearing/main.es.js","webpack:///./node_modules/@turf/line-slice-along/node_modules/@turf/distance/main.es.js","webpack:///./node_modules/@turf/line-slice-along/node_modules/@turf/destination/main.es.js","webpack:///./node_modules/@turf/line-slice-along/main.es.js","webpack:///./src/Stations.js","webpack:///./src/Route.js","webpack:///./src/routeVerifier.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","root","definition","undefined","noop","undefinedType","logMethods","bindMethod","obj","methodName","method","Function","e","apply","arguments","replaceLoggingMethods","level","loggerName","length","this","methodFactory","log","debug","defaultMethodFactory","console","realMethod","Logger","defaultLevel","factory","currentLevel","self","storageKey","getPersistedLevel","storedLevel","window","localStorage","ignore","cookie","document","location","indexOf","encodeURIComponent","exec","slice","levels","TRACE","DEBUG","INFO","WARN","ERROR","SILENT","getLevel","setLevel","persist","toUpperCase","levelNum","levelName","persistLevelIfPossible","setDefaultLevel","enableAll","disableAll","initialLevel","defaultLogger","_loggersByName","getLogger","TypeError","logger","_log","noConflict","getLoggers","feature","geom","properties","options","feat","type","id","bbox","geometry","point","coordinates","polygon","_i","coordinates_1","ring","Error","j","lineString","featureCollection","features","fc","multiLineString","multiPoint","multiPolygon","radiansToLength","radians","units","factor","factors","lengthToRadians","distance","radiansToDegrees","Math","PI","isNumber","num","isNaN","Array","isArray","test","earthRadius","centimeters","centimetres","degrees","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","yards","unitsFactors","areaFactors","acres","points","map","coords","polygons","lineStrings","geometryCollection","geometries","round","precision","multiplier","pow","lengthToDegrees","bearingToAzimuth","bearing","angle","degreesToRadians","convertLength","originalUnit","finalUnit","convertArea","area","startFactor","finalFactor","isObject","input","constructor","validateBBox","forEach","validateId","radians2degrees","degrees2radians","distanceToDegrees","distanceToRadians","radiansToDistance","bearingToAngle","convertDistance","freeGlobal","freeSelf","helpers_1","getCoord","coord","getCoords","containsNumber","geojsonType","featureOf","collectionOf","_a","getGeom","geojson","getType","baseIsNative","getValue","getRawTag","objectToString","nullTag","undefinedTag","symToStringTag","isFunction","isLength","baseGetTag","isObjectLike","symbolTag","other","arrayLikeKeys","baseKeys","isArrayLike","baseMatches","baseMatchesProperty","identity","invariant_1","default","from","to","coordinates1","coordinates2","dLat","dLon","lat1","lat2","a","sin","cos","atan2","sqrt","baseIsArguments","objectProto","propertyIsEnumerable","isArguments","listCacheClear","listCacheDelete","listCacheGet","listCacheHas","listCacheSet","ListCache","entries","index","clear","entry","set","has","eq","array","nativeCreate","getNative","isKeyable","data","__data__","iteratee","result","isSymbol","INFINITY","Ctor","Map","MAX_SAFE_INTEGER","stubFalse","freeExports","nodeType","freeModule","Buffer","isBuffer","baseIsTypedArray","baseUnary","nodeUtil","nodeIsTypedArray","isTypedArray","baseIsEqualDeep","baseIsEqual","bitmask","customizer","stack","mapCacheClear","mapCacheDelete","mapCacheGet","mapCacheHas","mapCacheSet","MapCache","reIsUint","baseForOwn","baseEach","createBaseEach","baseGet","path","defaultValue","reIsDeepProp","reIsPlainProp","baseToString","overRest","setToString","func","start","isIndex","getTag","isPrototype","mapTag","setTag","splice","tag","size","nativeKeys","push","transform","arg","DataView","Promise","Set","WeakMap","toSource","dataViewCtorString","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","ArrayBuffer","resolve","ctorString","asyncTag","funcTag","genTag","proxyTag","global","funcToString","toString","webpackPolyfill","deprecate","paths","children","stackClear","stackDelete","stackGet","stackHas","stackSet","Stack","SetCache","arraySome","cacheHas","COMPARE_PARTIAL_FLAG","COMPARE_UNORDERED_FLAG","equalFunc","isPartial","arrLength","othLength","stacked","seen","arrValue","othValue","compared","othIndex","values","offset","predicate","resIndex","baseTimes","inherited","isArr","isArg","isBuff","isType","skipIndexes","String","arrayFilter","baseFilter","baseIteratee","collection","srcValue","castPath","toKey","isKey","stringToPath","find","createFind","arrayEach","castFunction","arrayMap","baseMap","baseExtremum","baseLt","baseFlatten","baseOrderBy","baseRest","isIterateeCall","sortBy","iteratees","thisArg","args","assignInWith","attempt","baseValues","customDefaultsAssignIn","escapeStringChar","isError","keys","reInterpolate","templateSettings","reEmptyStringLeading","reEmptyStringMiddle","reEmptyStringTrailing","reEsTemplate","reNoMatch","reUnescapedString","string","guard","settings","imports","_","isEscaping","isEvaluating","importsKeys","importsValues","interpolate","source","reDelimiters","RegExp","escape","evaluate","sourceURL","replace","match","escapeValue","interpolateValue","esTemplateValue","evaluateValue","variable","configurable","writable","isPlainObject","domExcTag","errorTag","message","process","toGeoJSON","serializer","removeSpace","trimSpace","splitSpace","okhash","x","h","charCodeAt","y","getElementsByTagName","attr","getAttribute","attrf","parseFloat","get1","numarray","nodeVal","el","normalize","textContent","getMulti","ys","k","extend","coord1","v","split","coordPair","ll","ele","heartRate","time","xml2str","str","xml","serializeToString","XMLSerializer","browser","kml","doc","gj","styleIndex","styleByHash","styleMapIndex","geotypes","placemarks","styles","styleMaps","hash","pairs","pairsMap","concat","getPlacemark","kmlColor","color","opacity","substr","parseInt","gxCoords","elems","times","timeElems","geomsAndTimes","getGeometry","geomNode","geomNodes","geoms","coordTimes","rings","track","styleUrl","description","timeSpan","timeStamp","extendedData","lineStyle","polyStyle","visibility","styleHash","styleMapHash","normal","style","begin","end","timespan","timestamp","linestyles","width","stroke","polystyles","pcolor","popacity","fill","outline","datas","simpleDatas","gpx","tracks","routes","waypoints","getTrack","getRoute","getPoint","getPoints","node","pointname","pts","line","heartRates","segments","getProperties","prop","links","link","href","__importDefault","mod","distance_1","meta_1","segmentReduce","previousValue","segment","bearing_1","destination_1","line_intersect_1","lines","pt","closestPt","Infinity","dist","flattenEach","stop_1","sectionLength","heightDistance","max","direction","perpendicularPt1","perpendicularPt2","intersect","intersectPt","rhumb_distance_1","dot","u","calcDistance","b","segmentEach","c1","c2","b2","Pb","distanceToSegment","overArg","isMasked","reIsHostCtor","funcProto","reIsNative","g","nativeObjectToString","isOwn","unmasked","uid","coreJsData","maskSrcKey","IE_PROTO","argsTag","typedArrayTags","freeProcess","types","require","binding","equalArrays","equalByTag","equalObjects","arrayTag","objectTag","objIsArr","othIsArr","objTag","othTag","objIsObj","othIsObj","isSameTag","objIsWrapped","othIsWrapped","objUnwrapped","othUnwrapped","assocIndexOf","pop","LARGE_ARRAY_SIZE","Hash","hashClear","hashDelete","hashGet","hashHas","hashSet","HASH_UNDEFINED","getMapData","setCacheAdd","setCacheHas","add","cache","Uint8Array","mapToArray","setToArray","boolTag","dateTag","numberTag","regexpTag","stringTag","arrayBufferTag","dataViewTag","symbolProto","symbolValueOf","valueOf","byteLength","byteOffset","buffer","convert","getAllKeys","objProps","objLength","skipCtor","objValue","objCtor","othCtor","baseGetAllKeys","getSymbols","arrayPush","keysFunc","symbolsFunc","stubArray","nativeGetSymbols","getOwnPropertySymbols","symbol","baseFor","createBaseFor","fromRight","iterable","props","eachFunc","baseIsMatch","getMatchData","matchesStrictComparable","matchData","noCustomizer","isStrictComparable","hasIn","memoizeCapped","rePropName","reEscapeChar","number","quote","subString","memoize","MAX_MEMOIZE_SIZE","FUNC_ERROR_TEXT","resolver","memoized","Cache","symbolToString","baseHasIn","hasPath","hasFunc","baseProperty","basePropertyDeep","findIndexFunc","fromIndex","baseFindIndex","toInteger","nativeMax","toFinite","remainder","toNumber","MAX_INTEGER","NAN","reTrim","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","isBinary","comparator","current","computed","isFlattenable","depth","isStrict","spreadableSymbol","isConcatSpreadable","baseSortBy","compareMultiple","orders","criteria","comparer","sort","compareAscending","objCriteria","othCriteria","ordersLength","valIsDefined","valIsNull","valIsReflexive","valIsSymbol","othIsDefined","othIsNull","othIsReflexive","othIsSymbol","otherArgs","baseSetToString","shortOut","constant","HOT_COUNT","HOT_SPAN","nativeNow","Date","now","count","lastCalled","stamp","remaining","copyObject","createAssigner","keysIn","srcIndex","assignValue","baseAssignValue","isNew","newValue","assigner","sources","baseKeysIn","nativeKeysIn","isProto","getPrototype","objectCtorString","proto","getPrototypeOf","stringEscapes","\\","'","\n","\r"," "," ","chr","escapeHtmlChar","reUnescapedHtml","reHasUnescapedHtml","basePropertyOf","&","<",">","\"","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","len","run","marker","runClearTimeout","Item","nextTick","title","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","cwd","chdir","dir","umask","helpers","coordEach","callback","excludeWrapCoord","stopG","geometryMaybeCollection","isGeometryCollection","wrapShrink","coordIndex","isFeatureCollection","isFeature","stop","featureIndex","geomIndex","multiFeatureIndex","geometryIndex","geomType","propEach","featureEach","geomEach","featureProperties","featureBBox","featureId","segmentIndex","previousCoords","previousFeatureIndex","previousMultiIndex","prevGeomIndex","currentCoord","featureIndexCoord","multiPartIndexCoord","currentSegment","lineEach","coordReduce","initialValue","propReduce","currentProperties","featureReduce","currentFeature","coordAll","geomReduce","currentGeometry","flattenReduce","started","lineReduce","currentLine","findSegment","findPoint","final","bear","calculateFinalBearing","lon1","lon2","origin","longitude1","latitude1","bearingRad","latitude2","asin","longitude2","lng","lat","line_segment_1","geojson_rbush_1","intersects","line1","line2","coords1","coords2","x1","y1","x2","y2","x3","y3","x4","y4","denom","numeA","numeB","uA","uB","unique","results","tree","load","search","join","reduce","currentCoords","createSegments","lineSegmentFeature","rbush","meta","turfBBox","geojsonRbush","maxEntries","insert","remove","equals","toBBox","collides","all","toJSON","fromJSON","json","minX","minY","maxX","maxY","quickselect","format","_maxEntries","_minEntries","ceil","_initFormat","findItem","item","items","equalsFn","calcBBox","distBBox","destNode","createNode","child","leaf","min","compareNodeMinX","compareNodeMinY","bboxArea","bboxMargin","contains","height","multiSelect","arr","left","right","compare","mid","_all","childBBox","nodesToSearch","_build","_splitRoot","tmpNode","_insert","parent","goingUp","indexes","_condense","compareMinX","compareMinY","N","M","right2","right3","N2","N1","_chooseSubtree","targetNode","enlargement","minArea","minEnlargement","isNode","insertPath","_split","_adjustParentBBoxes","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","bbox1","bbox2","overlap","minOverlap","_allDistMargin","leftBBox","rightBBox","margin","siblings","compareArr","swap","tmp","defaultCompare","quickselectStep","z","exp","sd","newLeft","floor","newRight","destination","distanceInMeters","radius","R","Number","phi1","phi2","DeltaPhi","DeltaLambda","abs","DeltaPsi","tan","q","calculateRhumbDistance","instance","LogBuffer","_classCallCheck","Context","mapCanvasElement","$","routeUrl","routeParamsUrl","routeApproveUrl","language","translations","pl","en","Lang","Lang_classCallCheck","translation","literal","translatedLiteral","warn","updateControlColor","element","isValid","VALID_COLOR_CLASS","INVALID_COLOR_CLASS","removeClass","addClass","updateControlValue","unit","html","Controls","isNormalRoute","normalRouteString","inspiredRouteString","isLengthValid","toFixed","isElevationGainValid","elevationGain","isElevationLossValid","elevationLoss","isElevationTotalChangeValid","elevationTotalChange","areAllStationsPresent","isStationOrderCorrect","areAllStationsOnPath","isSinglePath","isDataConsistent","pathElevation","labelWidth","labels","elevation","Chart","datasets","label","backgroundColor","scales","xAxes","scaleLabel","display","labelString","ticks","dataLabel","yAxes","legend","tooltips","enabled","elevationChartParentElement","append","FAILED_VERIFICATION_MODAL_ID","VERIFY_BUTTON_ID","resetElevationChart","resetFailedVerificationModal","reloadTimeout","reload","modal","errors","errorsListHtml","error","main_es_feature","coordinate","main_es_featureCollection","main_es_isObject","main_es_validateBBox","main_es_validateId","main_es_isNumber","main_es","Helpers","parentNode","removeChild","geoJson","flatten","featureName","MAX_VALUE","newLineString","reverse","reject","ajax","done","fail","xhr","status","google","maps","LatLng","getGoogleMapsLatLng","useLocalElevations","elevations","getGoogleMapsPath","optimizedPath","delta","ElevationService","getElevationAlongPath","samples","ElevationStatus","OK","success","getGain","elevationDifference","getLoss","PathElevation","PathElevation_classCallCheck","gain","loss","totalChange","elevationsWithDistance","resolution","helpers_main_es_factors","helpers_main_es_earthRadius","_turf_helpers_main_es_feature","helpers_main_es_isObject","helpers_main_es_validateBBox","helpers_main_es_validateId","_turf_helpers_main_es_point","helpers_main_es_isNumber","_turf_helpers_main_es_lineString","helpers_main_es_radiansToLength","helpers_main_es_lengthToRadians","helpers_main_es_radiansToDegrees","helpers_main_es_degreesToRadians","main_es_bearing","bearing_main_es","distance_main_es","destination_main_es","bearing_rad","line_slice_along_main_es","startDist","stopDist","overshot","interpolated","travelled","turf","lineSliceAlong","pointToLineDistance","nearestPointOnLine","CONSTS","lang","logBuffer","Stations","Stations_classCallCheck","pathReversed","pathCircular","addIndexes","sortByIndex","pathStart","pathEnd","updateCircularity","updateDirection","findNearestPointsOnPath","sortByLocationOnPath","getInstance","_this","stepDistance","sampleDistance","nearestPointOnSlicedPath","nearestOnLine","startPointDistance","stopPointDistance","oldDistanceToPath","newDistanceToPath","slicedPath","addDebugInformationToMap","originalPoint","nearestPoint","Marker","position","fontWeight","text","icon","getIndex","getLocation","START_NAMES_REGEX","END_NAMES_REGEX","ROMAN_NUMBERS_REGEX","EUROPEAN_NUMBERS_REGEX","ROMAN_EUROPEAN_MAP","I","II","III","IV","V","VI","VII","VIII","IX","X","XI","XII","XIII","XIV","parts","trim","part","matches","stationNumber","isIndexEqual","startPoint","endPoint","endPointToPathStartDistance","reverseLineString","_this2","numberOfStations","_loop","firstStationName","stationsOfNumber","station","trans","currentStationNumber","previousStationNumber","maximumDistanceFromPath","distanceFromStationToPath","getDistanceToNearestPointOnLine","maximumDistance","lastStationPoint","lastStationLocation","getLocationOfNearestPointOnLine","Route","Route_classCallCheck","getLineString","isRouteVerifiable","stations","getUpdatedPath","numberOfPaths","getNumberOfFeatures","getCount","areAllOnThePath","isOrderCorrect","googleMapsPath","spherical","computeLength","getPathElevations","then","catch","NORMAL_ROUTE_MIN_LENGTH","SHORT_NORMAL_ROUTE_MIN_LENGTH","SHORT_NORMAL_ROUTE_MIN_ELEVATION_GAIN","GOOGLE_MAPS_API_LOADED","gm_authFailure","setLogLevel","logLevel","context","controls","routeSuccessfullyVerified","route","routeLength","isPathLengthValid","areStationsOnThePath","isPathElevationGainValid","isPathElevationLossValid","isPathElevationTotalChangeValid","resetAll","cleanLogs","addLoaderToButton","getGeoJSON","isVerifiable","updateSinglePath","getPathLength","updatePathLength","updateNumberOfStations","updateStationsOrder","updateStationsOnPath","fetchPathElevationData","getPathElevation","enrichData","updateElevationGain","updateRouteType","updateElevationLoss","updateElevationTotalChange","drawElevationChart","getRouteParameters","parameters","isLengthConsistent","isElevationGainConsistent","ascent","isRouteTypeConsistent","updateDataConsistency","finally","removeLoaderFromButton","info","approveRoute","showVerificationSuccessModal","showVerificationFailedModal","getLogs"],"mappings":"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","file":"edk-route-verifier.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 208);\n","/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      var storageKey = \"loglevel\";\n      if (name) {\n        storageKey += \":\" + name;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"string\" || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    return defaultLogger;\n}));\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.370,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.370,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, options) {\n    if (options === void 0) { options = {}; }\n    switch (type) {\n        case \"Point\": return point(coordinates).geometry;\n        case \"LineString\": return lineString(coordinates).geometry;\n        case \"Polygon\": return polygon(coordinates).geometry;\n        case \"MultiPoint\": return multiPoint(coordinates).geometry;\n        case \"MultiLineString\": return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\": return multiPolygon(coordinates).geometry;\n        default: throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\\s*$/.test(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error(\"method has been renamed to `radiansToDegrees`\");\n}\nexports.radians2degrees = radians2degrees;\nfunction degrees2radians() {\n    throw new Error(\"method has been renamed to `degreesToRadians`\");\n}\nexports.degrees2radians = degrees2radians;\nfunction distanceToDegrees() {\n    throw new Error(\"method has been renamed to `lengthToDegrees`\");\n}\nexports.distanceToDegrees = distanceToDegrees;\nfunction distanceToRadians() {\n    throw new Error(\"method has been renamed to `lengthToRadians`\");\n}\nexports.distanceToRadians = distanceToRadians;\nfunction radiansToDistance() {\n    throw new Error(\"method has been renamed to `radiansToLength`\");\n}\nexports.radiansToDistance = radiansToDistance;\nfunction bearingToAngle() {\n    throw new Error(\"method has been renamed to `bearingToAzimuth`\");\n}\nexports.bearingToAngle = bearingToAngle;\nfunction convertDistance() {\n    throw new Error(\"method has been renamed to `convertLength`\");\n}\nexports.convertDistance = convertDistance;\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"@turf/helpers\");\r\n/**\r\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\r\n *\r\n * @name getCoord\r\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\r\n * @returns {Array<number>} coordinates\r\n * @example\r\n * var pt = turf.point([10, 10]);\r\n *\r\n * var coord = turf.getCoord(pt);\r\n * //= [10, 10]\r\n */\r\nfunction getCoord(coord) {\r\n    if (!coord) {\r\n        throw new Error(\"coord is required\");\r\n    }\r\n    if (!Array.isArray(coord)) {\r\n        if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\r\n            return coord.geometry.coordinates;\r\n        }\r\n        if (coord.type === \"Point\") {\r\n            return coord.coordinates;\r\n        }\r\n    }\r\n    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\r\n        return coord;\r\n    }\r\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\r\n}\r\nexports.getCoord = getCoord;\r\n/**\r\n * Unwrap coordinates from a Feature, Geometry Object or an Array\r\n *\r\n * @name getCoords\r\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\r\n * @returns {Array<any>} coordinates\r\n * @example\r\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\r\n *\r\n * var coords = turf.getCoords(poly);\r\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\r\n */\r\nfunction getCoords(coords) {\r\n    if (Array.isArray(coords)) {\r\n        return coords;\r\n    }\r\n    // Feature\r\n    if (coords.type === \"Feature\") {\r\n        if (coords.geometry !== null) {\r\n            return coords.geometry.coordinates;\r\n        }\r\n    }\r\n    else {\r\n        // Geometry\r\n        if (coords.coordinates) {\r\n            return coords.coordinates;\r\n        }\r\n    }\r\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\r\n}\r\nexports.getCoords = getCoords;\r\n/**\r\n * Checks if coordinates contains a number\r\n *\r\n * @name containsNumber\r\n * @param {Array<any>} coordinates GeoJSON Coordinates\r\n * @returns {boolean} true if Array contains a number\r\n */\r\nfunction containsNumber(coordinates) {\r\n    if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\r\n        return containsNumber(coordinates[0]);\r\n    }\r\n    throw new Error(\"coordinates must only contain numbers\");\r\n}\r\nexports.containsNumber = containsNumber;\r\n/**\r\n * Enforce expectations about types of GeoJSON objects for Turf.\r\n *\r\n * @name geojsonType\r\n * @param {GeoJSON} value any GeoJSON object\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction geojsonType(value, type, name) {\r\n    if (!type || !name) {\r\n        throw new Error(\"type and name required\");\r\n    }\r\n    if (!value || value.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type);\r\n    }\r\n}\r\nexports.geojsonType = geojsonType;\r\n/**\r\n * Enforce expectations about types of {@link Feature} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name featureOf\r\n * @param {Feature} feature a feature with an expected geometry type\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} error if value is not the expected type.\r\n */\r\nfunction featureOf(feature, type, name) {\r\n    if (!feature) {\r\n        throw new Error(\"No feature passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".featureOf() requires a name\");\r\n    }\r\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n    }\r\n    if (!feature.geometry || feature.geometry.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n    }\r\n}\r\nexports.featureOf = featureOf;\r\n/**\r\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name collectionOf\r\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction collectionOf(featureCollection, type, name) {\r\n    if (!featureCollection) {\r\n        throw new Error(\"No featureCollection passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".collectionOf() requires a name\");\r\n    }\r\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\r\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\r\n    }\r\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\r\n        var feature = _a[_i];\r\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n        }\r\n        if (!feature.geometry || feature.geometry.type !== type) {\r\n            throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n        }\r\n    }\r\n}\r\nexports.collectionOf = collectionOf;\r\n/**\r\n * Get Geometry from Feature or Geometry Object\r\n *\r\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\r\n * @returns {Geometry|null} GeoJSON Geometry Object\r\n * @throws {Error} if geojson is not a Feature or Geometry Object\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getGeom(point)\r\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\r\n */\r\nfunction getGeom(geojson) {\r\n    if (geojson.type === \"Feature\") {\r\n        return geojson.geometry;\r\n    }\r\n    return geojson;\r\n}\r\nexports.getGeom = getGeom;\r\n/**\r\n * Get GeoJSON object's type, Geometry type is prioritize.\r\n *\r\n * @param {GeoJSON} geojson GeoJSON object\r\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\r\n * @returns {string} GeoJSON type\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getType(point)\r\n * //=\"Point\"\r\n */\r\nfunction getType(geojson, name) {\r\n    if (geojson.type === \"FeatureCollection\") {\r\n        return \"FeatureCollection\";\r\n    }\r\n    if (geojson.type === \"GeometryCollection\") {\r\n        return \"GeometryCollection\";\r\n    }\r\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\r\n        return geojson.geometry.type;\r\n    }\r\n    return geojson.type;\r\n}\r\nexports.getType = getType;\r\n","var baseIsNative = require('./_baseIsNative'),\n    getValue = require('./_getValue');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var isFunction = require('./isFunction'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeys = require('./_baseKeys'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n","var baseMatches = require('./_baseMatches'),\n    baseMatchesProperty = require('./_baseMatchesProperty'),\n    identity = require('./identity'),\n    isArray = require('./isArray'),\n    property = require('./property');\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\nmodule.exports = baseIteratee;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar invariant_1 = require(\"@turf/invariant\");\nvar helpers_1 = require(\"@turf/helpers\");\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians, miles, or kilometers.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name distance\n * @param {Coord} from origin point\n * @param {Coord} to destination point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.distance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n    if (options === void 0) { options = {}; }\n    var coordinates1 = invariant_1.getCoord(from);\n    var coordinates2 = invariant_1.getCoord(to);\n    var dLat = helpers_1.degreesToRadians((coordinates2[1] - coordinates1[1]));\n    var dLon = helpers_1.degreesToRadians((coordinates2[0] - coordinates1[0]));\n    var lat1 = helpers_1.degreesToRadians(coordinates1[1]);\n    var lat2 = helpers_1.degreesToRadians(coordinates2[1]);\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n        Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n    return helpers_1.radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);\n}\nexports.default = distance;\n","var baseIsArguments = require('./_baseIsArguments'),\n    isObjectLike = require('./isObjectLike');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n","var listCacheClear = require('./_listCacheClear'),\n    listCacheDelete = require('./_listCacheDelete'),\n    listCacheGet = require('./_listCacheGet'),\n    listCacheHas = require('./_listCacheHas'),\n    listCacheSet = require('./_listCacheSet');\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n","var eq = require('./eq');\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n","var getNative = require('./_getNative');\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n","var isKeyable = require('./_isKeyable');\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n","/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n","var isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = toKey;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n","var root = require('./_root'),\n    stubFalse = require('./stubFalse');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n","var baseIsTypedArray = require('./_baseIsTypedArray'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n","var baseIsEqualDeep = require('./_baseIsEqualDeep'),\n    isObjectLike = require('./isObjectLike');\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\nmodule.exports = baseIsEqual;\n","var mapCacheClear = require('./_mapCacheClear'),\n    mapCacheDelete = require('./_mapCacheDelete'),\n    mapCacheGet = require('./_mapCacheGet'),\n    mapCacheHas = require('./_mapCacheHas'),\n    mapCacheSet = require('./_mapCacheSet');\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n","var baseForOwn = require('./_baseForOwn'),\n    createBaseEach = require('./_createBaseEach');\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\nmodule.exports = baseEach;\n","var baseGet = require('./_baseGet');\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n","var isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nmodule.exports = isKey;\n","var baseToString = require('./_baseToString');\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nmodule.exports = toString;\n","var identity = require('./identity'),\n    overRest = require('./_overRest'),\n    setToString = require('./_setToString');\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\nmodule.exports = baseRest;\n","var eq = require('./eq'),\n    isArrayLike = require('./isArrayLike'),\n    isIndex = require('./_isIndex'),\n    isObject = require('./isObject');\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\nmodule.exports = isIterateeCall;\n","var baseKeys = require('./_baseKeys'),\n    getTag = require('./_getTag'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isArrayLike = require('./isArrayLike'),\n    isBuffer = require('./isBuffer'),\n    isPrototype = require('./_isPrototype'),\n    isTypedArray = require('./isTypedArray');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    setTag = '[object Set]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if `value` is an empty object, collection, map, or set.\n *\n * Objects are considered empty if they have no own enumerable string keyed\n * properties.\n *\n * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n * jQuery-like collections are considered empty if they have a `length` of `0`.\n * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n * @example\n *\n * _.isEmpty(null);\n * // => true\n *\n * _.isEmpty(true);\n * // => true\n *\n * _.isEmpty(1);\n * // => true\n *\n * _.isEmpty([1, 2, 3]);\n * // => false\n *\n * _.isEmpty({ 'a': 1 });\n * // => false\n */\nfunction isEmpty(value) {\n  if (value == null) {\n    return true;\n  }\n  if (isArrayLike(value) &&\n      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n        isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n    return !value.length;\n  }\n  var tag = getTag(value);\n  if (tag == mapTag || tag == setTag) {\n    return !value.size;\n  }\n  if (isPrototype(value)) {\n    return !baseKeys(value).length;\n  }\n  for (var key in value) {\n    if (hasOwnProperty.call(value, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = isEmpty;\n","var isPrototype = require('./_isPrototype'),\n    nativeKeys = require('./_nativeKeys');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n","var DataView = require('./_DataView'),\n    Map = require('./_Map'),\n    Promise = require('./_Promise'),\n    Set = require('./_Set'),\n    WeakMap = require('./_WeakMap'),\n    baseGetTag = require('./_baseGetTag'),\n    toSource = require('./_toSource');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nmodule.exports = getTag;\n","var baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n","var baseIsEqual = require('./_baseIsEqual');\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\nmodule.exports = isEqual;\n","var ListCache = require('./_ListCache'),\n    stackClear = require('./_stackClear'),\n    stackDelete = require('./_stackDelete'),\n    stackGet = require('./_stackGet'),\n    stackHas = require('./_stackHas'),\n    stackSet = require('./_stackSet');\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nmodule.exports = Stack;\n","var SetCache = require('./_SetCache'),\n    arraySome = require('./_arraySome'),\n    cacheHas = require('./_cacheHas');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalArrays;\n","/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n","/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayFilter;\n","var baseTimes = require('./_baseTimes'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isIndex = require('./_isIndex'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n","/**\n * Checks if `value` is `null`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n * @example\n *\n * _.isNull(null);\n * // => true\n *\n * _.isNull(void 0);\n * // => false\n */\nfunction isNull(value) {\n  return value === null;\n}\n\nmodule.exports = isNull;\n","var arrayFilter = require('./_arrayFilter'),\n    baseFilter = require('./_baseFilter'),\n    baseIteratee = require('./_baseIteratee'),\n    isArray = require('./isArray');\n\n/**\n * Iterates over elements of `collection`, returning an array of all elements\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * **Note:** Unlike `_.remove`, this method returns a new array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n * @see _.reject\n * @example\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': true },\n *   { 'user': 'fred',   'age': 40, 'active': false }\n * ];\n *\n * _.filter(users, function(o) { return !o.active; });\n * // => objects for ['fred']\n *\n * // The `_.matches` iteratee shorthand.\n * _.filter(users, { 'age': 36, 'active': true });\n * // => objects for ['barney']\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.filter(users, ['active', false]);\n * // => objects for ['fred']\n *\n * // The `_.property` iteratee shorthand.\n * _.filter(users, 'active');\n * // => objects for ['barney']\n */\nfunction filter(collection, predicate) {\n  var func = isArray(collection) ? arrayFilter : baseFilter;\n  return func(collection, baseIteratee(predicate, 3));\n}\n\nmodule.exports = filter;\n","var isObject = require('./isObject');\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\nmodule.exports = isStrictComparable;\n","/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\nmodule.exports = matchesStrictComparable;\n","var castPath = require('./_castPath'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n","var isArray = require('./isArray'),\n    isKey = require('./_isKey'),\n    stringToPath = require('./_stringToPath'),\n    toString = require('./toString');\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nmodule.exports = castPath;\n","var createFind = require('./_createFind'),\n    findIndex = require('./findIndex');\n\n/**\n * Iterates over elements of `collection`, returning the first element\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {*} Returns the matched element, else `undefined`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'age': 36, 'active': true },\n *   { 'user': 'fred',    'age': 40, 'active': false },\n *   { 'user': 'pebbles', 'age': 1,  'active': true }\n * ];\n *\n * _.find(users, function(o) { return o.age < 40; });\n * // => object for 'barney'\n *\n * // The `_.matches` iteratee shorthand.\n * _.find(users, { 'age': 1, 'active': true });\n * // => object for 'pebbles'\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.find(users, ['active', false]);\n * // => object for 'fred'\n *\n * // The `_.property` iteratee shorthand.\n * _.find(users, 'active');\n * // => object for 'barney'\n */\nvar find = createFind(findIndex);\n\nmodule.exports = find;\n","var arrayEach = require('./_arrayEach'),\n    baseEach = require('./_baseEach'),\n    castFunction = require('./_castFunction'),\n    isArray = require('./isArray');\n\n/**\n * Iterates over elements of `collection` and invokes `iteratee` for each element.\n * The iteratee is invoked with three arguments: (value, index|key, collection).\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n * property are iterated like arrays. To avoid this behavior use `_.forIn`\n * or `_.forOwn` for object iteration.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @alias each\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n * @see _.forEachRight\n * @example\n *\n * _.forEach([1, 2], function(value) {\n *   console.log(value);\n * });\n * // => Logs `1` then `2`.\n *\n * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n *   console.log(key);\n * });\n * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n */\nfunction forEach(collection, iteratee) {\n  var func = isArray(collection) ? arrayEach : baseEach;\n  return func(collection, castFunction(iteratee));\n}\n\nmodule.exports = forEach;\n","var arrayMap = require('./_arrayMap'),\n    baseIteratee = require('./_baseIteratee'),\n    baseMap = require('./_baseMap'),\n    isArray = require('./isArray');\n\n/**\n * Creates an array of values by running each element in `collection` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n *\n * The guarded methods are:\n * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n * @example\n *\n * function square(n) {\n *   return n * n;\n * }\n *\n * _.map([4, 8], square);\n * // => [16, 64]\n *\n * _.map({ 'a': 4, 'b': 8 }, square);\n * // => [16, 64] (iteration order is not guaranteed)\n *\n * var users = [\n *   { 'user': 'barney' },\n *   { 'user': 'fred' }\n * ];\n *\n * // The `_.property` iteratee shorthand.\n * _.map(users, 'user');\n * // => ['barney', 'fred']\n */\nfunction map(collection, iteratee) {\n  var func = isArray(collection) ? arrayMap : baseMap;\n  return func(collection, baseIteratee(iteratee, 3));\n}\n\nmodule.exports = map;\n","var baseEach = require('./_baseEach'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\nmodule.exports = baseMap;\n","var baseExtremum = require('./_baseExtremum'),\n    baseLt = require('./_baseLt'),\n    identity = require('./identity');\n\n/**\n * Computes the minimum value of `array`. If `array` is empty or falsey,\n * `undefined` is returned.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {*} Returns the minimum value.\n * @example\n *\n * _.min([4, 2, 8, 6]);\n * // => 2\n *\n * _.min([]);\n * // => undefined\n */\nfunction min(array) {\n  return (array && array.length)\n    ? baseExtremum(array, identity, baseLt)\n    : undefined;\n}\n\nmodule.exports = min;\n","var baseFlatten = require('./_baseFlatten'),\n    baseOrderBy = require('./_baseOrderBy'),\n    baseRest = require('./_baseRest'),\n    isIterateeCall = require('./_isIterateeCall');\n\n/**\n * Creates an array of elements, sorted in ascending order by the results of\n * running each element in a collection thru each iteratee. This method\n * performs a stable sort, that is, it preserves the original sort order of\n * equal elements. The iteratees are invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {...(Function|Function[])} [iteratees=[_.identity]]\n *  The iteratees to sort by.\n * @returns {Array} Returns the new sorted array.\n * @example\n *\n * var users = [\n *   { 'user': 'fred',   'age': 48 },\n *   { 'user': 'barney', 'age': 36 },\n *   { 'user': 'fred',   'age': 40 },\n *   { 'user': 'barney', 'age': 34 }\n * ];\n *\n * _.sortBy(users, [function(o) { return o.user; }]);\n * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n *\n * _.sortBy(users, ['user', 'age']);\n * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]\n */\nvar sortBy = baseRest(function(collection, iteratees) {\n  if (collection == null) {\n    return [];\n  }\n  var length = iteratees.length;\n  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n    iteratees = [];\n  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n    iteratees = [iteratees[0]];\n  }\n  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n});\n\nmodule.exports = sortBy;\n","/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\nmodule.exports = apply;\n","var getNative = require('./_getNative');\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nmodule.exports = defineProperty;\n","var assignInWith = require('./assignInWith'),\n    attempt = require('./attempt'),\n    baseValues = require('./_baseValues'),\n    customDefaultsAssignIn = require('./_customDefaultsAssignIn'),\n    escapeStringChar = require('./_escapeStringChar'),\n    isError = require('./isError'),\n    isIterateeCall = require('./_isIterateeCall'),\n    keys = require('./keys'),\n    reInterpolate = require('./_reInterpolate'),\n    templateSettings = require('./templateSettings'),\n    toString = require('./toString');\n\n/** Used to match empty string literals in compiled template source. */\nvar reEmptyStringLeading = /\\b__p \\+= '';/g,\n    reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n    reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\n/**\n * Used to match\n * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).\n */\nvar reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n/** Used to ensure capturing order of template delimiters. */\nvar reNoMatch = /($^)/;\n\n/** Used to match unescaped characters in compiled string literals. */\nvar reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n\n/**\n * Creates a compiled template function that can interpolate data properties\n * in \"interpolate\" delimiters, HTML-escape interpolated data properties in\n * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\n * properties may be accessed as free variables in the template. If a setting\n * object is given, it takes precedence over `_.templateSettings` values.\n *\n * **Note:** In the development build `_.template` utilizes\n * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\n * for easier debugging.\n *\n * For more information on precompiling templates see\n * [lodash's custom builds documentation](https://lodash.com/custom-builds).\n *\n * For more information on Chrome extension sandboxes see\n * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category String\n * @param {string} [string=''] The template string.\n * @param {Object} [options={}] The options object.\n * @param {RegExp} [options.escape=_.templateSettings.escape]\n *  The HTML \"escape\" delimiter.\n * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]\n *  The \"evaluate\" delimiter.\n * @param {Object} [options.imports=_.templateSettings.imports]\n *  An object to import into the template as free variables.\n * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]\n *  The \"interpolate\" delimiter.\n * @param {string} [options.sourceURL='templateSources[n]']\n *  The sourceURL of the compiled template.\n * @param {string} [options.variable='obj']\n *  The data object variable name.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Function} Returns the compiled template function.\n * @example\n *\n * // Use the \"interpolate\" delimiter to create a compiled template.\n * var compiled = _.template('hello <%= user %>!');\n * compiled({ 'user': 'fred' });\n * // => 'hello fred!'\n *\n * // Use the HTML \"escape\" delimiter to escape data property values.\n * var compiled = _.template('<b><%- value %></b>');\n * compiled({ 'value': '<script>' });\n * // => '<b>&lt;script&gt;</b>'\n *\n * // Use the \"evaluate\" delimiter to execute JavaScript and generate HTML.\n * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\n * compiled({ 'users': ['fred', 'barney'] });\n * // => '<li>fred</li><li>barney</li>'\n *\n * // Use the internal `print` function in \"evaluate\" delimiters.\n * var compiled = _.template('<% print(\"hello \" + user); %>!');\n * compiled({ 'user': 'barney' });\n * // => 'hello barney!'\n *\n * // Use the ES template literal delimiter as an \"interpolate\" delimiter.\n * // Disable support by replacing the \"interpolate\" delimiter.\n * var compiled = _.template('hello ${ user }!');\n * compiled({ 'user': 'pebbles' });\n * // => 'hello pebbles!'\n *\n * // Use backslashes to treat delimiters as plain text.\n * var compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\n * compiled({ 'value': 'ignored' });\n * // => '<%- value %>'\n *\n * // Use the `imports` option to import `jQuery` as `jq`.\n * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\n * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });\n * compiled({ 'users': ['fred', 'barney'] });\n * // => '<li>fred</li><li>barney</li>'\n *\n * // Use the `sourceURL` option to specify a custom sourceURL for the template.\n * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\n * compiled(data);\n * // => Find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector.\n *\n * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.\n * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\n * compiled.source;\n * // => function(data) {\n * //   var __t, __p = '';\n * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\n * //   return __p;\n * // }\n *\n * // Use custom template delimiters.\n * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\n * var compiled = _.template('hello {{ user }}!');\n * compiled({ 'user': 'mustache' });\n * // => 'hello mustache!'\n *\n * // Use the `source` property to inline compiled templates for meaningful\n * // line numbers in error messages and stack traces.\n * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\\\n *   var JST = {\\\n *     \"main\": ' + _.template(mainText).source + '\\\n *   };\\\n * ');\n */\nfunction template(string, options, guard) {\n  // Based on John Resig's `tmpl` implementation\n  // (http://ejohn.org/blog/javascript-micro-templating/)\n  // and Laura Doktorova's doT.js (https://github.com/olado/doT).\n  var settings = templateSettings.imports._.templateSettings || templateSettings;\n\n  if (guard && isIterateeCall(string, options, guard)) {\n    options = undefined;\n  }\n  string = toString(string);\n  options = assignInWith({}, options, settings, customDefaultsAssignIn);\n\n  var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),\n      importsKeys = keys(imports),\n      importsValues = baseValues(imports, importsKeys);\n\n  var isEscaping,\n      isEvaluating,\n      index = 0,\n      interpolate = options.interpolate || reNoMatch,\n      source = \"__p += '\";\n\n  // Compile the regexp to match each delimiter.\n  var reDelimiters = RegExp(\n    (options.escape || reNoMatch).source + '|' +\n    interpolate.source + '|' +\n    (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n    (options.evaluate || reNoMatch).source + '|$'\n  , 'g');\n\n  // Use a sourceURL for easier debugging.\n  var sourceURL = 'sourceURL' in options ? '//# sourceURL=' + options.sourceURL + '\\n' : '';\n\n  string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n    interpolateValue || (interpolateValue = esTemplateValue);\n\n    // Escape characters that can't be included in string literals.\n    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\n    // Replace delimiters with snippets.\n    if (escapeValue) {\n      isEscaping = true;\n      source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n    }\n    if (evaluateValue) {\n      isEvaluating = true;\n      source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n    }\n    if (interpolateValue) {\n      source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n    }\n    index = offset + match.length;\n\n    // The JS engine embedded in Adobe products needs `match` returned in\n    // order to produce the correct `offset` value.\n    return match;\n  });\n\n  source += \"';\\n\";\n\n  // If `variable` is not specified wrap a with-statement around the generated\n  // code to add the data object to the top of the scope chain.\n  var variable = options.variable;\n  if (!variable) {\n    source = 'with (obj) {\\n' + source + '\\n}\\n';\n  }\n  // Cleanup code by stripping empty strings.\n  source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n    .replace(reEmptyStringMiddle, '$1')\n    .replace(reEmptyStringTrailing, '$1;');\n\n  // Frame code as the function body.\n  source = 'function(' + (variable || 'obj') + ') {\\n' +\n    (variable\n      ? ''\n      : 'obj || (obj = {});\\n'\n    ) +\n    \"var __t, __p = ''\" +\n    (isEscaping\n       ? ', __e = _.escape'\n       : ''\n    ) +\n    (isEvaluating\n      ? ', __j = Array.prototype.join;\\n' +\n        \"function print() { __p += __j.call(arguments, '') }\\n\"\n      : ';\\n'\n    ) +\n    source +\n    'return __p\\n}';\n\n  var result = attempt(function() {\n    return Function(importsKeys, sourceURL + 'return ' + source)\n      .apply(undefined, importsValues);\n  });\n\n  // Provide the compiled function's source by its `toString` method or\n  // the `source` property as a convenience for inlining compiled templates.\n  result.source = source;\n  if (isError(result)) {\n    throw result;\n  }\n  return result;\n}\n\nmodule.exports = template;\n","var defineProperty = require('./_defineProperty');\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nmodule.exports = baseAssignValue;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike'),\n    isPlainObject = require('./isPlainObject');\n\n/** `Object#toString` result references. */\nvar domExcTag = '[object DOMException]',\n    errorTag = '[object Error]';\n\n/**\n * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n * `SyntaxError`, `TypeError`, or `URIError` object.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\n * @example\n *\n * _.isError(new Error);\n * // => true\n *\n * _.isError(Error);\n * // => false\n */\nfunction isError(value) {\n  if (!isObjectLike(value)) {\n    return false;\n  }\n  var tag = baseGetTag(value);\n  return tag == errorTag || tag == domExcTag ||\n    (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));\n}\n\nmodule.exports = isError;\n","/** Used to match template delimiters. */\nvar reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\nmodule.exports = reInterpolate;\n","var toGeoJSON = (function() {\n    'use strict';\n\n    var removeSpace = /\\s*/g,\n        trimSpace = /^\\s*|\\s*$/g,\n        splitSpace = /\\s+/;\n    // generate a short, numeric hash of a string\n    function okhash(x) {\n        if (!x || !x.length) return 0;\n        for (var i = 0, h = 0; i < x.length; i++) {\n            h = ((h << 5) - h) + x.charCodeAt(i) | 0;\n        } return h;\n    }\n    // all Y children of X\n    function get(x, y) { return x.getElementsByTagName(y); }\n    function attr(x, y) { return x.getAttribute(y); }\n    function attrf(x, y) { return parseFloat(attr(x, y)); }\n    // one Y child of X, if any, otherwise null\n    function get1(x, y) { var n = get(x, y); return n.length ? n[0] : null; }\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node.normalize\n    function norm(el) { if (el.normalize) { el.normalize(); } return el; }\n    // cast array x into numbers\n    function numarray(x) {\n        for (var j = 0, o = []; j < x.length; j++) { o[j] = parseFloat(x[j]); }\n        return o;\n    }\n    // get the content of a text node, if any\n    function nodeVal(x) {\n        if (x) { norm(x); }\n        return (x && x.textContent) || '';\n    }\n    // get the contents of multiple text nodes, if present\n    function getMulti(x, ys) {\n        var o = {}, n, k;\n        for (k = 0; k < ys.length; k++) {\n            n = get1(x, ys[k]);\n            if (n) o[ys[k]] = nodeVal(n);\n        }\n        return o;\n    }\n    // add properties of Y to X, overwriting if present in both\n    function extend(x, y) { for (var k in y) x[k] = y[k]; }\n    // get one coordinate from a coordinate array, if any\n    function coord1(v) { return numarray(v.replace(removeSpace, '').split(',')); }\n    // get all coordinates from a coordinate array as [[],[]]\n    function coord(v) {\n        var coords = v.replace(trimSpace, '').split(splitSpace),\n            o = [];\n        for (var i = 0; i < coords.length; i++) {\n            o.push(coord1(coords[i]));\n        }\n        return o;\n    }\n    function coordPair(x) {\n        var ll = [attrf(x, 'lon'), attrf(x, 'lat')],\n            ele = get1(x, 'ele'),\n            // handle namespaced attribute in browser\n            heartRate = get1(x, 'gpxtpx:hr') || get1(x, 'hr'),\n            time = get1(x, 'time'),\n            e;\n        if (ele) {\n            e = parseFloat(nodeVal(ele));\n            if (!isNaN(e)) {\n                ll.push(e);\n            }\n        }\n        return {\n            coordinates: ll,\n            time: time ? nodeVal(time) : null,\n            heartRate: heartRate ? parseFloat(nodeVal(heartRate)) : null\n        };\n    }\n\n    // create a new feature collection parent object\n    function fc() {\n        return {\n            type: 'FeatureCollection',\n            features: []\n        };\n    }\n\n    var serializer;\n    if (typeof XMLSerializer !== 'undefined') {\n        /* istanbul ignore next */\n        serializer = new XMLSerializer();\n    // only require xmldom in a node environment\n    } else if (typeof exports === 'object' && typeof process === 'object' && !process.browser) {\n        serializer = new (require('xmldom').XMLSerializer)();\n    }\n    function xml2str(str) {\n        // IE9 will create a new XMLSerializer but it'll crash immediately.\n        // This line is ignored because we don't run coverage tests in IE9\n        /* istanbul ignore next */\n        if (str.xml !== undefined) return str.xml;\n        return serializer.serializeToString(str);\n    }\n\n    var t = {\n        kml: function(doc) {\n\n            var gj = fc(),\n                // styleindex keeps track of hashed styles in order to match features\n                styleIndex = {}, styleByHash = {},\n                // stylemapindex keeps track of style maps to expose in properties\n                styleMapIndex = {},\n                // atomic geospatial types supported by KML - MultiGeometry is\n                // handled separately\n                geotypes = ['Polygon', 'LineString', 'Point', 'Track', 'gx:Track'],\n                // all root placemarks in the file\n                placemarks = get(doc, 'Placemark'),\n                styles = get(doc, 'Style'),\n                styleMaps = get(doc, 'StyleMap');\n\n            for (var k = 0; k < styles.length; k++) {\n                var hash = okhash(xml2str(styles[k])).toString(16);\n                styleIndex['#' + attr(styles[k], 'id')] = hash;\n                styleByHash[hash] = styles[k];\n            }\n            for (var l = 0; l < styleMaps.length; l++) {\n                styleIndex['#' + attr(styleMaps[l], 'id')] = okhash(xml2str(styleMaps[l])).toString(16);\n                var pairs = get(styleMaps[l], 'Pair');\n                var pairsMap = {};\n                for (var m = 0; m < pairs.length; m++) {\n                    pairsMap[nodeVal(get1(pairs[m], 'key'))] = nodeVal(get1(pairs[m], 'styleUrl'));\n                }\n                styleMapIndex['#' + attr(styleMaps[l], 'id')] = pairsMap;\n\n            }\n            for (var j = 0; j < placemarks.length; j++) {\n                gj.features = gj.features.concat(getPlacemark(placemarks[j]));\n            }\n            function kmlColor(v) {\n                var color, opacity;\n                v = v || '';\n                if (v.substr(0, 1) === '#') { v = v.substr(1); }\n                if (v.length === 6 || v.length === 3) { color = v; }\n                if (v.length === 8) {\n                    opacity = parseInt(v.substr(0, 2), 16) / 255;\n                    color = '#' + v.substr(6, 2) +\n                        v.substr(4, 2) +\n                        v.substr(2, 2);\n                }\n                return [color, isNaN(opacity) ? undefined : opacity];\n            }\n            function gxCoord(v) { return numarray(v.split(' ')); }\n            function gxCoords(root) {\n                var elems = get(root, 'coord', 'gx'), coords = [], times = [];\n                if (elems.length === 0) elems = get(root, 'gx:coord');\n                for (var i = 0; i < elems.length; i++) coords.push(gxCoord(nodeVal(elems[i])));\n                var timeElems = get(root, 'when');\n                for (var j = 0; j < timeElems.length; j++) times.push(nodeVal(timeElems[j]));\n                return {\n                    coords: coords,\n                    times: times\n                };\n            }\n            function getGeometry(root) {\n                var geomNode, geomNodes, i, j, k, geoms = [], coordTimes = [];\n                if (get1(root, 'MultiGeometry')) { return getGeometry(get1(root, 'MultiGeometry')); }\n                if (get1(root, 'MultiTrack')) { return getGeometry(get1(root, 'MultiTrack')); }\n                if (get1(root, 'gx:MultiTrack')) { return getGeometry(get1(root, 'gx:MultiTrack')); }\n                for (i = 0; i < geotypes.length; i++) {\n                    geomNodes = get(root, geotypes[i]);\n                    if (geomNodes) {\n                        for (j = 0; j < geomNodes.length; j++) {\n                            geomNode = geomNodes[j];\n                            if (geotypes[i] === 'Point') {\n                                geoms.push({\n                                    type: 'Point',\n                                    coordinates: coord1(nodeVal(get1(geomNode, 'coordinates')))\n                                });\n                            } else if (geotypes[i] === 'LineString') {\n                                geoms.push({\n                                    type: 'LineString',\n                                    coordinates: coord(nodeVal(get1(geomNode, 'coordinates')))\n                                });\n                            } else if (geotypes[i] === 'Polygon') {\n                                var rings = get(geomNode, 'LinearRing'),\n                                    coords = [];\n                                for (k = 0; k < rings.length; k++) {\n                                    coords.push(coord(nodeVal(get1(rings[k], 'coordinates'))));\n                                }\n                                geoms.push({\n                                    type: 'Polygon',\n                                    coordinates: coords\n                                });\n                            } else if (geotypes[i] === 'Track' ||\n                                geotypes[i] === 'gx:Track') {\n                                var track = gxCoords(geomNode);\n                                geoms.push({\n                                    type: 'LineString',\n                                    coordinates: track.coords\n                                });\n                                if (track.times.length) coordTimes.push(track.times);\n                            }\n                        }\n                    }\n                }\n                return {\n                    geoms: geoms,\n                    coordTimes: coordTimes\n                };\n            }\n            function getPlacemark(root) {\n                var geomsAndTimes = getGeometry(root), i, properties = {},\n                    name = nodeVal(get1(root, 'name')),\n                    styleUrl = nodeVal(get1(root, 'styleUrl')),\n                    description = nodeVal(get1(root, 'description')),\n                    timeSpan = get1(root, 'TimeSpan'),\n                    timeStamp = get1(root, 'TimeStamp'),\n                    extendedData = get1(root, 'ExtendedData'),\n                    lineStyle = get1(root, 'LineStyle'),\n                    polyStyle = get1(root, 'PolyStyle'),\n                    visibility = get1(root, 'visibility');\n\n                if (!geomsAndTimes.geoms.length) return [];\n                if (name) properties.name = name;\n                if (styleUrl) {\n                    if (styleUrl[0] !== '#') {\n                        styleUrl = '#' + styleUrl;\n                    }\n\n                    properties.styleUrl = styleUrl;\n                    if (styleIndex[styleUrl]) {\n                        properties.styleHash = styleIndex[styleUrl];\n                    }\n                    if (styleMapIndex[styleUrl]) {\n                        properties.styleMapHash = styleMapIndex[styleUrl];\n                        properties.styleHash = styleIndex[styleMapIndex[styleUrl].normal];\n                    }\n                    // Try to populate the lineStyle or polyStyle since we got the style hash\n                    var style = styleByHash[properties.styleHash];\n                    if (style) {\n                        if (!lineStyle) lineStyle = get1(style, 'LineStyle');\n                        if (!polyStyle) polyStyle = get1(style, 'PolyStyle');\n                    }\n                }\n                if (description) properties.description = description;\n                if (timeSpan) {\n                    var begin = nodeVal(get1(timeSpan, 'begin'));\n                    var end = nodeVal(get1(timeSpan, 'end'));\n                    properties.timespan = { begin: begin, end: end };\n                }\n                if (timeStamp) {\n                    properties.timestamp = nodeVal(get1(timeStamp, 'when'));\n                }\n                if (lineStyle) {\n                    var linestyles = kmlColor(nodeVal(get1(lineStyle, 'color'))),\n                        color = linestyles[0],\n                        opacity = linestyles[1],\n                        width = parseFloat(nodeVal(get1(lineStyle, 'width')));\n                    if (color) properties.stroke = color;\n                    if (!isNaN(opacity)) properties['stroke-opacity'] = opacity;\n                    if (!isNaN(width)) properties['stroke-width'] = width;\n                }\n                if (polyStyle) {\n                    var polystyles = kmlColor(nodeVal(get1(polyStyle, 'color'))),\n                        pcolor = polystyles[0],\n                        popacity = polystyles[1],\n                        fill = nodeVal(get1(polyStyle, 'fill')),\n                        outline = nodeVal(get1(polyStyle, 'outline'));\n                    if (pcolor) properties.fill = pcolor;\n                    if (!isNaN(popacity)) properties['fill-opacity'] = popacity;\n                    if (fill) properties['fill-opacity'] = fill === '1' ? properties['fill-opacity'] || 1 : 0;\n                    if (outline) properties['stroke-opacity'] = outline === '1' ? properties['stroke-opacity'] || 1 : 0;\n                }\n                if (extendedData) {\n                    var datas = get(extendedData, 'Data'),\n                        simpleDatas = get(extendedData, 'SimpleData');\n\n                    for (i = 0; i < datas.length; i++) {\n                        properties[datas[i].getAttribute('name')] = nodeVal(get1(datas[i], 'value'));\n                    }\n                    for (i = 0; i < simpleDatas.length; i++) {\n                        properties[simpleDatas[i].getAttribute('name')] = nodeVal(simpleDatas[i]);\n                    }\n                }\n                if (visibility) {\n                    properties.visibility = nodeVal(visibility);\n                }\n                if (geomsAndTimes.coordTimes.length) {\n                    properties.coordTimes = (geomsAndTimes.coordTimes.length === 1) ?\n                        geomsAndTimes.coordTimes[0] : geomsAndTimes.coordTimes;\n                }\n                var feature = {\n                    type: 'Feature',\n                    geometry: (geomsAndTimes.geoms.length === 1) ? geomsAndTimes.geoms[0] : {\n                        type: 'GeometryCollection',\n                        geometries: geomsAndTimes.geoms\n                    },\n                    properties: properties\n                };\n                if (attr(root, 'id')) feature.id = attr(root, 'id');\n                return [feature];\n            }\n            return gj;\n        },\n        gpx: function(doc) {\n            var i,\n                tracks = get(doc, 'trk'),\n                routes = get(doc, 'rte'),\n                waypoints = get(doc, 'wpt'),\n                // a feature collection\n                gj = fc(),\n                feature;\n            for (i = 0; i < tracks.length; i++) {\n                feature = getTrack(tracks[i]);\n                if (feature) gj.features.push(feature);\n            }\n            for (i = 0; i < routes.length; i++) {\n                feature = getRoute(routes[i]);\n                if (feature) gj.features.push(feature);\n            }\n            for (i = 0; i < waypoints.length; i++) {\n                gj.features.push(getPoint(waypoints[i]));\n            }\n            function getPoints(node, pointname) {\n                var pts = get(node, pointname),\n                    line = [],\n                    times = [],\n                    heartRates = [],\n                    l = pts.length;\n                if (l < 2) return {};  // Invalid line in GeoJSON\n                for (var i = 0; i < l; i++) {\n                    var c = coordPair(pts[i]);\n                    line.push(c.coordinates);\n                    if (c.time) times.push(c.time);\n                    if (c.heartRate) heartRates.push(c.heartRate);\n                }\n                return {\n                    line: line,\n                    times: times,\n                    heartRates: heartRates\n                };\n            }\n            function getTrack(node) {\n                var segments = get(node, 'trkseg'),\n                    track = [],\n                    times = [],\n                    heartRates = [],\n                    line;\n                for (var i = 0; i < segments.length; i++) {\n                    line = getPoints(segments[i], 'trkpt');\n                    if (line) {\n                        if (line.line) track.push(line.line);\n                        if (line.times && line.times.length) times.push(line.times);\n                        if (line.heartRates && line.heartRates.length) heartRates.push(line.heartRates);\n                    }\n                }\n                if (track.length === 0) return;\n                var properties = getProperties(node);\n                if (times.length) properties.coordTimes = track.length === 1 ? times[0] : times;\n                if (heartRates.length) properties.heartRates = track.length === 1 ? heartRates[0] : heartRates;\n                return {\n                    type: 'Feature',\n                    properties: properties,\n                    geometry: {\n                        type: track.length === 1 ? 'LineString' : 'MultiLineString',\n                        coordinates: track.length === 1 ? track[0] : track\n                    }\n                };\n            }\n            function getRoute(node) {\n                var line = getPoints(node, 'rtept');\n                if (!line.line) return;\n                var routeObj = {\n                    type: 'Feature',\n                    properties: getProperties(node),\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: line.line\n                    }\n                };\n                return routeObj;\n            }\n            function getPoint(node) {\n                var prop = getProperties(node);\n                extend(prop, getMulti(node, ['sym', 'type']));\n                return {\n                    type: 'Feature',\n                    properties: prop,\n                    geometry: {\n                        type: 'Point',\n                        coordinates: coordPair(node).coordinates\n                    }\n                };\n            }\n            function getProperties(node) {\n                var prop, links;\n                prop = getMulti(node, ['name', 'cmt', 'desc', 'time', 'keywords']);\n                links = get(node, 'link');\n                if (links.length) prop.links = [];\n                for (var i = 0, link; i < links.length; i++) {\n                    link = { href: attr(links[i], 'href') };\n                    extend(link, getMulti(links[i], ['text', 'type']));\n                    prop.links.push(link);\n                }\n                return prop;\n            }\n            return gj;\n        }\n    };\n    return t;\n})();\n\nif (typeof module !== 'undefined') module.exports = toGeoJSON;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar distance_1 = __importDefault(require(\"@turf/distance\"));\nvar meta_1 = require(\"@turf/meta\");\n/**\n * Takes a {@link GeoJSON} and measures its length in the specified units, {@link (Multi)Point}'s distance are ignored.\n *\n * @name length\n * @param {Feature<LineString|MultiLineString>} geojson GeoJSON to measure\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units=kilometers] can be degrees, radians, miles, or kilometers\n * @returns {number} length of GeoJSON\n * @example\n * var line = turf.lineString([[115, -32], [131, -22], [143, -25], [150, -34]]);\n * var length = turf.length(line, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line];\n * line.properties.distance = length;\n */\nfunction length(geojson, options) {\n    if (options === void 0) { options = {}; }\n    // Calculate distance from 2-vertex line segments\n    return meta_1.segmentReduce(geojson, function (previousValue, segment) {\n        var coords = segment.geometry.coordinates;\n        return previousValue + distance_1.default(coords[0], coords[1], options);\n    }, 0);\n}\nexports.default = length;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bearing_1 = require(\"@turf/bearing\");\nvar distance_1 = require(\"@turf/distance\");\nvar destination_1 = require(\"@turf/destination\");\nvar line_intersect_1 = require(\"@turf/line-intersect\");\nvar meta_1 = require(\"@turf/meta\");\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the (Multi)LineString.\n *\n * @name nearestPointOnLine\n * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to\n * @param {Geometry|Feature<Point>|number[]} pt point to snap from\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain three values: `index`: closest point was found on nth line part, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.\n * @example\n * var line = turf.lineString([\n *     [-77.031669, 38.878605],\n *     [-77.029609, 38.881946],\n *     [-77.020339, 38.884084],\n *     [-77.025661, 38.885821],\n *     [-77.021884, 38.889563],\n *     [-77.019824, 38.892368]\n * ]);\n * var pt = turf.point([-77.037076, 38.884017]);\n *\n * var snapped = turf.nearestPointOnLine(line, pt, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line, pt, snapped];\n * snapped.properties['marker-color'] = '#00f';\n */\nfunction nearestPointOnLine(lines, pt, options) {\n    if (options === void 0) { options = {}; }\n    var closestPt = helpers_1.point([Infinity, Infinity], {\n        dist: Infinity\n    });\n    var length = 0.0;\n    meta_1.flattenEach(lines, function (line) {\n        var coords = invariant_1.getCoords(line);\n        for (var i = 0; i < coords.length - 1; i++) {\n            //start\n            var start = helpers_1.point(coords[i]);\n            start.properties.dist = distance_1.default(pt, start, options);\n            //stop\n            var stop_1 = helpers_1.point(coords[i + 1]);\n            stop_1.properties.dist = distance_1.default(pt, stop_1, options);\n            // sectionLength\n            var sectionLength = distance_1.default(start, stop_1, options);\n            //perpendicular\n            var heightDistance = Math.max(start.properties.dist, stop_1.properties.dist);\n            var direction = bearing_1.default(start, stop_1);\n            var perpendicularPt1 = destination_1.default(pt, heightDistance, direction + 90, options);\n            var perpendicularPt2 = destination_1.default(pt, heightDistance, direction - 90, options);\n            var intersect = line_intersect_1.default(helpers_1.lineString([perpendicularPt1.geometry.coordinates, perpendicularPt2.geometry.coordinates]), helpers_1.lineString([start.geometry.coordinates, stop_1.geometry.coordinates]));\n            var intersectPt = null;\n            if (intersect.features.length > 0) {\n                intersectPt = intersect.features[0];\n                intersectPt.properties.dist = distance_1.default(pt, intersectPt, options);\n                intersectPt.properties.location = length + distance_1.default(start, intersectPt, options);\n            }\n            if (start.properties.dist < closestPt.properties.dist) {\n                closestPt = start;\n                closestPt.properties.index = i;\n                closestPt.properties.location = length;\n            }\n            if (stop_1.properties.dist < closestPt.properties.dist) {\n                closestPt = stop_1;\n                closestPt.properties.index = i + 1;\n                closestPt.properties.location = length + sectionLength;\n            }\n            if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {\n                closestPt = intersectPt;\n                closestPt.properties.index = i;\n            }\n            // update length\n            length += sectionLength;\n        }\n    });\n    return closestPt;\n}\nexports.default = nearestPointOnLine;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Taken from http://geomalgorithms.com/a02-_lines.html\nvar distance_1 = __importDefault(require(\"@turf/distance\"));\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\nvar meta_1 = require(\"@turf/meta\");\nvar rhumb_distance_1 = __importDefault(require(\"@turf/rhumb-distance\"));\n/**\n * Returns the minimum distance between a {@link Point} and a {@link LineString}, being the distance from a line the\n * minimum distance between the point and any segment of the `LineString`.\n *\n * @name pointToLineDistance\n * @param {Feature<Point>|Array<number>} pt Feature or Geometry\n * @param {Feature<LineString>} line GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units=\"kilometers\"] can be anything supported by turf/convertLength\n * (ex: degrees, radians, miles, or kilometers)\n * @param {string} [options.method=\"geodesic\"] wether to calculate the distance based on geodesic (spheroid) or\n * planar (flat) method. Valid options are 'geodesic' or 'planar'.\n * @returns {number} distance between point and line\n * @example\n * var pt = turf.point([0, 0]);\n * var line = turf.lineString([[1, 1],[-1, 1]]);\n *\n * var distance = turf.pointToLineDistance(pt, line, {units: 'miles'});\n * //=69.11854715938406\n */\nfunction pointToLineDistance(pt, line, options) {\n    if (options === void 0) { options = {}; }\n    // Optional parameters\n    if (!options.method) {\n        options.method = \"geodesic\";\n    }\n    if (!options.units) {\n        options.units = \"kilometers\";\n    }\n    // validation\n    if (!pt) {\n        throw new Error(\"pt is required\");\n    }\n    if (Array.isArray(pt)) {\n        pt = helpers_1.point(pt);\n    }\n    else if (pt.type === \"Point\") {\n        pt = helpers_1.feature(pt);\n    }\n    else {\n        invariant_1.featureOf(pt, \"Point\", \"point\");\n    }\n    if (!line) {\n        throw new Error(\"line is required\");\n    }\n    if (Array.isArray(line)) {\n        line = helpers_1.lineString(line);\n    }\n    else if (line.type === \"LineString\") {\n        line = helpers_1.feature(line);\n    }\n    else {\n        invariant_1.featureOf(line, \"LineString\", \"line\");\n    }\n    var distance = Infinity;\n    var p = pt.geometry.coordinates;\n    meta_1.segmentEach(line, function (segment) {\n        var a = segment.geometry.coordinates[0];\n        var b = segment.geometry.coordinates[1];\n        var d = distanceToSegment(p, a, b, options);\n        if (d < distance) {\n            distance = d;\n        }\n    });\n    return helpers_1.convertLength(distance, \"degrees\", options.units);\n}\n/**\n * Returns the distance between a point P on a segment AB.\n *\n * @private\n * @param {Array<number>} p external point\n * @param {Array<number>} a first segment point\n * @param {Array<number>} b second segment point\n * @param {Object} [options={}] Optional parameters\n * @returns {number} distance\n */\nfunction distanceToSegment(p, a, b, options) {\n    var v = [b[0] - a[0], b[1] - a[1]];\n    var w = [p[0] - a[0], p[1] - a[1]];\n    var c1 = dot(w, v);\n    if (c1 <= 0) {\n        return calcDistance(p, a, { method: options.method, units: \"degrees\" });\n    }\n    var c2 = dot(v, v);\n    if (c2 <= c1) {\n        return calcDistance(p, b, { method: options.method, units: \"degrees\" });\n    }\n    var b2 = c1 / c2;\n    var Pb = [a[0] + (b2 * v[0]), a[1] + (b2 * v[1])];\n    return calcDistance(p, Pb, { method: options.method, units: \"degrees\" });\n}\nfunction dot(u, v) {\n    return (u[0] * v[0] + u[1] * v[1]);\n}\nfunction calcDistance(a, b, options) {\n    return options.method === \"planar\" ? rhumb_distance_1.default(a, b, options) : distance_1.default(a, b, options);\n}\nexports.default = pointToLineDistance;\n","var overArg = require('./_overArg');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nmodule.exports = DataView;\n","var isFunction = require('./isFunction'),\n    isMasked = require('./_isMasked'),\n    isObject = require('./isObject'),\n    toSource = require('./_toSource');\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","var coreJsData = require('./_coreJsData');\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n","var root = require('./_root');\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nmodule.exports = Promise;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nmodule.exports = Set;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nmodule.exports = WeakMap;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n","/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n","var baseGetTag = require('./_baseGetTag'),\n    isLength = require('./isLength'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n","var Stack = require('./_Stack'),\n    equalArrays = require('./_equalArrays'),\n    equalByTag = require('./_equalByTag'),\n    equalObjects = require('./_equalObjects'),\n    getTag = require('./_getTag'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\nmodule.exports = baseIsEqualDeep;\n","/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n","var ListCache = require('./_ListCache');\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\nmodule.exports = stackClear;\n","/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\nmodule.exports = stackDelete;\n","/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nmodule.exports = stackGet;\n","/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nmodule.exports = stackHas;\n","var ListCache = require('./_ListCache'),\n    Map = require('./_Map'),\n    MapCache = require('./_MapCache');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nmodule.exports = stackSet;\n","var Hash = require('./_Hash'),\n    ListCache = require('./_ListCache'),\n    Map = require('./_Map');\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n","var hashClear = require('./_hashClear'),\n    hashDelete = require('./_hashDelete'),\n    hashGet = require('./_hashGet'),\n    hashHas = require('./_hashHas'),\n    hashSet = require('./_hashSet');\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n","var nativeCreate = require('./_nativeCreate');\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n","/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n","var getMapData = require('./_getMapData');\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n","/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n","var getMapData = require('./_getMapData');\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n","var getMapData = require('./_getMapData');\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n","var getMapData = require('./_getMapData');\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n","var MapCache = require('./_MapCache'),\n    setCacheAdd = require('./_setCacheAdd'),\n    setCacheHas = require('./_setCacheHas');\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\nmodule.exports = SetCache;\n","/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\nmodule.exports = setCacheAdd;\n","/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\nmodule.exports = setCacheHas;\n","/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arraySome;\n","/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\nmodule.exports = cacheHas;\n","var Symbol = require('./_Symbol'),\n    Uint8Array = require('./_Uint8Array'),\n    eq = require('./eq'),\n    equalArrays = require('./_equalArrays'),\n    mapToArray = require('./_mapToArray'),\n    setToArray = require('./_setToArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]';\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\nmodule.exports = equalByTag;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Uint8Array = root.Uint8Array;\n\nmodule.exports = Uint8Array;\n","/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\nmodule.exports = mapToArray;\n","/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nmodule.exports = setToArray;\n","var getAllKeys = require('./_getAllKeys');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalObjects;\n","var baseGetAllKeys = require('./_baseGetAllKeys'),\n    getSymbols = require('./_getSymbols'),\n    keys = require('./keys');\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\nmodule.exports = getAllKeys;\n","var arrayPush = require('./_arrayPush'),\n    isArray = require('./isArray');\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\nmodule.exports = baseGetAllKeys;\n","var arrayFilter = require('./_arrayFilter'),\n    stubArray = require('./stubArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\nmodule.exports = getSymbols;\n","/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\nmodule.exports = stubArray;\n","/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n","var baseEach = require('./_baseEach');\n\n/**\n * The base implementation of `_.filter` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction baseFilter(collection, predicate) {\n  var result = [];\n  baseEach(collection, function(value, index, collection) {\n    if (predicate(value, index, collection)) {\n      result.push(value);\n    }\n  });\n  return result;\n}\n\nmodule.exports = baseFilter;\n","var baseFor = require('./_baseFor'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n","var createBaseFor = require('./_createBaseFor');\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n","/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n","var isArrayLike = require('./isArrayLike');\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\nmodule.exports = createBaseEach;\n","var baseIsMatch = require('./_baseIsMatch'),\n    getMatchData = require('./_getMatchData'),\n    matchesStrictComparable = require('./_matchesStrictComparable');\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\nmodule.exports = baseMatches;\n","var Stack = require('./_Stack'),\n    baseIsEqual = require('./_baseIsEqual');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nmodule.exports = baseIsMatch;\n","var isStrictComparable = require('./_isStrictComparable'),\n    keys = require('./keys');\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\nmodule.exports = getMatchData;\n","var baseIsEqual = require('./_baseIsEqual'),\n    get = require('./get'),\n    hasIn = require('./hasIn'),\n    isKey = require('./_isKey'),\n    isStrictComparable = require('./_isStrictComparable'),\n    matchesStrictComparable = require('./_matchesStrictComparable'),\n    toKey = require('./_toKey');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\nmodule.exports = baseMatchesProperty;\n","var memoizeCapped = require('./_memoizeCapped');\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nmodule.exports = stringToPath;\n","var memoize = require('./memoize');\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nmodule.exports = memoizeCapped;\n","var MapCache = require('./_MapCache');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n","var Symbol = require('./_Symbol'),\n    arrayMap = require('./_arrayMap'),\n    isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = baseToString;\n","var baseHasIn = require('./_baseHasIn'),\n    hasPath = require('./_hasPath');\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\nmodule.exports = hasIn;\n","/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\nmodule.exports = baseHasIn;\n","var castPath = require('./_castPath'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isIndex = require('./_isIndex'),\n    isLength = require('./isLength'),\n    toKey = require('./_toKey');\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\nmodule.exports = hasPath;\n","var baseProperty = require('./_baseProperty'),\n    basePropertyDeep = require('./_basePropertyDeep'),\n    isKey = require('./_isKey'),\n    toKey = require('./_toKey');\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nmodule.exports = property;\n","/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = baseProperty;\n","var baseGet = require('./_baseGet');\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\nmodule.exports = basePropertyDeep;\n","var baseIteratee = require('./_baseIteratee'),\n    isArrayLike = require('./isArrayLike'),\n    keys = require('./keys');\n\n/**\n * Creates a `_.find` or `_.findLast` function.\n *\n * @private\n * @param {Function} findIndexFunc The function to find the collection index.\n * @returns {Function} Returns the new find function.\n */\nfunction createFind(findIndexFunc) {\n  return function(collection, predicate, fromIndex) {\n    var iterable = Object(collection);\n    if (!isArrayLike(collection)) {\n      var iteratee = baseIteratee(predicate, 3);\n      collection = keys(collection);\n      predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n    }\n    var index = findIndexFunc(collection, predicate, fromIndex);\n    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n  };\n}\n\nmodule.exports = createFind;\n","var baseFindIndex = require('./_baseFindIndex'),\n    baseIteratee = require('./_baseIteratee'),\n    toInteger = require('./toInteger');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\n * // => 0\n *\n * // The `_.matches` iteratee shorthand.\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findIndex(users, ['active', false]);\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.findIndex(users, 'active');\n * // => 2\n */\nfunction findIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index);\n}\n\nmodule.exports = findIndex;\n","/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = baseFindIndex;\n","var toFinite = require('./toFinite');\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nmodule.exports = toInteger;\n","var toNumber = require('./toNumber');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nmodule.exports = toFinite;\n","var isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n","/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n","var identity = require('./identity');\n\n/**\n * Casts `value` to `identity` if it's not a function.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Function} Returns cast function.\n */\nfunction castFunction(value) {\n  return typeof value == 'function' ? value : identity;\n}\n\nmodule.exports = castFunction;\n","var isSymbol = require('./isSymbol');\n\n/**\n * The base implementation of methods like `_.max` and `_.min` which accepts a\n * `comparator` to determine the extremum value.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The iteratee invoked per iteration.\n * @param {Function} comparator The comparator used to compare values.\n * @returns {*} Returns the extremum value.\n */\nfunction baseExtremum(array, iteratee, comparator) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    var value = array[index],\n        current = iteratee(value);\n\n    if (current != null && (computed === undefined\n          ? (current === current && !isSymbol(current))\n          : comparator(current, computed)\n        )) {\n      var computed = current,\n          result = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseExtremum;\n","/**\n * The base implementation of `_.lt` which doesn't coerce arguments.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if `value` is less than `other`,\n *  else `false`.\n */\nfunction baseLt(value, other) {\n  return value < other;\n}\n\nmodule.exports = baseLt;\n","var arrayPush = require('./_arrayPush'),\n    isFlattenable = require('./_isFlattenable');\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseFlatten;\n","var Symbol = require('./_Symbol'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray');\n\n/** Built-in value references. */\nvar spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\nmodule.exports = isFlattenable;\n","var arrayMap = require('./_arrayMap'),\n    baseIteratee = require('./_baseIteratee'),\n    baseMap = require('./_baseMap'),\n    baseSortBy = require('./_baseSortBy'),\n    baseUnary = require('./_baseUnary'),\n    compareMultiple = require('./_compareMultiple'),\n    identity = require('./identity');\n\n/**\n * The base implementation of `_.orderBy` without param guards.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n * @param {string[]} orders The sort orders of `iteratees`.\n * @returns {Array} Returns the new sorted array.\n */\nfunction baseOrderBy(collection, iteratees, orders) {\n  var index = -1;\n  iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));\n\n  var result = baseMap(collection, function(value, key, collection) {\n    var criteria = arrayMap(iteratees, function(iteratee) {\n      return iteratee(value);\n    });\n    return { 'criteria': criteria, 'index': ++index, 'value': value };\n  });\n\n  return baseSortBy(result, function(object, other) {\n    return compareMultiple(object, other, orders);\n  });\n}\n\nmodule.exports = baseOrderBy;\n","/**\n * The base implementation of `_.sortBy` which uses `comparer` to define the\n * sort order of `array` and replaces criteria objects with their corresponding\n * values.\n *\n * @private\n * @param {Array} array The array to sort.\n * @param {Function} comparer The function to define sort order.\n * @returns {Array} Returns `array`.\n */\nfunction baseSortBy(array, comparer) {\n  var length = array.length;\n\n  array.sort(comparer);\n  while (length--) {\n    array[length] = array[length].value;\n  }\n  return array;\n}\n\nmodule.exports = baseSortBy;\n","var compareAscending = require('./_compareAscending');\n\n/**\n * Used by `_.orderBy` to compare multiple properties of a value to another\n * and stable sort them.\n *\n * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n * of corresponding values.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {boolean[]|string[]} orders The order to sort by for each property.\n * @returns {number} Returns the sort order indicator for `object`.\n */\nfunction compareMultiple(object, other, orders) {\n  var index = -1,\n      objCriteria = object.criteria,\n      othCriteria = other.criteria,\n      length = objCriteria.length,\n      ordersLength = orders.length;\n\n  while (++index < length) {\n    var result = compareAscending(objCriteria[index], othCriteria[index]);\n    if (result) {\n      if (index >= ordersLength) {\n        return result;\n      }\n      var order = orders[index];\n      return result * (order == 'desc' ? -1 : 1);\n    }\n  }\n  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n  // that causes it, under certain circumstances, to provide the same value for\n  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n  // for more details.\n  //\n  // This also ensures a stable sort in V8 and other engines.\n  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n  return object.index - other.index;\n}\n\nmodule.exports = compareMultiple;\n","var isSymbol = require('./isSymbol');\n\n/**\n * Compares values to sort them in ascending order.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {number} Returns the sort order indicator for `value`.\n */\nfunction compareAscending(value, other) {\n  if (value !== other) {\n    var valIsDefined = value !== undefined,\n        valIsNull = value === null,\n        valIsReflexive = value === value,\n        valIsSymbol = isSymbol(value);\n\n    var othIsDefined = other !== undefined,\n        othIsNull = other === null,\n        othIsReflexive = other === other,\n        othIsSymbol = isSymbol(other);\n\n    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n        (valIsNull && othIsDefined && othIsReflexive) ||\n        (!valIsDefined && othIsReflexive) ||\n        !valIsReflexive) {\n      return 1;\n    }\n    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n        (othIsNull && valIsDefined && valIsReflexive) ||\n        (!othIsDefined && valIsReflexive) ||\n        !othIsReflexive) {\n      return -1;\n    }\n  }\n  return 0;\n}\n\nmodule.exports = compareAscending;\n","var apply = require('./_apply');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\nmodule.exports = overRest;\n","var baseSetToString = require('./_baseSetToString'),\n    shortOut = require('./_shortOut');\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\nmodule.exports = setToString;\n","var constant = require('./constant'),\n    defineProperty = require('./_defineProperty'),\n    identity = require('./identity');\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\nmodule.exports = baseSetToString;\n","/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\nmodule.exports = constant;\n","/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeNow = Date.now;\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\nmodule.exports = shortOut;\n","var copyObject = require('./_copyObject'),\n    createAssigner = require('./_createAssigner'),\n    keysIn = require('./keysIn');\n\n/**\n * This method is like `_.assignIn` except that it accepts `customizer`\n * which is invoked to produce the assigned values. If `customizer` returns\n * `undefined`, assignment is handled by the method instead. The `customizer`\n * is invoked with five arguments: (objValue, srcValue, key, object, source).\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @alias extendWith\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} sources The source objects.\n * @param {Function} [customizer] The function to customize assigned values.\n * @returns {Object} Returns `object`.\n * @see _.assignWith\n * @example\n *\n * function customizer(objValue, srcValue) {\n *   return _.isUndefined(objValue) ? srcValue : objValue;\n * }\n *\n * var defaults = _.partialRight(_.assignInWith, customizer);\n *\n * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n * // => { 'a': 1, 'b': 2 }\n */\nvar assignInWith = createAssigner(function(object, source, srcIndex, customizer) {\n  copyObject(source, keysIn(source), object, customizer);\n});\n\nmodule.exports = assignInWith;\n","var assignValue = require('./_assignValue'),\n    baseAssignValue = require('./_baseAssignValue');\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\nmodule.exports = copyObject;\n","var baseAssignValue = require('./_baseAssignValue'),\n    eq = require('./eq');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignValue;\n","var baseRest = require('./_baseRest'),\n    isIterateeCall = require('./_isIterateeCall');\n\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return baseRest(function(object, sources) {\n    var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined;\n\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\n      ? (length--, customizer)\n      : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n    return object;\n  });\n}\n\nmodule.exports = createAssigner;\n","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeysIn = require('./_baseKeysIn'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\nmodule.exports = keysIn;\n","var isObject = require('./isObject'),\n    isPrototype = require('./_isPrototype'),\n    nativeKeysIn = require('./_nativeKeysIn');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeysIn;\n","/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = nativeKeysIn;\n","var apply = require('./_apply'),\n    baseRest = require('./_baseRest'),\n    isError = require('./isError');\n\n/**\n * Attempts to invoke `func`, returning either the result or the caught error\n * object. Any additional arguments are provided to `func` when it's invoked.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Util\n * @param {Function} func The function to attempt.\n * @param {...*} [args] The arguments to invoke `func` with.\n * @returns {*} Returns the `func` result or error object.\n * @example\n *\n * // Avoid throwing errors for invalid selectors.\n * var elements = _.attempt(function(selector) {\n *   return document.querySelectorAll(selector);\n * }, '>_>');\n *\n * if (_.isError(elements)) {\n *   elements = [];\n * }\n */\nvar attempt = baseRest(function(func, args) {\n  try {\n    return apply(func, undefined, args);\n  } catch (e) {\n    return isError(e) ? e : new Error(e);\n  }\n});\n\nmodule.exports = attempt;\n","var baseGetTag = require('./_baseGetTag'),\n    getPrototype = require('./_getPrototype'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nmodule.exports = isPlainObject;\n","var overArg = require('./_overArg');\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nmodule.exports = getPrototype;\n","var arrayMap = require('./_arrayMap');\n\n/**\n * The base implementation of `_.values` and `_.valuesIn` which creates an\n * array of `object` property values corresponding to the property names\n * of `props`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} props The property names to get values for.\n * @returns {Object} Returns the array of property values.\n */\nfunction baseValues(object, props) {\n  return arrayMap(props, function(key) {\n    return object[key];\n  });\n}\n\nmodule.exports = baseValues;\n","var eq = require('./eq');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used by `_.defaults` to customize its `_.assignIn` use to assign properties\n * of source objects to the destination object for all destination properties\n * that resolve to `undefined`.\n *\n * @private\n * @param {*} objValue The destination value.\n * @param {*} srcValue The source value.\n * @param {string} key The key of the property to assign.\n * @param {Object} object The parent object of `objValue`.\n * @returns {*} Returns the value to assign.\n */\nfunction customDefaultsAssignIn(objValue, srcValue, key, object) {\n  if (objValue === undefined ||\n      (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n    return srcValue;\n  }\n  return objValue;\n}\n\nmodule.exports = customDefaultsAssignIn;\n","/** Used to escape characters for inclusion in compiled string literals. */\nvar stringEscapes = {\n  '\\\\': '\\\\',\n  \"'\": \"'\",\n  '\\n': 'n',\n  '\\r': 'r',\n  '\\u2028': 'u2028',\n  '\\u2029': 'u2029'\n};\n\n/**\n * Used by `_.template` to escape characters for inclusion in compiled string literals.\n *\n * @private\n * @param {string} chr The matched character to escape.\n * @returns {string} Returns the escaped character.\n */\nfunction escapeStringChar(chr) {\n  return '\\\\' + stringEscapes[chr];\n}\n\nmodule.exports = escapeStringChar;\n","var escape = require('./escape'),\n    reEscape = require('./_reEscape'),\n    reEvaluate = require('./_reEvaluate'),\n    reInterpolate = require('./_reInterpolate');\n\n/**\n * By default, the template delimiters used by lodash are like those in\n * embedded Ruby (ERB) as well as ES2015 template strings. Change the\n * following template settings to use alternative delimiters.\n *\n * @static\n * @memberOf _\n * @type {Object}\n */\nvar templateSettings = {\n\n  /**\n   * Used to detect `data` property values to be HTML-escaped.\n   *\n   * @memberOf _.templateSettings\n   * @type {RegExp}\n   */\n  'escape': reEscape,\n\n  /**\n   * Used to detect code to be evaluated.\n   *\n   * @memberOf _.templateSettings\n   * @type {RegExp}\n   */\n  'evaluate': reEvaluate,\n\n  /**\n   * Used to detect `data` property values to inject.\n   *\n   * @memberOf _.templateSettings\n   * @type {RegExp}\n   */\n  'interpolate': reInterpolate,\n\n  /**\n   * Used to reference the data object in the template text.\n   *\n   * @memberOf _.templateSettings\n   * @type {string}\n   */\n  'variable': '',\n\n  /**\n   * Used to import variables into the compiled template.\n   *\n   * @memberOf _.templateSettings\n   * @type {Object}\n   */\n  'imports': {\n\n    /**\n     * A reference to the `lodash` function.\n     *\n     * @memberOf _.templateSettings.imports\n     * @type {Function}\n     */\n    '_': { 'escape': escape }\n  }\n};\n\nmodule.exports = templateSettings;\n","var escapeHtmlChar = require('./_escapeHtmlChar'),\n    toString = require('./toString');\n\n/** Used to match HTML entities and HTML characters. */\nvar reUnescapedHtml = /[&<>\"']/g,\n    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\n/**\n * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `string` to their\n * corresponding HTML entities.\n *\n * **Note:** No other characters are escaped. To escape additional\n * characters use a third-party library like [_he_](https://mths.be/he).\n *\n * Though the \">\" character is escaped for symmetry, characters like\n * \">\" and \"/\" don't need escaping in HTML and have no special meaning\n * unless they're part of a tag or unquoted attribute value. See\n * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n * (under \"semi-related fun fact\") for more details.\n *\n * When working with HTML you should always\n * [quote attribute values](http://wonko.com/post/html-escaping) to reduce\n * XSS vectors.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category String\n * @param {string} [string=''] The string to escape.\n * @returns {string} Returns the escaped string.\n * @example\n *\n * _.escape('fred, barney, & pebbles');\n * // => 'fred, barney, &amp; pebbles'\n */\nfunction escape(string) {\n  string = toString(string);\n  return (string && reHasUnescapedHtml.test(string))\n    ? string.replace(reUnescapedHtml, escapeHtmlChar)\n    : string;\n}\n\nmodule.exports = escape;\n","var basePropertyOf = require('./_basePropertyOf');\n\n/** Used to map characters to HTML entities. */\nvar htmlEscapes = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;'\n};\n\n/**\n * Used by `_.escape` to convert characters to HTML entities.\n *\n * @private\n * @param {string} chr The matched character to escape.\n * @returns {string} Returns the escaped character.\n */\nvar escapeHtmlChar = basePropertyOf(htmlEscapes);\n\nmodule.exports = escapeHtmlChar;\n","/**\n * The base implementation of `_.propertyOf` without support for deep paths.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyOf(object) {\n  return function(key) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = basePropertyOf;\n","/** Used to match template delimiters. */\nvar reEscape = /<%-([\\s\\S]+?)%>/g;\n\nmodule.exports = reEscape;\n","/** Used to match template delimiters. */\nvar reEvaluate = /<%([\\s\\S]+?)%>/g;\n\nmodule.exports = reEvaluate;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        var previousFeatureIndex = 0;\n        var previousMultiIndex = 0;\n        var prevGeomIndex = 0;\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n                previousCoords = currentCoord;\n                previousFeatureIndex = featureIndex;\n                previousMultiIndex = multiPartIndexCoord;\n                prevGeomIndex = geometryIndex;\n                segmentIndex = 0;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        if (feature.geometry === null) return;\n        var type = feature.geometry.type;\n        var coords = feature.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\n// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Takes two {@link Point|points} and finds the geographic bearing between them,\n * i.e. the angle measured in degrees from the north line (0 degrees)\n *\n * @name bearing\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.final=false] calculates the final bearing if true\n * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)\n * @example\n * var point1 = turf.point([-75.343, 39.984]);\n * var point2 = turf.point([-75.534, 39.123]);\n *\n * var bearing = turf.bearing(point1, point2);\n *\n * //addToMap\n * var addToMap = [point1, point2]\n * point1.properties['marker-color'] = '#f00'\n * point2.properties['marker-color'] = '#0f0'\n * point1.properties.bearing = bearing\n */\nfunction bearing(start, end, options) {\n    if (options === void 0) { options = {}; }\n    // Reverse calculation\n    if (options.final === true) {\n        return calculateFinalBearing(start, end);\n    }\n    var coordinates1 = invariant_1.getCoord(start);\n    var coordinates2 = invariant_1.getCoord(end);\n    var lon1 = helpers_1.degreesToRadians(coordinates1[0]);\n    var lon2 = helpers_1.degreesToRadians(coordinates2[0]);\n    var lat1 = helpers_1.degreesToRadians(coordinates1[1]);\n    var lat2 = helpers_1.degreesToRadians(coordinates2[1]);\n    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n    var b = Math.cos(lat1) * Math.sin(lat2) -\n        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n    return helpers_1.radiansToDegrees(Math.atan2(a, b));\n}\n/**\n * Calculates Final Bearing\n *\n * @private\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @returns {number} bearing\n */\nfunction calculateFinalBearing(start, end) {\n    // Swap start & end\n    var bear = bearing(end, start);\n    bear = (bear + 180) % 360;\n    return bear;\n}\nexports.default = bearing;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in\n * degrees, radians, miles, or kilometers; and bearing in degrees.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Coord} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {Object} [options.properties={}] Translate properties to Point\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.destination(point, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\nfunction destination(origin, distance, bearing, options) {\n    if (options === void 0) { options = {}; }\n    // Handle input\n    var coordinates1 = invariant_1.getCoord(origin);\n    var longitude1 = helpers_1.degreesToRadians(coordinates1[0]);\n    var latitude1 = helpers_1.degreesToRadians(coordinates1[1]);\n    var bearingRad = helpers_1.degreesToRadians(bearing);\n    var radians = helpers_1.lengthToRadians(distance, options.units);\n    // Main\n    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));\n    var longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n    var lng = helpers_1.radiansToDegrees(longitude2);\n    var lat = helpers_1.radiansToDegrees(latitude2);\n    return helpers_1.point([lng, lat], options.properties);\n}\nexports.default = destination;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\nvar line_segment_1 = __importDefault(require(\"@turf/line-segment\"));\nvar meta_1 = require(\"@turf/meta\");\nvar geojson_rbush_1 = __importDefault(require(\"geojson-rbush\"));\n/**\n * Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).\n *\n * @name lineIntersect\n * @param {GeoJSON} line1 any LineString or Polygon\n * @param {GeoJSON} line2 any LineString or Polygon\n * @returns {FeatureCollection<Point>} point(s) that intersect both\n * @example\n * var line1 = turf.lineString([[126, -11], [129, -21]]);\n * var line2 = turf.lineString([[123, -18], [131, -14]]);\n * var intersects = turf.lineIntersect(line1, line2);\n *\n * //addToMap\n * var addToMap = [line1, line2, intersects]\n */\nfunction lineIntersect(line1, line2) {\n    var unique = {};\n    var results = [];\n    // First, normalize geometries to features\n    // Then, handle simple 2-vertex segments\n    if (line1.type === \"LineString\") {\n        line1 = helpers_1.feature(line1);\n    }\n    if (line2.type === \"LineString\") {\n        line2 = helpers_1.feature(line2);\n    }\n    if (line1.type === \"Feature\" &&\n        line2.type === \"Feature\" &&\n        line1.geometry !== null &&\n        line2.geometry !== null &&\n        line1.geometry.type === \"LineString\" &&\n        line2.geometry.type === \"LineString\" &&\n        line1.geometry.coordinates.length === 2 &&\n        line2.geometry.coordinates.length === 2) {\n        var intersect = intersects(line1, line2);\n        if (intersect) {\n            results.push(intersect);\n        }\n        return helpers_1.featureCollection(results);\n    }\n    // Handles complex GeoJSON Geometries\n    var tree = geojson_rbush_1.default();\n    tree.load(line_segment_1.default(line2));\n    meta_1.featureEach(line_segment_1.default(line1), function (segment) {\n        meta_1.featureEach(tree.search(segment), function (match) {\n            var intersect = intersects(segment, match);\n            if (intersect) {\n                // prevent duplicate points https://github.com/Turfjs/turf/issues/688\n                var key = invariant_1.getCoords(intersect).join(\",\");\n                if (!unique[key]) {\n                    unique[key] = true;\n                    results.push(intersect);\n                }\n            }\n        });\n    });\n    return helpers_1.featureCollection(results);\n}\n/**\n * Find a point that intersects LineStrings with two coordinates each\n *\n * @private\n * @param {Feature<LineString>} line1 GeoJSON LineString (Must only contain 2 coordinates)\n * @param {Feature<LineString>} line2 GeoJSON LineString (Must only contain 2 coordinates)\n * @returns {Feature<Point>} intersecting GeoJSON Point\n */\nfunction intersects(line1, line2) {\n    var coords1 = invariant_1.getCoords(line1);\n    var coords2 = invariant_1.getCoords(line2);\n    if (coords1.length !== 2) {\n        throw new Error(\"<intersects> line1 must only contain 2 coordinates\");\n    }\n    if (coords2.length !== 2) {\n        throw new Error(\"<intersects> line2 must only contain 2 coordinates\");\n    }\n    var x1 = coords1[0][0];\n    var y1 = coords1[0][1];\n    var x2 = coords1[1][0];\n    var y2 = coords1[1][1];\n    var x3 = coords2[0][0];\n    var y3 = coords2[0][1];\n    var x4 = coords2[1][0];\n    var y4 = coords2[1][1];\n    var denom = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));\n    var numeA = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3));\n    var numeB = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3));\n    if (denom === 0) {\n        if (numeA === 0 && numeB === 0) {\n            return null;\n        }\n        return null;\n    }\n    var uA = numeA / denom;\n    var uB = numeB / denom;\n    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n        var x = x1 + (uA * (x2 - x1));\n        var y = y1 + (uA * (y2 - y1));\n        return helpers_1.point([x, y]);\n    }\n    return null;\n}\nexports.default = lineIntersect;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\nvar meta_1 = require(\"@turf/meta\");\n/**\n * Creates a {@link FeatureCollection} of 2-vertex {@link LineString} segments from a\n * {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon}.\n *\n * @name lineSegment\n * @param {GeoJSON} geojson GeoJSON Polygon or LineString\n * @returns {FeatureCollection<LineString>} 2-vertex line segments\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n * var segments = turf.lineSegment(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, segments]\n */\nfunction lineSegment(geojson) {\n    if (!geojson) {\n        throw new Error(\"geojson is required\");\n    }\n    var results = [];\n    meta_1.flattenEach(geojson, function (feature) {\n        lineSegmentFeature(feature, results);\n    });\n    return helpers_1.featureCollection(results);\n}\n/**\n * Line Segment\n *\n * @private\n * @param {Feature<LineString|Polygon>} geojson Line or polygon feature\n * @param {Array} results push to results\n * @returns {void}\n */\nfunction lineSegmentFeature(geojson, results) {\n    var coords = [];\n    var geometry = geojson.geometry;\n    if (geometry !== null) {\n        switch (geometry.type) {\n            case \"Polygon\":\n                coords = invariant_1.getCoords(geometry);\n                break;\n            case \"LineString\":\n                coords = [invariant_1.getCoords(geometry)];\n        }\n        coords.forEach(function (coord) {\n            var segments = createSegments(coord, geojson.properties);\n            segments.forEach(function (segment) {\n                segment.id = results.length;\n                results.push(segment);\n            });\n        });\n    }\n}\n/**\n * Create Segments from LineString coordinates\n *\n * @private\n * @param {Array<Array<number>>} coords LineString coordinates\n * @param {*} properties GeoJSON properties\n * @returns {Array<Feature<LineString>>} line segments\n */\nfunction createSegments(coords, properties) {\n    var segments = [];\n    coords.reduce(function (previousCoords, currentCoords) {\n        var segment = helpers_1.lineString([previousCoords, currentCoords], properties);\n        segment.bbox = bbox(previousCoords, currentCoords);\n        segments.push(segment);\n        return currentCoords;\n    });\n    return segments;\n}\n/**\n * Create BBox between two coordinates (faster than @turf/bbox)\n *\n * @private\n * @param {Array<number>} coords1 Point coordinate\n * @param {Array<number>} coords2 Point coordinate\n * @returns {BBox} [west, south, east, north]\n */\nfunction bbox(coords1, coords2) {\n    var x1 = coords1[0];\n    var y1 = coords1[1];\n    var x2 = coords2[0];\n    var y2 = coords2[1];\n    var west = (x1 < x2) ? x1 : x2;\n    var south = (y1 < y2) ? y1 : y2;\n    var east = (x1 > x2) ? x1 : x2;\n    var north = (y1 > y2) ? y1 : y2;\n    return [west, south, east, north];\n}\nexports.default = lineSegment;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        var previousFeatureIndex = 0;\n        var previousMultiIndex = 0;\n        var prevGeomIndex = 0;\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n                previousCoords = currentCoord;\n                previousFeatureIndex = featureIndex;\n                previousMultiIndex = multiPartIndexCoord;\n                prevGeomIndex = geometryIndex;\n                segmentIndex = 0;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        if (feature.geometry === null) return;\n        var type = feature.geometry.type;\n        var coords = feature.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        var previousFeatureIndex = 0;\n        var previousMultiIndex = 0;\n        var prevGeomIndex = 0;\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n                previousCoords = currentCoord;\n                previousFeatureIndex = featureIndex;\n                previousMultiIndex = multiPartIndexCoord;\n                prevGeomIndex = geometryIndex;\n                segmentIndex = 0;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        if (feature.geometry === null) return;\n        var type = feature.geometry.type;\n        var coords = feature.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n","var rbush = require('rbush');\nvar helpers = require('@turf/helpers');\nvar meta = require('@turf/meta');\nvar turfBBox = require('@turf/bbox').default;\nvar featureEach = meta.featureEach;\nvar coordEach = meta.coordEach;\nvar polygon = helpers.polygon;\nvar featureCollection = helpers.featureCollection;\n\n/**\n * GeoJSON implementation of [RBush](https://github.com/mourner/rbush#rbush) spatial index.\n *\n * @name rbush\n * @param {number} [maxEntries=9] defines the maximum number of entries in a tree node. 9 (used by default) is a\n * reasonable choice for most applications. Higher value means faster insertion and slower search, and vice versa.\n * @returns {RBush} GeoJSON RBush\n * @example\n * var geojsonRbush = require('geojson-rbush').default;\n * var tree = geojsonRbush();\n */\nfunction geojsonRbush(maxEntries) {\n    var tree = rbush(maxEntries);\n    /**\n     * [insert](https://github.com/mourner/rbush#data-format)\n     *\n     * @param {Feature} feature insert single GeoJSON Feature\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     * tree.insert(poly)\n     */\n    tree.insert = function (feature) {\n        if (feature.type !== 'Feature') throw new Error('invalid feature');\n        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        return rbush.prototype.insert.call(this, feature);\n    };\n\n    /**\n     * [load](https://github.com/mourner/rbush#bulk-inserting-data)\n     *\n     * @param {FeatureCollection|Array<Feature>} features load entire GeoJSON FeatureCollection\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polys = turf.polygons([\n     *     [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]],\n     *     [[[-93, 32], [-83, 32], [-83, 39], [-93, 39], [-93, 32]]]\n     * ]);\n     * tree.load(polys);\n     */\n    tree.load = function (features) {\n        var load = [];\n        // Load an Array of Features\n        if (Array.isArray(features)) {\n            features.forEach(function (feature) {\n                if (feature.type !== 'Feature') throw new Error('invalid features');\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        } else {\n            // Load a FeatureCollection\n            featureEach(features, function (feature) {\n                if (feature.type !== 'Feature') throw new Error('invalid features');\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        }\n        return rbush.prototype.load.call(this, load);\n    };\n\n    /**\n     * [remove](https://github.com/mourner/rbush#removing-data)\n     *\n     * @param {Feature} feature remove single GeoJSON Feature\n     * @param {Function} equals Pass a custom equals function to compare by value for removal.\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.remove(poly);\n     */\n    tree.remove = function (feature, equals) {\n        if (feature.type !== 'Feature') throw new Error('invalid feature');\n        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        return rbush.prototype.remove.call(this, feature, equals);\n    };\n\n    /**\n     * [clear](https://github.com/mourner/rbush#removing-data)\n     *\n     * @returns {RBush} GeoJSON Rbush\n     * @example\n     * tree.clear()\n     */\n    tree.clear = function () {\n        return rbush.prototype.clear.call(this);\n    };\n\n    /**\n     * [search](https://github.com/mourner/rbush#search)\n     *\n     * @param {BBox|FeatureCollection|Feature} geojson search with GeoJSON\n     * @returns {FeatureCollection} all features that intersects with the given GeoJSON.\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.search(poly);\n     */\n    tree.search = function (geojson) {\n        var features = rbush.prototype.search.call(this, this.toBBox(geojson));\n        return featureCollection(features);\n    };\n\n    /**\n     * [collides](https://github.com/mourner/rbush#collisions)\n     *\n     * @param {BBox|FeatureCollection|Feature} geojson collides with GeoJSON\n     * @returns {boolean} true if there are any items intersecting the given GeoJSON, otherwise false.\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.collides(poly);\n     */\n    tree.collides = function (geojson) {\n        return rbush.prototype.collides.call(this, this.toBBox(geojson));\n    };\n\n    /**\n     * [all](https://github.com/mourner/rbush#search)\n     *\n     * @returns {FeatureCollection} all the features in RBush\n     * @example\n     * tree.all()\n     */\n    tree.all = function () {\n        var features = rbush.prototype.all.call(this);\n        return featureCollection(features);\n    };\n\n    /**\n     * [toJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @returns {any} export data as JSON object\n     * @example\n     * var exported = tree.toJSON()\n     */\n    tree.toJSON = function () {\n        return rbush.prototype.toJSON.call(this);\n    };\n\n    /**\n     * [fromJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @param {any} json import previously exported data\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var exported = {\n     *   \"children\": [\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"geometry\": {\n     *         \"type\": \"Point\",\n     *         \"coordinates\": [110, 50]\n     *       },\n     *       \"properties\": {},\n     *       \"bbox\": [110, 50, 110, 50]\n     *     }\n     *   ],\n     *   \"height\": 1,\n     *   \"leaf\": true,\n     *   \"minX\": 110,\n     *   \"minY\": 50,\n     *   \"maxX\": 110,\n     *   \"maxY\": 50\n     * }\n     * tree.fromJSON(exported)\n     */\n    tree.fromJSON = function (json) {\n        return rbush.prototype.fromJSON.call(this, json);\n    };\n\n    /**\n     * Converts GeoJSON to {minX, minY, maxX, maxY} schema\n     *\n     * @private\n     * @param {BBox|FeatureCollection|Feature} geojson feature(s) to retrieve BBox from\n     * @returns {Object} converted to {minX, minY, maxX, maxY}\n     */\n    tree.toBBox = function (geojson) {\n        var bbox;\n        if (geojson.bbox) bbox = geojson.bbox;\n        else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;\n        else if (Array.isArray(geojson) && geojson.length === 6) bbox = [geojson[0], geojson[1], geojson[3], geojson[4]];\n        else if (geojson.type === 'Feature') bbox = turfBBox(geojson);\n        else if (geojson.type === 'FeatureCollection') bbox = turfBBox(geojson);\n        else throw new Error('invalid geojson')\n\n        return {\n            minX: bbox[0],\n            minY: bbox[1],\n            maxX: bbox[2],\n            maxY: bbox[3]\n        };\n    };\n    return tree;\n}\n\nmodule.exports = geojsonRbush;\nmodule.exports.default = geojsonRbush;\n","'use strict';\n\nmodule.exports = rbush;\nmodule.exports.default = rbush;\n\nvar quickselect = require('quickselect');\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.quickselect = factory());\n}(this, (function () { 'use strict';\n\nfunction quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nreturn quickselect;\n\n})));\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        var previousFeatureIndex = 0;\n        var previousMultiIndex = 0;\n        var prevGeomIndex = 0;\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n                previousCoords = currentCoord;\n                previousFeatureIndex = featureIndex;\n                previousMultiIndex = multiPartIndexCoord;\n                prevGeomIndex = geometryIndex;\n                segmentIndex = 0;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        if (feature.geometry === null) return;\n        var type = feature.geometry.type;\n        var coords = feature.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar meta_1 = require(\"@turf/meta\");\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n    var result = [Infinity, Infinity, -Infinity, -Infinity];\n    meta_1.coordEach(geojson, function (coord) {\n        if (result[0] > coord[0]) {\n            result[0] = coord[0];\n        }\n        if (result[1] > coord[1]) {\n            result[1] = coord[1];\n        }\n        if (result[2] < coord[0]) {\n            result[2] = coord[0];\n        }\n        if (result[3] < coord[1]) {\n            result[3] = coord[1];\n        }\n    });\n    return result;\n}\nexports.default = bbox;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        var previousFeatureIndex = 0;\n        var previousMultiIndex = 0;\n        var prevGeomIndex = 0;\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n                previousCoords = currentCoord;\n                previousFeatureIndex = featureIndex;\n                previousMultiIndex = multiPartIndexCoord;\n                prevGeomIndex = geometryIndex;\n                segmentIndex = 0;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        if (feature.geometry === null) return;\n        var type = feature.geometry.type;\n        var coords = feature.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        var previousFeatureIndex = 0;\n        var previousMultiIndex = 0;\n        var prevGeomIndex = 0;\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n                previousCoords = currentCoord;\n                previousFeatureIndex = featureIndex;\n                previousMultiIndex = multiPartIndexCoord;\n                prevGeomIndex = geometryIndex;\n                segmentIndex = 0;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        if (feature.geometry === null) return;\n        var type = feature.geometry.type;\n        var coords = feature.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        var previousFeatureIndex = 0;\n        var previousMultiIndex = 0;\n        var prevGeomIndex = 0;\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n                previousCoords = currentCoord;\n                previousFeatureIndex = featureIndex;\n                previousMultiIndex = multiPartIndexCoord;\n                prevGeomIndex = geometryIndex;\n                segmentIndex = 0;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        if (feature.geometry === null) return;\n        var type = feature.geometry.type;\n        var coords = feature.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// https://en.wikipedia.org/wiki/Rhumb_line\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Calculates the distance along a rhumb line between two {@link Point|points} in degrees, radians,\n * miles, or kilometers.\n *\n * @name rhumbDistance\n * @param {Coord} from origin point\n * @param {Coord} to destination point\n * @param {Object} [options] Optional parameters\n * @param {string} [options.units=\"kilometers\"] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.rhumbDistance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction rhumbDistance(from, to, options) {\n    if (options === void 0) { options = {}; }\n    var origin = invariant_1.getCoord(from);\n    var destination = invariant_1.getCoord(to);\n    // compensate the crossing of the 180th meridian (https://macwright.org/2016/09/26/the-180th-meridian.html)\n    // solution from https://github.com/mapbox/mapbox-gl-js/issues/3250#issuecomment-294887678\n    destination[0] += (destination[0] - origin[0] > 180) ? -360 : (origin[0] - destination[0] > 180) ? 360 : 0;\n    var distanceInMeters = calculateRhumbDistance(origin, destination);\n    var distance = helpers_1.convertLength(distanceInMeters, \"meters\", options.units);\n    return distance;\n}\n/**\n * Returns the distance travelling from ‘this’ point to destination point along a rhumb line.\n * Adapted from Geodesy: https://github.com/chrisveness/geodesy/blob/master/latlon-spherical.js\n *\n * @private\n * @param   {Array<number>} origin point.\n * @param   {Array<number>} destination point.\n * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\n * @returns {number} Distance in km between this point and destination point (same units as radius).\n *\n * @example\n *     var p1 = new LatLon(51.127, 1.338);\n *     var p2 = new LatLon(50.964, 1.853);\n *     var d = p1.distanceTo(p2); // 40.31 km\n */\nfunction calculateRhumbDistance(origin, destination, radius) {\n    // φ => phi\n    // λ => lambda\n    // ψ => psi\n    // Δ => Delta\n    // δ => delta\n    // θ => theta\n    radius = (radius === undefined) ? helpers_1.earthRadius : Number(radius);\n    // see www.edwilliams.org/avform.htm#Rhumb\n    var R = radius;\n    var phi1 = origin[1] * Math.PI / 180;\n    var phi2 = destination[1] * Math.PI / 180;\n    var DeltaPhi = phi2 - phi1;\n    var DeltaLambda = Math.abs(destination[0] - origin[0]) * Math.PI / 180;\n    // if dLon over 180° take shorter rhumb line across the anti-meridian:\n    if (DeltaLambda > Math.PI) {\n        DeltaLambda -= 2 * Math.PI;\n    }\n    // on Mercator projection, longitude distances shrink by latitude; q is the 'stretch factor'\n    // q becomes ill-conditioned along E-W line (0/0); use empirical tolerance to avoid it\n    var DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));\n    var q = Math.abs(DeltaPsi) > 10e-12 ? DeltaPhi / DeltaPsi : Math.cos(phi1);\n    // distance is pythagoras on 'stretched' Mercator projection\n    var delta = Math.sqrt(DeltaPhi * DeltaPhi + q * q * DeltaLambda * DeltaLambda); // angular distance in radians\n    var dist = delta * R;\n    return dist;\n}\nexports.default = rhumbDistance;\n","let instance = null;\n\nexport default class LogBuffer {\n    constructor() {\n        if (!instance) {\n            this.buffer = [];\n            instance = this;\n        }\n\n        return instance;\n    }\n\n    add(message) {\n        this.buffer.push(message);\n    }\n\n    getLogs() {\n        return this.buffer;\n    }\n\n    cleanLogs() {\n        this.buffer = [];\n    }\n\n    static getInstance() {\n        return instance;\n    }\n}\n","export default function () {\n    const mapCanvasElement = $('div#map-canvas');\n\n    this.routeUrl = mapCanvasElement.attr('data-what');\n    this.routeParamsUrl = mapCanvasElement.attr('data-route-params');\n    this.routeApproveUrl = mapCanvasElement.attr('data-route-approve');\n    this.language = $('html').attr('lang');\n}\n","import logger from 'loglevel';\nimport * as _ from '../utils/lodash';\n\nconst pl = require('./pl');\nconst en = require('./en');\n\nconst translations = { pl, en };\n\nlet instance = null;\n\nexport default class Lang {\n    constructor(language) {\n        if (!instance) {\n            instance = this;\n\n            this.language = language;\n            this.translation = translations[this.language];\n\n            // Fallback to en if selected language not present\n            if (!this.translation) {\n                this.translation = translations.en;\n            }\n        }\n\n        return instance;\n    }\n\n    trans(literal, properties) {\n        const translatedLiteral = this.translation[literal];\n\n        let result = literal;\n        if (translatedLiteral) {\n            result = _.isEmpty(properties) ? translatedLiteral : _.template(translatedLiteral)(properties);\n        } else {\n            logger.warn(`No translation found for '${literal}'.`);\n        }\n\n        return result;\n    }\n\n    static getInstance() {\n        return instance;\n    }\n}\n","import logger from 'loglevel';\n\nimport * as _ from './utils/lodash';\n\n// Constants\nconst ROUTE_TYPE_ID = 'div#routeType';\nconst SINGLE_PATH_ID = 'div#singlePath';\nconst PATH_LENGTH_ID = 'div#pathLength';\nconst ELEVATION_GAIN_ID = 'div#elevationGain';\nconst ELEVATION_LOSS_ID = 'div#elevationLoss';\nconst ELEVATION_TOTAL_CHANGE_ID = 'div#elevationTotalChange';\nconst NUMBER_OF_STATIONS_ID = 'div#numberOfStations';\nconst STATIONS_ORDER_ID = 'div#stationsOrder';\nconst STATIONS_ON_PATH_ID = 'div#stationsOnPath';\nconst DATA_CONSISTENCY_ID = 'div#dataConsistency';\nconst ELEVATION_CHART_ID = 'canvas#elevationChart';\nconst VERIFY_BUTTON_ID = 'button#verifyRoute';\nconst LOADER_ID = 'div#loader';\nconst LOADER_ELEMENT = '<div id=\"loader\" class=\"overlay\"><i class=\"fa fa-refresh fa-spin\"></i></div>';\nconst ELEVATION_CHART_ELEMENT = '<canvas id=\"elevationChart\"></canvas>';\nconst SUCCESS_VERIFICATION_MODAL_ID = 'div#pageReloadModal';\nconst FAILED_VERIFICATION_MODAL_ID = 'div#verificationFailedModal';\nconst FAILED_VERIFICATION_MODAL_BODY = `${FAILED_VERIFICATION_MODAL_ID} div.modal-body`;\n\nconst updateControlColor = (element, isValid) => {\n    const VALID_COLOR_CLASS = 'bg-green';\n    const INVALID_COLOR_CLASS = 'bg-yellow';\n    const INFO_BOX_ICON = 'span.info-box-icon';\n\n    if (_.isNull(isValid)) {\n        $(`${element} ${INFO_BOX_ICON}`).removeClass([INVALID_COLOR_CLASS, VALID_COLOR_CLASS].join(' '));\n    } else {\n        (isValid)\n            ? $(`${element} ${INFO_BOX_ICON}`).removeClass(INVALID_COLOR_CLASS).addClass(VALID_COLOR_CLASS)\n            : $(`${element} ${INFO_BOX_ICON}`).removeClass(VALID_COLOR_CLASS).addClass(INVALID_COLOR_CLASS);\n    }\n};\n\nconst updateControlValue = (element, value, unit) => {\n    const INFO_BOX_NUMBER = 'span.info-box-number';\n\n    logger.debug('Updating control element', element, 'with:', value, unit);\n    $(`${element} ${INFO_BOX_NUMBER}`).html(`${value} ${unit ? `<small>${unit}</small>` : ''}`);\n};\n\nconst removeControlChildren = element => {\n    $(ELEVATION_CHART_ID).empty();\n};\n\n\nexport default class Controls {\n    // Constructor\n\n\n    updateRouteType(isNormalRoute) {\n        const normalRouteString = $('input#normalRouteString').attr('value');\n        const inspiredRouteString = $('input#inspiredRouteString').attr('value');\n        updateControlValue(ROUTE_TYPE_ID, isNormalRoute ? normalRouteString : inspiredRouteString);\n        updateControlColor(ROUTE_TYPE_ID, true);\n    }\n\n    updatePathLength(isLengthValid, length) {\n        updateControlValue(PATH_LENGTH_ID, length.toFixed(2), 'km');\n        updateControlColor(PATH_LENGTH_ID, isLengthValid);\n    }\n\n    updateElevationGain(isElevationGainValid, elevationGain) {\n        updateControlValue(ELEVATION_GAIN_ID, elevationGain.toFixed(2), 'm');\n        updateControlColor(ELEVATION_GAIN_ID, isElevationGainValid);\n    }\n\n    updateElevationLoss(isElevationLossValid, elevationLoss) {\n        updateControlValue(ELEVATION_LOSS_ID, elevationLoss.toFixed(2), 'm');\n        updateControlColor(ELEVATION_LOSS_ID, isElevationLossValid);\n    }\n\n    updateElevationTotalChange(isElevationTotalChangeValid, elevationTotalChange) {\n        updateControlValue(ELEVATION_TOTAL_CHANGE_ID, elevationTotalChange.toFixed(2), 'm');\n        updateControlColor(ELEVATION_TOTAL_CHANGE_ID, isElevationTotalChangeValid);\n    }\n\n    updateNumberOfStations(areAllStationsPresent) {\n        updateControlColor(NUMBER_OF_STATIONS_ID, areAllStationsPresent);\n    }\n\n    updateStationsOrder(isStationOrderCorrect) {\n        updateControlColor(STATIONS_ORDER_ID, isStationOrderCorrect);\n    }\n\n    updateStationsOnPath(areAllStationsOnPath) {\n        updateControlColor(STATIONS_ON_PATH_ID, areAllStationsOnPath);\n    }\n\n    updateSinglePath(isSinglePath) {\n        updateControlColor(SINGLE_PATH_ID, isSinglePath);\n    }\n\n    updateDataConsistency(isDataConsistent) {\n        updateControlColor(DATA_CONSISTENCY_ID, isDataConsistent);\n    }\n\n    drawElevationChart(pathElevation) {\n        const X_AXIS_NUMBER_OF_LABELS = 10;\n        const X_AXIS_LABEL_STRING = '[km]';\n        const Y_AXIS_LABEL_STRING = '[m]';\n        const CHART_BACKGROUND_COLOR = 'rgb(32, 77, 116)';\n\n        const labelWidth = parseInt(pathElevation.data.length / X_AXIS_NUMBER_OF_LABELS);\n        const labels = _.map(pathElevation.data, elevation => elevation.distance.toFixed());\n        const data = _.map(pathElevation.data, elevation => elevation.elevation);\n\n        logger.debug('Drawing elevation chart. Input:', pathElevation);\n\n        const elevationChart = new Chart($(ELEVATION_CHART_ID), {\n            type: 'line',\n            data: {\n                labels,\n                datasets: [{\n                    label: '',\n                    data,\n                    fill: 'start',\n                    radius: 0,\n                    backgroundColor: CHART_BACKGROUND_COLOR,\n                }],\n            },\n            options: {\n                scales: {\n                    xAxes: [{\n                        scaleLabel: {\n                            display: true,\n                            labelString: X_AXIS_LABEL_STRING,\n                        },\n                        ticks: {\n                            callback: (dataLabel, index) => (index % labelWidth === 0\n                                || (index === pathElevation.data.length - 1)\n                                ? dataLabel\n                                : null)\n                            ,\n                        },\n                    }],\n                    yAxes: [{\n                        scaleLabel: {\n                            display: true,\n                            labelString: Y_AXIS_LABEL_STRING,\n                        },\n                    }],\n                },\n                legend: {\n                    display: false,\n                },\n                tooltips: {\n                    enabled: false,\n                },\n            },\n        });\n    }\n\n    resetElevationChart() {\n        const elevationChartParentElement = $(ELEVATION_CHART_ID).parent();\n        $(ELEVATION_CHART_ID).remove();\n        elevationChartParentElement.append(ELEVATION_CHART_ELEMENT);\n    }\n\n    resetFailedVerificationModal() {\n        $(FAILED_VERIFICATION_MODAL_BODY).children().remove();\n    }\n\n    addLoaderToButton() {\n        $(VERIFY_BUTTON_ID).append(LOADER_ELEMENT);\n    }\n\n    removeLoaderFromButton() {\n        $(`${VERIFY_BUTTON_ID} ${LOADER_ID}`).remove();\n    }\n\n    resetAll(value) {\n        const text = '';\n        const isValid = value === undefined ? null : value;\n\n        updateControlValue(ROUTE_TYPE_ID, text);\n        updateControlColor(ROUTE_TYPE_ID, isValid);\n        updateControlValue(PATH_LENGTH_ID, text);\n        updateControlColor(PATH_LENGTH_ID, isValid);\n        updateControlValue(ELEVATION_GAIN_ID, text);\n        updateControlColor(ELEVATION_GAIN_ID, isValid);\n        updateControlValue(ELEVATION_LOSS_ID, text);\n        updateControlColor(ELEVATION_LOSS_ID, isValid);\n        updateControlValue(ELEVATION_TOTAL_CHANGE_ID, text);\n        updateControlColor(ELEVATION_TOTAL_CHANGE_ID, isValid);\n        updateControlColor(NUMBER_OF_STATIONS_ID, isValid);\n        updateControlColor(STATIONS_ORDER_ID, isValid);\n        updateControlColor(STATIONS_ON_PATH_ID, isValid);\n        updateControlColor(SINGLE_PATH_ID, isValid);\n        updateControlColor(DATA_CONSISTENCY_ID, isValid);\n        this.resetElevationChart();\n        this.resetFailedVerificationModal();\n    }\n\n    showVerificationSuccessModal(timeout) {\n        const reloadTimeout = setTimeout(() => {\n            window.location.reload(1);\n        }, timeout);\n        $(SUCCESS_VERIFICATION_MODAL_ID).on('hide.bs.modal', e => clearTimeout(reloadTimeout));\n        $(SUCCESS_VERIFICATION_MODAL_ID).modal();\n    }\n\n    showVerificationFailedModal(errors = []) {\n        let errorsListHtml = '';\n        errorsListHtml += '<div><ul>';\n        errors.forEach(error => { errorsListHtml += `<li>${error}</li>`; });\n        errorsListHtml += '</ul></div>';\n\n        $(FAILED_VERIFICATION_MODAL_BODY).append(errorsListHtml);\n        $(FAILED_VERIFICATION_MODAL_ID).modal();\n    }\n}\n","/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325,\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nvar unitsFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000,\n    millimetres: 1000,\n    centimeters: 100,\n    centimetres: 100,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    miles: 1 / 1609.344,\n    nauticalmiles: 1 / 1852,\n    inches: 39.370,\n    yards: 1 / 1.0936,\n    feet: 3.28084,\n    radians: 1 / earthRadius,\n    degrees: 1 / 111325,\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nvar areaFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    centimeters: 10000,\n    centimetres: 10000,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox) validateBBox(bbox);\n\n    // Main\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (length === null || length === undefined) throw new Error('length is required');\n    if (!(length >= 0)) throw new Error('length must be a positive number');\n\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) throw new Error('bbox is required');\n    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n    });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) throw new Error('id is required');\n    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nfunction degrees2radians() {\n    throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nfunction distanceToDegrees() {\n    throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nfunction distanceToRadians() {\n    throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nfunction radiansToDistance() {\n    throw new Error('method has been renamed to `radiansToLength`');\n}\n\nfunction bearingToAngle() {\n    throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nfunction convertDistance() {\n    throw new Error('method has been renamed to `convertLength`');\n}\n\nexport { earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId, radians2degrees, degrees2radians, distanceToDegrees, distanceToRadians, radiansToDistance, bearingToAngle, convertDistance };\n","import { feature, isObject, lineString, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    if (geomType === 'MultiPolygon') geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature$$1.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature$$1.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        if (coordEach(feature$$1, function (currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined) {\n                previousCoords = currentCoord;\n                return;\n            }\n            var currentSegment = lineString([previousCoords, currentCoord], feature$$1.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        if (feature$$1.geometry === null) return;\n        var type = feature$$1.geometry.type;\n        var coords = feature$$1.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(lineString(coords[geometryIndex], feature$$1.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexport { coordEach, coordReduce, propEach, propReduce, featureEach, featureReduce, coordAll, geomEach, geomReduce, flattenEach, flattenReduce, segmentEach, segmentReduce, lineEach, lineReduce, findSegment, findPoint };\n","/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325,\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nvar unitsFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000,\n    millimetres: 1000,\n    centimeters: 100,\n    centimetres: 100,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    miles: 1 / 1609.344,\n    nauticalmiles: 1 / 1852,\n    inches: 39.370,\n    yards: 1 / 1.0936,\n    feet: 3.28084,\n    radians: 1 / earthRadius,\n    degrees: 1 / 111325,\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nvar areaFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    centimeters: 10000,\n    centimetres: 10000,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox) validateBBox(bbox);\n\n    // Main\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (length === null || length === undefined) throw new Error('length is required');\n    if (!(length >= 0)) throw new Error('length must be a positive number');\n\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) throw new Error('bbox is required');\n    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n    });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) throw new Error('id is required');\n    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nfunction degrees2radians() {\n    throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nfunction distanceToDegrees() {\n    throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nfunction distanceToRadians() {\n    throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nfunction radiansToDistance() {\n    throw new Error('method has been renamed to `radiansToLength`');\n}\n\nfunction bearingToAngle() {\n    throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nfunction convertDistance() {\n    throw new Error('method has been renamed to `convertLength`');\n}\n\nexport { earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId, radians2degrees, degrees2radians, distanceToDegrees, distanceToRadians, radiansToDistance, bearingToAngle, convertDistance };\n","import { flattenEach } from '@turf/meta';\nimport { featureCollection } from '@turf/helpers';\n\n/**\n * Flattens any {@link GeoJSON} to a {@link FeatureCollection} inspired by [geojson-flatten](https://github.com/tmcw/geojson-flatten).\n *\n * @name flatten\n * @param {GeoJSON} geojson any valid GeoJSON Object\n * @returns {FeatureCollection<any>} all Multi-Geometries are flattened into single Features\n * @example\n * var multiGeometry = turf.multiPolygon([\n *   [[[102.0, 2.0], [103.0, 2.0], [103.0, 3.0], [102.0, 3.0], [102.0, 2.0]]],\n *   [[[100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0]],\n *   [[100.2, 0.2], [100.8, 0.2], [100.8, 0.8], [100.2, 0.8], [100.2, 0.2]]]\n * ]);\n *\n * var flatten = turf.flatten(multiGeometry);\n *\n * //addToMap\n * var addToMap = [flatten]\n */\nfunction flatten(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n\n    var results = [];\n    flattenEach(geojson, function (feature) {\n        results.push(feature);\n    });\n    return featureCollection(results);\n}\n\nexport default flatten;\n","import toGeoJSON from 'togeojson';\nimport flatten from '@turf/flatten';\nimport logger from 'loglevel';\nimport * as _ from './lodash';\n\n\nexport default class Helpers {\n    static getGeoJSON(kml) {\n        const extendedData = kml.getElementsByTagName('ExtendedData');\n        for (let index = extendedData.length - 1; index >= 0; index--) {\n            extendedData[index].parentNode.removeChild(extendedData[index]);\n        }\n        logger.log('KML (no ExtendedData):', kml);\n\n        let geoJson = toGeoJSON.kml(kml);\n        geoJson = flatten(geoJson);\n        logger.log('GeoJSON (flatten): ', geoJson);\n\n        return geoJson;\n    }\n\n    static getNumberOfFeatures(featureName, geoJson) {\n        const features = _.filter(geoJson.features,\n            feature => _.isEqual(feature.geometry.type, featureName));\n        return features.length;\n    }\n\n    static getLineString(geoJson) {\n        const lineString = _.find(geoJson.features,\n            feature => _.isEqual(feature.geometry.type, 'LineString'));\n        return lineString;\n    }\n\n    static getDistanceToNearestPointOnLine(point) {\n        return _.get(point, 'properties.nearestOnLine.properties.dist', Number.MAX_VALUE);\n    }\n\n    static getLocationOfNearestPointOnLine(point) {\n        return _.get(point, 'properties.nearestOnLine.properties.location', 0);\n    }\n\n    static reverseLineString(lineString) {\n        const newLineString = { ...lineString };\n        newLineString.geometry.coordinates = lineString.geometry.coordinates.reverse();\n        return newLineString;\n    }\n\n    static getPoints(geoJson) {\n        const points = _.filter(geoJson.features,\n            feature => _.isEqual(feature.geometry.type, 'Point'));\n        return points;\n    }\n\n    static getRoute(routeUrl) {\n        logger.debug('Fetching route from:', routeUrl);\n        return new Promise((resolve, reject) => {\n            $.ajax(routeUrl)\n                .done(data => {\n                    logger.debug('Route data:', data);\n                    resolve(data);\n                })\n                .fail((xhr, status) => {\n                    logger.error(`Route fetching error. Status: ${status}`);\n                    reject('Route fetching error');\n                });\n        });\n    }\n\n    static getGoogleMapsLatLng(coordinates) {\n        return new google.maps.LatLng(coordinates[1], coordinates[0]);\n    }\n\n    static getGoogleMapsPath(lineString) {\n        const path = _.map(lineString.geometry.coordinates,\n            element => Helpers.getGoogleMapsLatLng(element));\n        return path;\n    }\n\n    static getPathElevations(lineString, useLocalElevations) {\n        if (useLocalElevations && lineString.geometry.coordinates[0].length === 3) {\n            // Elevation present in line string\n\n            logger.debug('Getting path elevations from line string...');\n            const elevations = _.map(lineString.geometry.coordinates,\n                element => ({ elevation: element[2] }));\n            logger.debug('Elevations:', elevations);\n            return new Promise((resolve, reject) => {\n                resolve(elevations);\n            });\n        }\n        // No elevation in line string\n        let path = this.getGoogleMapsPath(lineString);\n\n        // Optimize path array length\n        // This is done to send no more than\n        // MAXIMUM_NUMBER_OF_LATLNG_OBJECTS coordinates in KML path\n        const MAXIMUM_NUMBER_OF_SAMPLES = 512;\n        // Request to google.maps.ElevationService cannot be too long (2048 is too long)\n        const MAXIMUM_NUMBER_OF_LATLNG_OBJECTS = 1024;\n        logger.debug('Number of LatLng objects:', path.length);\n        if (path.length > MAXIMUM_NUMBER_OF_LATLNG_OBJECTS) {\n            const optimizedPath = [];\n            const delta = parseFloat(path.length / MAXIMUM_NUMBER_OF_LATLNG_OBJECTS);\n            for (let i = 0; i < path.length; i += delta) {\n                optimizedPath.push(path[Math.floor(i)]);\n            }\n            path = optimizedPath;\n            logger.debug('Number of LatLng objects after optimization:', path.length);\n        }\n\n        return new Promise((resolve, reject) => {\n            const elevator = new google.maps.ElevationService();\n            elevator.getElevationAlongPath({\n                path,\n                samples: MAXIMUM_NUMBER_OF_SAMPLES,\n            }, (elevations, status) => {\n                if (status === google.maps.ElevationStatus.OK) {\n                    resolve(elevations);\n                } else {\n                    reject(status);\n                }\n            });\n        });\n    }\n\n    static getRouteParameters(routeParamsUrl) {\n        return new Promise((resolve, reject) => {\n            $.ajax(routeParamsUrl)\n                .done(data => {\n                    logger.debug('Route parameters:', data);\n                    if (data.success === 1) {\n                        resolve(data);\n                    } else {\n                        reject(`Server side error: ${data.error}`);\n                    }\n                })\n                .fail((xhr, status) => {\n                    logger.error(`Route parameters data fetching error. Status: ${status}`);\n                    reject('Route parameters data fetching error');\n                });\n        });\n    }\n\n    static approveRoute(routeApproveUrl) {\n        return new Promise((resolve, reject) => {\n            $.ajax(routeApproveUrl)\n                .done(data => {\n                    resolve({ success: true });\n                })\n                .fail((xhr, status) => {\n                    reject(status);\n                });\n        });\n    }\n}\n","const getGain = elevations => {\n    let elevationGain = 0.0;\n    for (let i = 1; i < elevations.length; i++) {\n        const elevationDifference = elevations[i].elevation - elevations[i - 1].elevation;\n        elevationGain += (elevationDifference > 0) ? elevationDifference : 0.0;\n    }\n    return Number(elevationGain);\n};\n\nconst getLoss = elevations => {\n    let elevationLoss = 0.0;\n    for (let i = 1; i < elevations.length; i++) {\n        const elevationDifference = elevations[i - 1].elevation - elevations[i].elevation;\n        elevationLoss += (elevationDifference > 0) ? elevationDifference : 0.0;\n    }\n    return Number(elevationLoss);\n};\n\n\nexport default class PathElevation {\n    constructor(elevations, length) {\n        this.gain = getGain(elevations);\n        this.loss = getLoss(elevations);\n        this.totalChange = this.loss + this.gain;\n        this.data = elevations;\n    }\n\n    enrichData(length) {\n        const elevationsWithDistance = [];\n        const resolution = length / this.data.length;\n        for (let i = 0; i < this.data.length; i++) {\n            elevationsWithDistance.push({\n                elevation: this.data[i].elevation, distance: i * resolution,\n            });\n        }\n        this.data = elevationsWithDistance;\n    }\n}\n","/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325,\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nvar unitsFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000,\n    millimetres: 1000,\n    centimeters: 100,\n    centimetres: 100,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    miles: 1 / 1609.344,\n    nauticalmiles: 1 / 1852,\n    inches: 39.370,\n    yards: 1 / 1.0936,\n    feet: 3.28084,\n    radians: 1 / earthRadius,\n    degrees: 1 / 111325,\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nvar areaFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    centimeters: 10000,\n    centimetres: 10000,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox) validateBBox(bbox);\n\n    // Main\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (length === null || length === undefined) throw new Error('length is required');\n    if (!(length >= 0)) throw new Error('length must be a positive number');\n\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) throw new Error('bbox is required');\n    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n    });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) throw new Error('id is required');\n    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nfunction degrees2radians() {\n    throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nfunction distanceToDegrees() {\n    throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nfunction distanceToRadians() {\n    throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nfunction radiansToDistance() {\n    throw new Error('method has been renamed to `radiansToLength`');\n}\n\nfunction bearingToAngle() {\n    throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nfunction convertDistance() {\n    throw new Error('method has been renamed to `convertLength`');\n}\n\nexport { earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId, radians2degrees, degrees2radians, distanceToDegrees, distanceToRadians, radiansToDistance, bearingToAngle, convertDistance };\n","import { isNumber } from '@turf/helpers';\n\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(coord) {\n    if (!coord) throw new Error('coord is required');\n    if (coord.type === 'Feature' && coord.geometry !== null && coord.geometry.type === 'Point') return coord.geometry.coordinates;\n    if (coord.type === 'Point') return coord.coordinates;\n    if (Array.isArray(coord) && coord.length >= 2 && coord[0].length === undefined && coord[1].length === undefined) return coord;\n\n    throw new Error('coord must be GeoJSON Point or an Array of numbers');\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nfunction getCoords(coords) {\n    if (!coords) throw new Error('coords is required');\n\n    // Feature\n    if (coords.type === 'Feature' && coords.geometry !== null) return coords.geometry.coordinates;\n\n    // Geometry\n    if (coords.coordinates) return coords.coordinates;\n\n    // Array of numbers\n    if (Array.isArray(coords)) return coords;\n\n    throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates) {\n    if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nfunction getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\nfunction getGeomType() {\n    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nfunction getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n\nexport { getCoord, getCoords, containsNumber, geojsonType, featureOf, collectionOf, getGeom, getGeomType, getType };\n","import { getCoord } from '@turf/invariant';\nimport { degreesToRadians, isObject, radiansToDegrees } from '@turf/helpers';\n\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n\n/**\n * Takes two {@link Point|points} and finds the geographic bearing between them,\n * i.e. the angle measured in degrees from the north line (0 degrees)\n *\n * @name bearing\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.final=false] calculates the final bearing if true\n * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)\n * @example\n * var point1 = turf.point([-75.343, 39.984]);\n * var point2 = turf.point([-75.534, 39.123]);\n *\n * var bearing = turf.bearing(point1, point2);\n *\n * //addToMap\n * var addToMap = [point1, point2]\n * point1.properties['marker-color'] = '#f00'\n * point2.properties['marker-color'] = '#0f0'\n * point1.properties.bearing = bearing\n */\nfunction bearing(start, end, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var final = options.final;\n\n    // Reverse calculation\n    if (final === true) return calculateFinalBearing(start, end);\n\n    var coordinates1 = getCoord(start);\n    var coordinates2 = getCoord(end);\n\n    var lon1 = degreesToRadians(coordinates1[0]);\n    var lon2 = degreesToRadians(coordinates2[0]);\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n    var b = Math.cos(lat1) * Math.sin(lat2) -\n        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n\n    return radiansToDegrees(Math.atan2(a, b));\n}\n\n/**\n * Calculates Final Bearing\n *\n * @private\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @returns {number} bearing\n */\nfunction calculateFinalBearing(start, end) {\n    // Swap start & end\n    var bear = bearing(end, start);\n    bear = (bear + 180) % 360;\n    return bear;\n}\n\nexport default bearing;\n","import { getCoord } from '@turf/invariant';\nimport { degreesToRadians, isObject, radiansToLength } from '@turf/helpers';\n\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians,\n * miles, or kilometers. This uses the\n * [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula)\n * to account for global curvature.\n *\n * @name distance\n * @param {Coord} from origin point\n * @param {Coord} to destination point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.distance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var units = options.units;\n\n    var coordinates1 = getCoord(from);\n    var coordinates2 = getCoord(to);\n    var dLat = degreesToRadians((coordinates2[1] - coordinates1[1]));\n    var dLon = degreesToRadians((coordinates2[0] - coordinates1[0]));\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n          Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n\n    return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), units);\n}\n\nexport default distance;\n","import { getCoord } from '@turf/invariant';\nimport { degreesToRadians, isObject, lengthToRadians, point, radiansToDegrees } from '@turf/helpers';\n\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in degrees, radians, miles, or kilometers; and bearing in degrees. This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Coord} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {Object} [options.properties={}] Translate properties to Point\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.destination(point, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\nfunction destination(origin, distance, bearing, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var units = options.units;\n    var properties = options.properties;\n\n    // Handle input\n    var coordinates1 = getCoord(origin);\n    var longitude1 = degreesToRadians(coordinates1[0]);\n    var latitude1 = degreesToRadians(coordinates1[1]);\n    var bearing_rad = degreesToRadians(bearing);\n    var radians = lengthToRadians(distance, units);\n\n    // Main\n    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearing_rad));\n    var longitude2 = longitude1 + Math.atan2(Math.sin(bearing_rad) * Math.sin(radians) * Math.cos(latitude1),\n        Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n    var lng = radiansToDegrees(longitude2);\n    var lat = radiansToDegrees(latitude2);\n\n    return point([lng, lat], properties);\n}\n\nexport default destination;\n","import bearing from '@turf/bearing';\nimport distance from '@turf/distance';\nimport destination from '@turf/destination';\nimport { isObject, lineString } from '@turf/helpers';\n\n/**\n * Takes a {@link LineString|line}, a specified distance along the line to a start {@link Point},\n * and a specified  distance along the line to a stop point\n * and returns a subsection of the line in-between those points.\n *\n * This can be useful for extracting only the part of a route between two distances.\n *\n * @name lineSliceAlong\n * @param {Feature<LineString>|LineString} line input line\n * @param {number} startDist distance along the line to starting point\n * @param {number} stopDist distance along the line to ending point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<LineString>} sliced line\n * @example\n * var line = turf.lineString([[7, 45], [9, 45], [14, 40], [14, 41]]);\n * var start = 12.5;\n * var stop = 25;\n * var sliced = turf.lineSliceAlong(line, start, stop, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line, start, stop, sliced]\n */\nfunction lineSliceAlong(line, startDist, stopDist, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n\n    var coords;\n    var slice = [];\n\n    // Validation\n    if (line.type === 'Feature') coords = line.geometry.coordinates;\n    else if (line.type === 'LineString') coords = line.coordinates;\n    else throw new Error('input must be a LineString Feature or Geometry');\n\n    var travelled = 0;\n    var overshot, direction, interpolated;\n    for (var i = 0; i < coords.length; i++) {\n        if (startDist >= travelled && i === coords.length - 1) break;\n        else if (travelled > startDist && slice.length === 0) {\n            overshot = startDist - travelled;\n            if (!overshot) {\n                slice.push(coords[i]);\n                return lineString(slice);\n            }\n            direction = bearing(coords[i], coords[i - 1]) - 180;\n            interpolated = destination(coords[i], overshot, direction, options);\n            slice.push(interpolated.geometry.coordinates);\n        }\n\n        if (travelled >= stopDist) {\n            overshot = stopDist - travelled;\n            if (!overshot) {\n                slice.push(coords[i]);\n                return lineString(slice);\n            }\n            direction = bearing(coords[i], coords[i - 1]) - 180;\n            interpolated = destination(coords[i], overshot, direction, options);\n            slice.push(interpolated.geometry.coordinates);\n            return lineString(slice);\n        }\n\n        if (travelled >= startDist) {\n            slice.push(coords[i]);\n        }\n\n        if (i === coords.length - 1) {\n            return lineString(slice);\n        }\n\n        travelled += distance(coords[i], coords[i + 1], options);\n    }\n    return lineString(coords[coords.length - 1]);\n}\n\nexport default lineSliceAlong;\n","import length from '@turf/length';\nimport lineSliceAlong from '@turf/line-slice-along';\nimport nearestPointOnLine from '@turf/nearest-point-on-line';\nimport pointToLineDistance from '@turf/point-to-line-distance';\nimport distance from '@turf/distance';\nimport { point } from '@turf/helpers';\nimport logger from 'loglevel';\n\nimport * as _ from './utils/lodash';\nimport helpers from './utils/helpers';\nimport Lang from './lang/Lang';\nimport LogBuffer from './utils/LogBuffer';\n\n\nconst turf = {\n    distance,\n    length,\n    lineSliceAlong,\n    point,\n    pointToLineDistance,\n    nearestPointOnLine,\n\n    options: { units: 'meters' },\n};\n\nconst CONSTS = {\n    START_INDEX: 0,\n    FIRST_STATION_INDEX: 1,\n    LAST_STATION_INDEX: 14,\n    END_INDEX: 15,\n};\n\nlet lang = null;\nlet logBuffer = null;\n\nexport default class Stations {\n    constructor(points, lineString) {\n        this.points = points;\n        this.path = lineString;\n        this.pathReversed = false;\n        this.pathCircular = false;\n\n        // Map points to stations and sort\n        this.addIndexes();\n        this.sortByIndex();\n\n        // Path circular check\n        this.pathStart = turf.point(this.path.geometry.coordinates[0]);\n        this.pathEnd = turf.point(this.path.geometry.coordinates[this.path.geometry.coordinates.length - 1]);\n        this.updateCircularity();\n\n        // Path reverse check\n        this.updateDirection();\n\n        // Stations to path mapping\n        this.findNearestPointsOnPath();\n        this.sortByLocationOnPath();\n\n        lang = Lang.getInstance();\n        logBuffer = LogBuffer.getInstance();\n    }\n\n    findNearestPointsOnPath() {\n        const stepDistance = turf.length(this.path, turf.options) / 10;\n        const sampleDistance = stepDistance / 10;\n\n        let nearestPointOnSlicedPath = null;\n        _.forEach(this.points, point => {\n            // Filter out point if it is too far from path\n            const coordinates = point.geometry.coordinates;\n            const distanceToPath = turf.pointToLineDistance(coordinates, this.path, turf.options);\n            const maximumDistanceFromPath = 200; // meters\n            if (distanceToPath > maximumDistanceFromPath) {\n                logger.debug(`Point ${point.properties.name} too far from the path. `\n                    + 'Not looking for nearest point on line for it.');\n                point.properties.nearestOnLine = turf.nearestPointOnLine(this.path, point, turf.options);\n                return true;\n            }\n\n            // Find nearest point on line for the specific station\n            logger.debug(`Looking for nearest point on line for ${point.properties.name}`);\n\n            // Set start and stop point of the sliced path traversal\n            const startPointDistance = _.get(nearestPointOnSlicedPath, 'properties.location', 0);\n            let stopPointDistance = startPointDistance + stepDistance;\n\n            // Reset nearest point on sliced path\n            nearestPointOnSlicedPath = null;\n\n            for (let oldDistanceToPath = 0, newDistanceToPath = Number.MAX_VALUE;\n                newDistanceToPath !== oldDistanceToPath || newDistanceToPath > maximumDistanceFromPath;\n                stopPointDistance += sampleDistance) {\n                const slicedPath = turf.lineSliceAlong(this.path, startPointDistance, stopPointDistance, turf.options);\n                nearestPointOnSlicedPath = turf.nearestPointOnLine(slicedPath, point, turf.options);\n                oldDistanceToPath = newDistanceToPath;\n                newDistanceToPath = turf.pointToLineDistance(coordinates, slicedPath, turf.options);\n            }\n\n            // Save nearest point on line for the specific station\n            point.properties.nearestOnLine = nearestPointOnSlicedPath;\n\n            // Update location on line (starting from the path beginning)\n            point.properties.nearestOnLine.properties.location += startPointDistance;\n\n            const dist = point.properties.nearestOnLine.properties.dist;\n            const location = point.properties.nearestOnLine.properties.location;\n            logger.debug(`Distance from path: ${dist.toFixed(2)} meter(s).`);\n            logger.debug(`Location on path: ${location.toFixed(2)} meter(s).`);\n\n            this.addDebugInformationToMap(point, nearestPointOnSlicedPath);\n        });\n    }\n\n    addDebugInformationToMap(originalPoint, nearestPoint) {\n        if (logger.getLevel() <= logger.levels.DEBUG && !!window.map) {\n            new google.maps.Marker({\n                position: helpers.getGoogleMapsLatLng(nearestPoint.geometry.coordinates),\n                map: window.map,\n                label: {\n                    fontWeight: 'bold',\n                    text: `${originalPoint.properties.index}`,\n                },\n                title: `${originalPoint.properties.index}`,\n                icon: 'https://maps.google.com/mapfiles/ms/icons/yellow.png',\n            });\n            new google.maps.Marker({\n                position: helpers.getGoogleMapsLatLng(originalPoint.geometry.coordinates),\n                map: window.map,\n                label: {\n                    fontWeight: 'bold',\n                    text: `${originalPoint.properties.index}`,\n                },\n                title: `${originalPoint.properties.index}`,\n                icon: 'https://maps.google.com/mapfiles/ms/icons/blue.png',\n            });\n        }\n    }\n\n    sortByIndex() {\n        const getIndex = point => _.get(point, 'properties.index', Number.MAX_VALUE);\n        this.points = _.sortBy(this.points, point => getIndex(point));\n    }\n\n    sortByLocationOnPath() {\n        const getLocation = point => _.get(point, 'properties.nearestOnLine.properties.location', Number.MAX_VALUE);\n        this.points = _.sortBy(this.points, point => getLocation(point));\n    }\n\n    addIndexes() {\n        const getIndex = str => {\n            /** Regular expressions for extracting station number\n             *  from a given string (which might be represented by different types\n             *  of numbers and different delimiters)\n             */\n            const START_NAMES_REGEX = /^(wstęp|wprowadzenie|początek|start)$/ig;\n            const END_NAMES_REGEX = /^(zakończenie|koniec|podsumowanie)$/ig;\n            const ROMAN_NUMBERS_REGEX = /^(I|II|III|IV|V|VI|VII|VIII|IX|X|XI|XII|XIII|XIV)$/g;\n            const EUROPEAN_NUMBERS_REGEX = /^\\d+$/g;\n            const SPLITTER_REGEX = /[ ,\\._\\-:;]+/;\n            const ROMAN_EUROPEAN_MAP = {\n                I: 1,\n                II: 2,\n                III: 3,\n                IV: 4,\n                V: 5,\n                VI: 6,\n                VII: 7,\n                VIII: 8,\n                IX: 9,\n                X: 10,\n                XI: 11,\n                XII: 12,\n                XIII: 13,\n                XIV: 14,\n            };\n\n            let index = null;\n\n            logger.debug(`Checking station index for string: ${str}`);\n\n            // noname station\n            if (!str) {\n                return index;\n            }\n\n            // split\n            const parts = str.trim().split(SPLITTER_REGEX);\n\n            _.forEach(parts, part => {\n                // try roman numbers\n                // it isn't clear why there are for matches declaration\n                let matches = part.match(ROMAN_NUMBERS_REGEX);\n                if (!_.isNull(matches)) {\n                    index = ROMAN_EUROPEAN_MAP[matches[0]];\n                    return false;\n                }\n\n                // try european numbers\n                matches = part.match(EUROPEAN_NUMBERS_REGEX);\n                if (!_.isNull(matches)) {\n                    const stationNumber = parseInt(matches[0]);\n                    if (stationNumber >= CONSTS.FIRST_STATION_INDEX\n                        && stationNumber <= CONSTS.LAST_STATION_INDEX) {\n                        index = stationNumber;\n                        return false;\n                    }\n                    return true;\n                }\n\n                // try start names\n                matches = part.match(START_NAMES_REGEX);\n                if (!_.isNull(matches)) {\n                    index = CONSTS.START_INDEX;\n                    return false;\n                }\n\n                // try end names\n                matches = part.match(END_NAMES_REGEX);\n                if (!_.isNull(matches)) {\n                    index = CONSTS.END_INDEX;\n                    return false;\n                }\n            });\n\n            return index;\n        };\n\n        this.points = _.map(this.points, point => {\n            const name = point.properties.name;\n\n            point.properties.index = getIndex(name);\n            return point;\n        });\n    }\n\n    updateDirection() {\n        const isIndexEqual = (point, index) => point.properties.index === index;\n        const startPoint = _.filter(this.points,\n            point => isIndexEqual(point, CONSTS.START_INDEX) || isIndexEqual(point, CONSTS.FIRST_STATION_INDEX));\n        const endPoint = _.filter(this.points,\n            point => isIndexEqual(point, CONSTS.END_INDEX) || isIndexEqual(point, CONSTS.LAST_STATION_INDEX));\n\n        if (!_.isEmpty(startPoint)) {\n            logger.debug('Start point detected. Checking if it is closer to path start or path end...');\n            const startPointToPathStartDistance = turf.distance(this.pathStart,\n                startPoint[0], turf.options);\n            const startPointToPathEndDistance = turf.distance(this.pathEnd, startPoint[0], turf.options);\n            if (startPointToPathStartDistance > startPointToPathEndDistance) {\n                logger.debug('Reversed path detected. Start point is closer to path end.');\n                this.pathReversed = true;\n            }\n        } else if (!_.isEmpty(endPoint)) {\n            logger.debug('End point detected. Checking if it is closer to path start or path end...');\n            const endPointToPathStartDistance = turf.distance(this.pathStart, endPoint[0], turf.options);\n            const endPointToPathEndDistance = turf.distance(this.pathEnd, endPoint[0], turf.options);\n            if (endPointToPathEndDistance > endPointToPathStartDistance) {\n                logger.debug('Reversed path detected. Start point is closer to path end.');\n                this.pathReversed = true;\n            }\n        }\n\n        if (this.pathReversed) {\n            logger.debug('Reversing points.');\n            this.path = helpers.reverseLineString(this.path);\n        }\n    }\n\n    updateCircularity() {\n        const maxDistanceBetweenPathEnds = 1000; // meters\n        const distance = turf.distance(this.pathStart, this.pathEnd, turf.options);\n\n        logger.debug('Distance between path start and end points:', distance.toFixed(2), 'meters.');\n        if (distance <= maxDistanceBetweenPathEnds) {\n            logger.debug('Circular path detected.');\n            this.pathCircular = true;\n        } else {\n            logger.debug('Circular path not detected.');\n            this.pathCircular = false;\n        }\n    }\n\n    getCount() {\n        let numberOfStations = 0;\n\n        for (let stationNumber = CONSTS.FIRST_STATION_INDEX;\n            stationNumber <= CONSTS.LAST_STATION_INDEX; stationNumber++) {\n            let firstStationName = '';\n            const stationsOfNumber = _.filter(this.points, station => {\n                if (station.properties.index === stationNumber) {\n                    firstStationName = station.properties.name;\n                    return true;\n                }\n                return false;\n            });\n            if (stationsOfNumber.length > 1) {\n                logBuffer.add(lang.trans('Station found multiple times',\n                    { number: stationNumber, times: stationsOfNumber.length }));\n            } else if (stationsOfNumber.length === 0) {\n                logBuffer.add(lang.trans('Station not found', { number: stationNumber }));\n            } else {\n                logger.debug(`Station ${stationNumber} found. Station name: ${firstStationName}`);\n                numberOfStations++;\n            }\n        }\n        return numberOfStations;\n    }\n\n    isOrderCorrect() {\n        let result = true;\n\n        for (let i = 1; i < this.points.length; i++) {\n            const currentStationNumber = this.points[i].properties.index;\n            const previousStationNumber = this.points[i - 1].properties.index;\n            logger.debug(`Point ${i - 1}`);\n            if (currentStationNumber === null) {\n                logger.debug(`Not checking order for unrecognized point: ${this.points[i].properties.name}`);\n            } else if (previousStationNumber === null) {\n                logger.debug(`Not checking order for unrecognized point: ${this.points[i - 1].properties.name}`);\n            } else if (this.pathCircular\n                && (\n                    (previousStationNumber === CONSTS.FIRST_STATION_INDEX\n                    && currentStationNumber === CONSTS.LAST_STATION_INDEX)\n                    || (currentStationNumber === CONSTS.FIRST_STATION_INDEX\n                    && previousStationNumber === CONSTS.LAST_STATION_INDEX)\n                )\n            ) {\n                logger.debug('Not checking order for station',\n                    CONSTS.FIRST_STATION_INDEX, 'and', CONSTS.LAST_STATION_INDEX,\n                    'when route is circular.');\n            } else if (currentStationNumber <= previousStationNumber) {\n                logBuffer.add(lang.trans('Invalid stations order', { currentStationNumber, previousStationNumber }));\n                result = false;\n            } else {\n                logger.debug(`Station ${currentStationNumber} is after station ${previousStationNumber}.`);\n            }\n        }\n        return result;\n    }\n\n    areAllOnThePath(maximumDistanceFromPath) {\n        let result = true;\n\n        _.forEach(this.points, (station, index) => {\n            const stationNumber = station.properties.index;\n\n            logger.debug(`Point ${index}`);\n            if (stationNumber === null) {\n                logger.debug(`Not checking distance for: ${station.properties.name}`);\n            } else {\n                const distanceFromStationToPath = helpers.getDistanceToNearestPointOnLine(station);\n                logger.debug(`Station ${stationNumber} distance from path: `\n                    + `${distanceFromStationToPath.toFixed(2)} meter(s).`);\n                if (distanceFromStationToPath > maximumDistanceFromPath) {\n                    logBuffer.add(lang.trans('Station too far from path',\n                        { number: stationNumber, maximumDistance: maximumDistanceFromPath }));\n                    result = false;\n                } else {\n                    logger.debug(`Station ${stationNumber} is on the path.`);\n                }\n            }\n        });\n\n        return result;\n    }\n\n    getUpdatedPath() {\n        const lastStationPoint = _.find(this.points, point => point.properties.index === CONSTS.LAST_STATION_INDEX);\n\n        if (lastStationPoint !== null) {\n            const lastStationLocation = helpers.getLocationOfNearestPointOnLine(lastStationPoint);\n            if (lastStationLocation > 0) {\n                logger.debug('getPathEndingOnLastStation: Returning sliced path. '\n                    + `Last station location: ${lastStationLocation.toFixed(2)}`);\n                return turf.lineSliceAlong(this.path, 0, lastStationLocation, turf.options);\n            }\n        }\n\n        logger.debug('getPathEndingOnLastStation: Returning original path. Last station not found.');\n        return this.path;\n    }\n}\n","import logger from 'loglevel';\nimport * as _ from './utils/lodash';\nimport helpers from './utils/helpers';\nimport PathElevation from './PathElevation';\nimport Stations from './Stations';\nimport Lang from './lang/Lang';\nimport LogBuffer from './utils/LogBuffer';\n\n// Constants\nconst EXPECTED_NUMBER_OF_PATHS = 1;\nconst EXPECTED_NUMBER_OF_STATIONS = 14;\nconst MAXIMUM_DISTANCE_FROM_STATION_TO_PATH = 50; // meters\n\nlet lang = null;\nlet logBuffer = null;\n\n\nexport default class Route {\n    constructor(geoJson) {\n        this.geoJson = geoJson;\n        this.lineString = helpers.getLineString(this.geoJson);\n        this.points = helpers.getPoints(this.geoJson);\n        this.isRouteVerifiable = true;\n\n        lang = Lang.getInstance();\n        logBuffer = LogBuffer.getInstance();\n\n        if (_.isEmpty(this.lineString)) {\n            logBuffer.add(lang.trans('No path in route'));\n            this.isRouteVerifiable = false;\n        }\n        if (_.isEmpty(this.points)) {\n            logBuffer.add(lang.trans('No points in route'));\n        }\n        if (this.isRouteVerifiable) {\n            this.stations = new Stations(this.points, this.lineString);\n            this.path = this.stations.getUpdatedPath();\n            this.numberOfPaths = helpers.getNumberOfFeatures('LineString', this.geoJson);\n        }\n    }\n\n    isVerifiable() {\n        return this.isRouteVerifiable;\n    }\n\n    isSinglePath() {\n        const result = _.isEqual(this.numberOfPaths, EXPECTED_NUMBER_OF_PATHS);\n        if (!result) {\n            logBuffer.add(lang.trans('No single path defined'));\n        }\n        logger.debug('isSinglePath:', result, ', numberOfPaths:', this.numberOfPaths);\n        return result;\n    }\n\n    areAllStationsPresent() {\n        const numberOfStations = this.stations.getCount();\n        const result = _.isEqual(numberOfStations, EXPECTED_NUMBER_OF_STATIONS);\n        logger.debug('areAllStationsPresent:', result, ', numberOfStations:', numberOfStations);\n        return result;\n    }\n\n    areStationsOnThePath() {\n        const result = this.stations.areAllOnThePath(MAXIMUM_DISTANCE_FROM_STATION_TO_PATH);\n        logger.debug('areStationsOnThePath:', result);\n        return result;\n    }\n\n    isStationOrderCorrect() {\n        const result = this.stations.isOrderCorrect();\n        logger.debug('isStationOrderCorrect:', result);\n        return result;\n    }\n\n    getPathLength() {\n        let result = 0;\n\n        const googleMapsPath = helpers.getGoogleMapsPath(this.path);\n        result = google.maps.geometry.spherical.computeLength(googleMapsPath);\n        result /= 1000;\n\n        logger.debug('getPathLength [km]:', result);\n        return result;\n    }\n\n    fetchPathElevationData() {\n        return helpers.getPathElevations(this.path)\n            .then(elevations => {\n                logger.debug('Path elevations:', elevations);\n                this.pathElevation = new PathElevation(elevations);\n                return this.pathElevation;\n            })\n            .catch(error => {\n                logger.error(`Path elevation data fetching error, Error: ${error}`);\n                return Promise.reject('Path elevation data fetching error');\n            });\n    }\n\n    getPathElevation() {\n        logger.debug('getPathElevation:', this.pathElevation);\n        return this.pathElevation;\n    }\n}\n","import logger from 'loglevel';\n\nimport LogBuffer from './utils/LogBuffer';\nimport Context from './Context';\nimport Lang from './lang/Lang';\nimport Controls from './Controls';\nimport helpers from './utils/helpers';\nimport Route from './Route';\n\n// Constants\nconst NORMAL_ROUTE_MIN_LENGTH = 40; // kilometers\nconst SHORT_NORMAL_ROUTE_MIN_LENGTH = 30; // kilometers\nconst SHORT_NORMAL_ROUTE_MIN_ELEVATION_GAIN = 500; // meters\n\n// Google Maps API loading and key validation\nwindow.GOOGLE_MAPS_API_LOADED = true;\nwindow.gm_authFailure = () => { window.GOOGLE_MAPS_API_LOADED = false; };\n\nfunction verifyRoute() {\n    if (!window.GOOGLE_MAPS_API_LOADED || !window.google || !window.google.maps) {\n        window.GOOGLE_MAPS_API_LOADED = false;\n        logger.error('Google Maps API is not loaded. Verification cannot be done.');\n    }\n\n    const context = new Context();\n    const controls = new Controls();\n    const lang = new Lang(context.language);\n    const logBuffer = new LogBuffer();\n\n    let routeSuccessfullyVerified = false;\n    let route = null;\n    let routeLength = 0;\n    let pathElevation = null;\n\n    let isSinglePath = false;\n    let isPathLengthValid = false;\n    let isNormalRoute = false;\n    let areAllStationsPresent = false;\n    let isStationOrderCorrect = false;\n    let areStationsOnThePath = false;\n    let isPathElevationGainValid = false;\n    let isPathElevationLossValid = false;\n    let isPathElevationTotalChangeValid = false;\n    let isDataConsistent = false;\n\n    controls.resetAll();\n    logBuffer.cleanLogs();\n    controls.addLoaderToButton();\n\n    helpers.getRoute(context.routeUrl)\n        .then(data => {\n            const geoJson = helpers.getGeoJSON(data);\n            route = new Route(geoJson);\n\n            if (!route.isVerifiable()) {\n                controls.resetAll(false);\n                return Promise.reject('Route is unverifiable');\n            }\n\n            // Path basic checks\n            isSinglePath = route.isSinglePath();\n            controls.updateSinglePath(isSinglePath);\n            routeLength = route.getPathLength();\n            isPathLengthValid = true;\n            controls.updatePathLength(isPathLengthValid, routeLength);\n\n            // Station checks\n            areAllStationsPresent = route.areAllStationsPresent();\n            controls.updateNumberOfStations(areAllStationsPresent);\n            isStationOrderCorrect = route.isStationOrderCorrect();\n            controls.updateStationsOrder(isStationOrderCorrect);\n            areStationsOnThePath = route.areStationsOnThePath();\n            controls.updateStationsOnPath(areStationsOnThePath);\n        })\n        .then(() => route.fetchPathElevationData())\n        .then(() => {\n            pathElevation = route.getPathElevation();\n            pathElevation.enrichData(routeLength);\n\n            isPathElevationGainValid = true;\n            controls.updateElevationGain(isPathElevationGainValid, pathElevation.gain);\n\n            isNormalRoute = routeLength >= NORMAL_ROUTE_MIN_LENGTH\n                || pathElevation.gain > SHORT_NORMAL_ROUTE_MIN_ELEVATION_GAIN\n                && routeLength >= SHORT_NORMAL_ROUTE_MIN_LENGTH;\n            controls.updateRouteType(isNormalRoute);\n\n            isPathElevationLossValid = true;\n            controls.updateElevationLoss(isPathElevationLossValid, pathElevation.loss);\n\n            isPathElevationTotalChangeValid = true;\n            controls.updateElevationTotalChange(isPathElevationTotalChangeValid,\n                pathElevation.totalChange);\n\n            controls.drawElevationChart(pathElevation);\n        })\n        .then(() => helpers.getRouteParameters(context.routeParamsUrl))\n        .then(parameters => {\n            const ACCEPTED_ROUTE_LENGTH_DIFF = 1; // km\n            const ACCEPTED_ELEVATION_GAIN_DIFF = 50; // m\n            const NORMAL_ROUTE_TYPE = 0;\n            const INSPIRED_ROUTE_TYPE = 1;\n            /* eslint-disable max-len */\n            const isLengthConsistent = (routeLength - ACCEPTED_ROUTE_LENGTH_DIFF <= parameters.length\n                && parameters.length <= routeLength + ACCEPTED_ROUTE_LENGTH_DIFF);\n            const isElevationGainConsistent = (pathElevation.gain - ACCEPTED_ELEVATION_GAIN_DIFF <= parameters.ascent\n                && parameters.ascent <= pathElevation.gain + ACCEPTED_ELEVATION_GAIN_DIFF);\n            const isRouteTypeConsistent = parameters.type === (isNormalRoute ? NORMAL_ROUTE_TYPE : INSPIRED_ROUTE_TYPE);\n            isDataConsistent = isLengthConsistent && isElevationGainConsistent && isRouteTypeConsistent;\n\n            logger.debug('isLengthConsistent:', isLengthConsistent,\n                ', isElevationGainConsistent:', isElevationGainConsistent,\n                ', isRouteTypeConsistent:', isRouteTypeConsistent);\n            controls.updateDataConsistency(isDataConsistent);\n\n            routeSuccessfullyVerified = isSinglePath && isPathLengthValid\n                && areAllStationsPresent && isStationOrderCorrect\n                && areStationsOnThePath && isPathElevationGainValid\n                && isPathElevationLossValid && isPathElevationTotalChangeValid\n                && isDataConsistent;\n        })\n        .catch(error => {\n            logBuffer.add(lang.trans(error));\n        })\n        .finally(() => {\n            controls.removeLoaderFromButton();\n\n            if (routeSuccessfullyVerified) {\n                logger.info('Route verification success. Approving...');\n                helpers.approveRoute(context.routeApproveUrl)\n                    .then(() => {\n                        logger.info('Route approved.');\n                        controls.showVerificationSuccessModal(5000);\n                    })\n                    .catch(error => {\n                        logger.error('Route approval error.', error);\n                    });\n            } else {\n                logger.info('Route verification failed. Cannot be approved.');\n                controls.showVerificationFailedModal(logBuffer.getLogs());\n            }\n        });\n}\n\nif (process.env.NODE_ENV === 'production') {\n    logger.setLevel('warn');\n} else {\n    logger.setLevel('debug');\n}\nwindow.setLogLevel = (logLevel = 'debug') => logger.setLevel(logLevel);\n\n$('button#verifyRoute').bind('click', verifyRoute);\n"],"sourceRoot":""}