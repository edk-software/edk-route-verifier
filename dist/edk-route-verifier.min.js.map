{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/loglevel/lib/loglevel.js","webpack:///./node_modules/lodash/isArray.js","webpack:///./node_modules/lodash/_root.js","webpack:///./node_modules/lodash/_getNative.js","webpack:///./node_modules/lodash/identity.js","webpack:///./node_modules/lodash/isSymbol.js","webpack:///./node_modules/lodash/isArrayLike.js","webpack:///./node_modules/lodash/_baseIteratee.js","webpack:///./node_modules/lodash/isObjectLike.js","webpack:///./node_modules/lodash/isObject.js","webpack:///./node_modules/lodash/_Symbol.js","webpack:///./node_modules/lodash/_baseGetTag.js","webpack:///./node_modules/lodash/_toKey.js","webpack:///./node_modules/lodash/keys.js","webpack:///./node_modules/lodash/_getMapData.js","webpack:///./node_modules/lodash/_nativeCreate.js","webpack:///./node_modules/lodash/_assocIndexOf.js","webpack:///./node_modules/lodash/_ListCache.js","webpack:///./node_modules/lodash/isArguments.js","webpack:///./node_modules/lodash/_arrayMap.js","webpack:///./node_modules/lodash/_isKey.js","webpack:///./node_modules/lodash/_baseEach.js","webpack:///./node_modules/lodash/_isIndex.js","webpack:///./node_modules/lodash/_MapCache.js","webpack:///./node_modules/lodash/eq.js","webpack:///./node_modules/lodash/_baseIsEqual.js","webpack:///./node_modules/lodash/isTypedArray.js","webpack:///./node_modules/lodash/isBuffer.js","webpack:///./node_modules/lodash/isLength.js","webpack:///./node_modules/lodash/_Map.js","webpack:///./node_modules/lodash/sortBy.js","webpack:///./node_modules/lodash/min.js","webpack:///./node_modules/lodash/_baseMap.js","webpack:///./node_modules/lodash/map.js","webpack:///./node_modules/lodash/forEach.js","webpack:///./node_modules/lodash/find.js","webpack:///./node_modules/lodash/_castPath.js","webpack:///./node_modules/lodash/_baseGet.js","webpack:///./node_modules/lodash/_matchesStrictComparable.js","webpack:///./node_modules/lodash/_isStrictComparable.js","webpack:///./node_modules/lodash/filter.js","webpack:///./node_modules/lodash/isNull.js","webpack:///./node_modules/lodash/_arrayFilter.js","webpack:///./node_modules/lodash/_arrayPush.js","webpack:///./node_modules/lodash/_equalArrays.js","webpack:///./node_modules/lodash/_Stack.js","webpack:///./node_modules/lodash/isEqual.js","webpack:///./node_modules/lodash/_baseUnary.js","webpack:///(webpack)/buildin/module.js","webpack:///./node_modules/lodash/_toSource.js","webpack:///./node_modules/lodash/_freeGlobal.js","webpack:///./node_modules/lodash/isFunction.js","webpack:///./node_modules/lodash/_getTag.js","webpack:///./node_modules/lodash/_isPrototype.js","webpack:///./node_modules/lodash/_baseKeys.js","webpack:///./node_modules/lodash/isEmpty.js","webpack:///./node_modules/togeojson/togeojson.js","webpack:///./node_modules/@turf/meta/node_modules/@turf/helpers/main.es.js","webpack:///./node_modules/@turf/meta/main.es.js","webpack:///./node_modules/@turf/flatten/node_modules/@turf/helpers/main.es.js","webpack:///./node_modules/@turf/flatten/main.es.js","webpack:///./src/helpers.js","webpack:///./src/PathElevation.js","webpack:///./node_modules/@turf/bearing/node_modules/@turf/invariant/index.js","webpack:///./node_modules/@turf/bearing/index.js","webpack:///./node_modules/@turf/point-on-line/node_modules/@turf/invariant/index.js","webpack:///./node_modules/@turf/point-on-line/node_modules/@turf/helpers/index.js","webpack:///./node_modules/@turf/point-on-line/node_modules/@turf/distance/index.js","webpack:///./node_modules/@turf/destination/node_modules/@turf/invariant/index.js","webpack:///./node_modules/@turf/destination/node_modules/@turf/helpers/index.js","webpack:///./node_modules/@turf/destination/index.js","webpack:///./node_modules/@turf/point-on-line/node_modules/geojson-rbush/quickselect.js","webpack:///./node_modules/@turf/point-on-line/node_modules/geojson-rbush/rbush.js","webpack:///./node_modules/@turf/point-on-line/node_modules/@turf/meta/index.js","webpack:///./node_modules/@turf/point-on-line/node_modules/geojson-rbush/index.js","webpack:///./node_modules/@turf/point-on-line/node_modules/@turf/line-segment/node_modules/@turf/helpers/main.es.js","webpack:///./node_modules/@turf/point-on-line/node_modules/@turf/line-segment/node_modules/@turf/invariant/main.es.js","webpack:///./node_modules/@turf/point-on-line/node_modules/@turf/line-segment/node_modules/@turf/meta/main.es.js","webpack:///./node_modules/@turf/point-on-line/node_modules/@turf/line-segment/main.es.js","webpack:///./node_modules/@turf/point-on-line/node_modules/@turf/line-intersect/node_modules/@turf/helpers/main.es.js","webpack:///./node_modules/@turf/point-on-line/node_modules/@turf/line-intersect/node_modules/@turf/invariant/main.es.js","webpack:///./node_modules/@turf/point-on-line/node_modules/@turf/line-intersect/node_modules/@turf/meta/main.es.js","webpack:///./node_modules/@turf/point-on-line/node_modules/@turf/line-intersect/main.es.js","webpack:///./node_modules/@turf/point-on-line/index.js","webpack:///./node_modules/@turf/helpers/main.es.js","webpack:///./node_modules/@turf/invariant/main.es.js","webpack:///./node_modules/@turf/distance/main.es.js","webpack:///./src/Stations.js","webpack:///./src/Route.js","webpack:///./src/Context.js","webpack:///./src/Controls.js","webpack:///./src/routeVerifier.js","webpack:///./node_modules/lodash/_isIterateeCall.js","webpack:///./node_modules/lodash/_shortOut.js","webpack:///./node_modules/lodash/_defineProperty.js","webpack:///./node_modules/lodash/constant.js","webpack:///./node_modules/lodash/_baseSetToString.js","webpack:///./node_modules/lodash/_setToString.js","webpack:///./node_modules/lodash/_apply.js","webpack:///./node_modules/lodash/_overRest.js","webpack:///./node_modules/lodash/_baseRest.js","webpack:///./node_modules/lodash/_compareAscending.js","webpack:///./node_modules/lodash/_compareMultiple.js","webpack:///./node_modules/lodash/_baseSortBy.js","webpack:///./node_modules/lodash/_baseOrderBy.js","webpack:///./node_modules/lodash/_isFlattenable.js","webpack:///./node_modules/lodash/_baseFlatten.js","webpack:///./node_modules/lodash/_baseLt.js","webpack:///./node_modules/lodash/_baseExtremum.js","webpack:///./node_modules/lodash/_castFunction.js","webpack:///./node_modules/lodash/_arrayEach.js","webpack:///./node_modules/lodash/toNumber.js","webpack:///./node_modules/lodash/toFinite.js","webpack:///./node_modules/lodash/toInteger.js","webpack:///./node_modules/lodash/_baseFindIndex.js","webpack:///./node_modules/lodash/findIndex.js","webpack:///./node_modules/lodash/_createFind.js","webpack:///./node_modules/lodash/_basePropertyDeep.js","webpack:///./node_modules/lodash/_baseProperty.js","webpack:///./node_modules/lodash/property.js","webpack:///./node_modules/lodash/_hasPath.js","webpack:///./node_modules/lodash/_baseHasIn.js","webpack:///./node_modules/lodash/hasIn.js","webpack:///./node_modules/lodash/_baseToString.js","webpack:///./node_modules/lodash/toString.js","webpack:///./node_modules/lodash/memoize.js","webpack:///./node_modules/lodash/_memoizeCapped.js","webpack:///./node_modules/lodash/_stringToPath.js","webpack:///./node_modules/lodash/get.js","webpack:///./node_modules/lodash/_baseMatchesProperty.js","webpack:///./node_modules/lodash/_getMatchData.js","webpack:///./node_modules/lodash/_baseIsMatch.js","webpack:///./node_modules/lodash/_baseMatches.js","webpack:///./node_modules/lodash/_createBaseEach.js","webpack:///./node_modules/lodash/_createBaseFor.js","webpack:///./node_modules/lodash/_baseFor.js","webpack:///./node_modules/lodash/_baseForOwn.js","webpack:///./node_modules/lodash/_baseFilter.js","webpack:///./node_modules/lodash/_baseTimes.js","webpack:///./node_modules/lodash/_arrayLikeKeys.js","webpack:///./node_modules/lodash/stubArray.js","webpack:///./node_modules/lodash/_getSymbols.js","webpack:///./node_modules/lodash/_baseGetAllKeys.js","webpack:///./node_modules/lodash/_getAllKeys.js","webpack:///./node_modules/lodash/_equalObjects.js","webpack:///./node_modules/lodash/_setToArray.js","webpack:///./node_modules/lodash/_mapToArray.js","webpack:///./node_modules/lodash/_Uint8Array.js","webpack:///./node_modules/lodash/_equalByTag.js","webpack:///./node_modules/lodash/_cacheHas.js","webpack:///./node_modules/lodash/_arraySome.js","webpack:///./node_modules/lodash/_setCacheHas.js","webpack:///./node_modules/lodash/_setCacheAdd.js","webpack:///./node_modules/lodash/_SetCache.js","webpack:///./node_modules/lodash/_mapCacheSet.js","webpack:///./node_modules/lodash/_mapCacheHas.js","webpack:///./node_modules/lodash/_mapCacheGet.js","webpack:///./node_modules/lodash/_isKeyable.js","webpack:///./node_modules/lodash/_mapCacheDelete.js","webpack:///./node_modules/lodash/_hashSet.js","webpack:///./node_modules/lodash/_hashHas.js","webpack:///./node_modules/lodash/_hashGet.js","webpack:///./node_modules/lodash/_hashDelete.js","webpack:///./node_modules/lodash/_hashClear.js","webpack:///./node_modules/lodash/_Hash.js","webpack:///./node_modules/lodash/_mapCacheClear.js","webpack:///./node_modules/lodash/_stackSet.js","webpack:///./node_modules/lodash/_stackHas.js","webpack:///./node_modules/lodash/_stackGet.js","webpack:///./node_modules/lodash/_stackDelete.js","webpack:///./node_modules/lodash/_stackClear.js","webpack:///./node_modules/lodash/_listCacheSet.js","webpack:///./node_modules/lodash/_listCacheHas.js","webpack:///./node_modules/lodash/_listCacheGet.js","webpack:///./node_modules/lodash/_listCacheDelete.js","webpack:///./node_modules/lodash/_listCacheClear.js","webpack:///./node_modules/lodash/_baseIsEqualDeep.js","webpack:///./node_modules/lodash/_nodeUtil.js","webpack:///./node_modules/lodash/_baseIsTypedArray.js","webpack:///./node_modules/lodash/stubFalse.js","webpack:///./node_modules/lodash/_baseIsArguments.js","webpack:///./node_modules/lodash/_WeakMap.js","webpack:///./node_modules/lodash/_Set.js","webpack:///./node_modules/lodash/_Promise.js","webpack:///./node_modules/lodash/_getValue.js","webpack:///./node_modules/lodash/_coreJsData.js","webpack:///./node_modules/lodash/_isMasked.js","webpack:///./node_modules/lodash/_objectToString.js","webpack:///./node_modules/lodash/_getRawTag.js","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/lodash/_baseIsNative.js","webpack:///./node_modules/lodash/_DataView.js","webpack:///./node_modules/lodash/_overArg.js","webpack:///./node_modules/lodash/_nativeKeys.js","webpack:///./node_modules/process/browser.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","root","definition","undefined","noop","undefinedType","logMethods","bindMethod","obj","methodName","method","bind","Function","e","apply","arguments","replaceLoggingMethods","level","loggerName","length","this","methodFactory","log","debug","defaultMethodFactory","console","realMethod","Logger","defaultLevel","factory","currentLevel","self","storageKey","getPersistedLevel","storedLevel","window","localStorage","ignore","cookie","document","location","indexOf","encodeURIComponent","exec","slice","levels","TRACE","DEBUG","INFO","WARN","ERROR","SILENT","getLevel","setLevel","persist","toUpperCase","levelNum","levelName","persistLevelIfPossible","setDefaultLevel","enableAll","disableAll","initialLevel","defaultLogger","_loggersByName","getLogger","TypeError","logger","_log","noConflict","isArray","Array","freeGlobal","freeSelf","baseIsNative","getValue","key","baseGetTag","isObjectLike","symbolTag","isFunction","isLength","baseMatches","baseMatchesProperty","identity","type","Symbol","getRawTag","objectToString","nullTag","undefinedTag","symToStringTag","toStringTag","isSymbol","INFINITY","result","arrayLikeKeys","baseKeys","isArrayLike","isKeyable","map","data","__data__","nativeCreate","getNative","eq","array","listCacheClear","listCacheDelete","listCacheGet","listCacheHas","listCacheSet","ListCache","entries","index","clear","entry","set","has","baseIsArguments","objectProto","propertyIsEnumerable","isArguments","iteratee","reIsDeepProp","reIsPlainProp","test","baseForOwn","baseEach","createBaseEach","MAX_SAFE_INTEGER","reIsUint","mapCacheClear","mapCacheDelete","mapCacheGet","mapCacheHas","mapCacheSet","MapCache","other","baseIsEqualDeep","baseIsEqual","bitmask","customizer","stack","baseIsTypedArray","baseUnary","nodeUtil","nodeIsTypedArray","isTypedArray","stubFalse","freeExports","nodeType","freeModule","Buffer","isBuffer","Map","baseFlatten","baseOrderBy","baseRest","isIterateeCall","sortBy","collection","iteratees","baseExtremum","baseLt","arrayMap","baseIteratee","baseMap","arrayEach","castFunction","find","createFind","isKey","stringToPath","toString","castPath","toKey","path","srcValue","isObject","arrayFilter","baseFilter","predicate","resIndex","values","offset","SetCache","arraySome","cacheHas","COMPARE_PARTIAL_FLAG","COMPARE_UNORDERED_FLAG","equalFunc","isPartial","arrLength","othLength","stacked","seen","arrValue","othValue","compared","othIndex","push","stackClear","stackDelete","stackGet","stackHas","stackSet","Stack","size","func","webpackPolyfill","deprecate","paths","children","funcToString","global","asyncTag","funcTag","genTag","proxyTag","tag","DataView","Promise","Set","WeakMap","toSource","dataViewCtorString","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","getTag","ArrayBuffer","resolve","Ctor","constructor","ctorString","isPrototype","nativeKeys","mapTag","setTag","splice","process","toGeoJSON","serializer","removeSpace","trimSpace","splitSpace","okhash","x","h","charCodeAt","y","getElementsByTagName","attr","getAttribute","attrf","parseFloat","get1","numarray","j","nodeVal","el","normalize","textContent","getMulti","ys","k","extend","coord1","v","replace","split","coord","coords","coordPair","ll","ele","heartRate","time","isNaN","coordinates","xml2str","str","xml","serializeToString","XMLSerializer","browser","kml","doc","gj","features","styleIndex","styleByHash","styleMapIndex","geotypes","placemarks","styles","styleMaps","hash","pairs","pairsMap","concat","getPlacemark","kmlColor","color","opacity","substr","parseInt","gxCoords","elems","times","timeElems","geomsAndTimes","getGeometry","geomNode","geomNodes","geoms","coordTimes","rings","track","properties","styleUrl","description","timeSpan","timeStamp","extendedData","lineStyle","polyStyle","visibility","styleHash","styleMapHash","normal","style","begin","end","timespan","timestamp","linestyles","width","stroke","polystyles","pcolor","popacity","fill","outline","datas","simpleDatas","feature","geometry","geometries","id","gpx","tracks","routes","waypoints","getTrack","getRoute","getPoint","getPoints","node","pointname","pts","line","heartRates","segments","getProperties","prop","links","link","href","main_es_feature","options","Error","bbox","validateBBox","validateId","feat","isNumber","num","input","forEach","geomEach","geojson","callback","g","stopG","geometryMaybeCollection","isGeometryCollection","featureProperties","featureBBox","featureId","featureIndex","isFeatureCollection","isFeature","stop","flattenEach","geomType","multiFeatureIndex","coordinate","main_es_featureCollection","main_es_isObject","main_es_validateBBox","main_es_validateId","fc","main_es_isNumber","main_es","results","parentNode","removeChild","loglevel_default","a","geoJson","togeojson_default","featureName","filter_default","isEqual_default","find_default","lineString","newLineString","reverse","routeUrl","$","ajax","map_default","element","google","maps","LatLng","useLocalElevations","elevations","elevation","reject","getGoogleMapsPath","optimizedPath","delta","Math","floor","ElevationService","getElevationAlongPath","samples","status","ElevationStatus","OK","routeParamsUrl","done","success","error","fail","xhr","routeApproveUrl","getGain","elevationGain","elevationDifference","Number","getLoss","elevationLoss","PathElevation","PathElevation_classCallCheck","gain","loss","totalChange","elevationsWithDistance","resolution","distance","getCoord","containsNumber","getCoords","bearing_bearing","start","final","bear","calculateFinalBearing","degrees2radians","PI","radians2degrees","coordinates1","coordinates2","lon1","lon2","lat1","lat2","sin","cos","b","atan2","_turf_bearing","invariant_getCoord","invariant_getCoords","invariant_containsNumber","helpers_feature","helpers_point","helpers_isNumber","helpers_lineString","helpers_factors","miles","nauticalmiles","degrees","radians","inches","yards","meters","metres","centimeters","centimetres","kilometers","kilometres","feet","helpers_radiansToDistance","units","factor","_turf_distance","from","to","dLat","dLon","pow","sqrt","_turf_invariant_getCoord","_turf_invariant_containsNumber","_turf_invariant_getCoords","_turf_helpers_feature","_turf_helpers_point","_turf_helpers_isNumber","_turf_helpers_factors","_turf_helpers_distanceToRadians","_turf_destination","origin","bearing","longitude1","latitude1","bearing_rad","latitude2","asin","swap","arr","tmp","defaultCompare","geojson_rbush_quickselect","left","right","compare","quickselectStep","z","exp","sd","newLeft","max","newRight","min","t","rbush","maxEntries","format","_maxEntries","_minEntries","ceil","_initFormat","findItem","item","items","equalsFn","calcBBox","toBBox","distBBox","destNode","createNode","minX","Infinity","minY","maxX","maxY","child","leaf","compareNodeMinX","compareNodeMinY","bboxArea","bboxMargin","contains","intersects","height","multiSelect","mid","pop","all","_all","search","len","childBBox","nodesToSearch","collides","load","insert","_build","_splitRoot","tmpNode","_insert","remove","parent","goingUp","indexes","_condense","compareMinX","compareMinY","toJSON","fromJSON","N","M","right2","right3","N2","N1","_chooseSubtree","targetNode","area","enlargement","minArea","minEnlargement","isNode","insertPath","_split","_adjustParentBBoxes","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","bbox1","bbox2","overlap","minOverlap","_allDistMargin","sort","leftBBox","rightBBox","margin","siblings","compareArr","join","geojson_rbush_rbush","meta_coordEach","excludeWrapCoord","geometryIndex","wrapShrink","coordIndex","featureSubIndex","meta_featureEach","meta_geomEach","geometryProperties","meta_flattenEach","meta_feature","bboxPolygon","lowLeft","topLeft","topRight","turfBBox","geojson_rbush","tree","json","_turf_helpers_main_es_feature","helpers_main_es_isObject","helpers_main_es_validateBBox","helpers_main_es_validateId","_turf_helpers_main_es_lineString","helpers_main_es_isNumber","helpers_main_es_featureCollection","main_es_getCoords","main_es_geomEach","main_es_flattenEach","line_segment_main_es","reduce","previousCoords","currentCoords","coords1","coords2","x1","y1","x2","y2","segment","createSegments","lineSegmentFeature","node_modules_turf_helpers_main_es_feature","_turf_helpers_main_es_isObject","_turf_helpers_main_es_validateBBox","_turf_helpers_main_es_validateId","_turf_helpers_main_es_point","_turf_helpers_main_es_isNumber","_turf_helpers_main_es_featureCollection","invariant_main_es_getCoords","meta_main_es_featureEach","main_es_intersects","line1","line2","x3","y3","x4","y4","denom","numeA","numeB","uA","uB","line_intersect_main_es","unique","intersect","match","point_on_line","lines","pt","closestPt","dist","sectionLength","heightDistance","direction","perpendicularPt1","perpendicularPt2","intersectPt","node_modules_turf_helpers_main_es_factors","millimeters","node_modules_turf_helpers_main_es_earthRadius","millimetres","node_modules_turf_helpers_main_es_feature_0","node_modules_turf_helpers_main_es_isObject","node_modules_turf_helpers_main_es_validateBBox","node_modules_turf_helpers_main_es_validateId","node_modules_turf_helpers_main_es_point","node_modules_turf_helpers_main_es_isNumber","node_modules_turf_helpers_main_es_radiansToLength","node_modules_turf_helpers_main_es_degreesToRadians","_turf_invariant_main_es_getCoord","distance_main_es","turf","pointOnLine","point","CONSTS","Stations","points","Stations_classCallCheck","pathReversed","pathCircular","pathStart","pathEnd","_sortPoints","_addIndexes","_updateCircularity","_updateDirection","enhancedPoints","nearestOnLine","sortedPoints","sortBy_default","number","START_NAMES_REGEX","END_NAMES_REGEX","ROMAN_NUMBERS_REGEX","EUROPEAN_NUMBERS_REGEX","ROMAN_EUROPEAN_MAP","I","II","III","IV","V","VI","VII","VIII","IX","X","XI","XII","XIII","XIV","parts","trim","forEach_default","part","matches","isNull_default","stationNumber","getIndex","startPoint","endPoint","isEmpty_default","endPointToPathStartDistance","toFixed","_this","numberOfStations","_loop","firstStationName","stationsOfNumber","station","warn","currentStationNumber","previousStationNumber","maximumDistanceFromPath","distanceFromStationToPath","Route","Route_classCallCheck","helpers","getLineString","isRouteVerifiable","stations","src_Stations","isPathReversed","reverseLineString","numberOfPaths","getNumberOfFeatures","getCount","areAllOnThePath","isOrderCorrect","googleMapsPath","spherical","computeLength","getPathElevations","then","pathElevation","src_PathElevation","catch","Context","Controls_updateControlColor","isValid","VALID_COLOR_CLASS","INVALID_COLOR_CLASS","removeClass","addClass","Controls_updateControlValue","unit","html","isNormalRoute","normalRouteString","inspiredRouteString","isLengthValid","isElevationGainValid","isElevationLossValid","isElevationTotalChangeValid","elevationTotalChange","areAllStationsPresent","isStationOrderCorrect","areAllStationsOnPath","isSinglePath","isDataConsistent","labelWidth","labels","Chart","datasets","label","radius","backgroundColor","scales","xAxes","scaleLabel","display","labelString","ticks","dataLabel","yAxes","legend","tooltips","enabled","elevationChartParentElement","append","VERIFY_BUTTON_ID","resetElevationChart","NORMAL_ROUTE_MIN_LENGTH","SHORT_NORMAL_ROUTE_MIN_LENGTH","SHORT_NORMAL_ROUTE_MIN_ELEVATION_GAIN","setLogLevel","logLevel","context","controls","src_Controls","resetAll","addLoaderToButton","getGeoJSON","route","src_Route","isVerifiable","updateSinglePath","routeLength","getPathLength","updatePathLength","updateNumberOfStations","updateStationsOrder","areStationsOnThePath","updateStationsOnPath","fetchPathElevationData","getPathElevation","enrichData","updateElevationGain","updateRouteType","updateElevationLoss","updateElevationTotalChange","drawElevationChart","getRouteParameters","parameters","isLengthConsistent","isElevationGainConsistent","ascent","isRouteTypeConsistent","updateDataConsistency","info","approveRoute","reloadTimeout","setTimeout","reload","on","clearTimeout","modal","always","removeLoaderFromButton","isIndex","HOT_COUNT","HOT_SPAN","nativeNow","Date","now","count","lastCalled","stamp","remaining","constant","baseSetToString","string","writable","setToString","shortOut","thisArg","args","nativeMax","transform","otherArgs","overRest","valIsDefined","valIsNull","valIsReflexive","valIsSymbol","othIsDefined","othIsNull","othIsReflexive","othIsSymbol","compareAscending","orders","objCriteria","criteria","othCriteria","ordersLength","comparer","baseSortBy","compareMultiple","spreadableSymbol","isConcatSpreadable","arrayPush","isFlattenable","depth","isStrict","comparator","current","computed","NAN","reTrim","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","valueOf","isBinary","toNumber","MAX_INTEGER","toFinite","remainder","fromIndex","fromRight","baseFindIndex","toInteger","keys","findIndexFunc","iterable","baseGet","baseProperty","basePropertyDeep","hasFunc","baseHasIn","hasPath","symbolProto","symbolToString","baseToString","FUNC_ERROR_TEXT","memoize","resolver","memoized","cache","Cache","MAX_MEMOIZE_SIZE","reLeadingDot","rePropName","reEscapeChar","memoizeCapped","quote","defaultValue","hasIn","isStrictComparable","matchesStrictComparable","objValue","source","matchData","noCustomizer","baseIsMatch","getMatchData","eachFunc","keysFunc","props","baseFor","createBaseFor","baseTimes","inherited","isArr","isArg","isBuff","isType","skipIndexes","String","stubArray","nativeGetSymbols","getOwnPropertySymbols","getSymbols","symbol","symbolsFunc","baseGetAllKeys","getAllKeys","objProps","objLength","skipCtor","objCtor","othCtor","Uint8Array","equalArrays","mapToArray","setToArray","boolTag","dateTag","errorTag","numberTag","regexpTag","stringTag","arrayBufferTag","dataViewTag","symbolValueOf","byteLength","byteOffset","buffer","message","convert","HASH_UNDEFINED","setCacheAdd","setCacheHas","add","getMapData","hashClear","hashDelete","hashGet","hashHas","hashSet","Hash","LARGE_ARRAY_SIZE","assocIndexOf","equalByTag","equalObjects","argsTag","arrayTag","objectTag","objIsArr","othIsArr","objTag","othTag","objIsObj","othIsObj","isSameTag","objIsWrapped","othIsWrapped","objUnwrapped","othUnwrapped","freeProcess","binding","typedArrayTags","coreJsData","uid","maskSrcKey","IE_PROTO","nativeObjectToString","isOwn","unmasked","eval","isMasked","reIsHostCtor","funcProto","reIsNative","RegExp","arg","overArg","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","run","marker","runClearTimeout","Item","nextTick","title","env","argv","version","versions","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","cwd","chdir","dir","umask"],"mappings":"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","file":"edk-route-verifier.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 57);\n","/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      var storageKey = \"loglevel\";\n      if (name) {\n        storageKey += \":\" + name;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"string\" || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    return defaultLogger;\n}));\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","var baseIsNative = require('./_baseIsNative'),\n    getValue = require('./_getValue');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n","/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","var isFunction = require('./isFunction'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n","var baseMatches = require('./_baseMatches'),\n    baseMatchesProperty = require('./_baseMatchesProperty'),\n    identity = require('./identity'),\n    isArray = require('./isArray'),\n    property = require('./property');\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\nmodule.exports = baseIteratee;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","var isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = toKey;\n","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeys = require('./_baseKeys'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n","var isKeyable = require('./_isKeyable');\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n","var getNative = require('./_getNative');\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n","var eq = require('./eq');\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n","var listCacheClear = require('./_listCacheClear'),\n    listCacheDelete = require('./_listCacheDelete'),\n    listCacheGet = require('./_listCacheGet'),\n    listCacheHas = require('./_listCacheHas'),\n    listCacheSet = require('./_listCacheSet');\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n","var baseIsArguments = require('./_baseIsArguments'),\n    isObjectLike = require('./isObjectLike');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n","/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n","var isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nmodule.exports = isKey;\n","var baseForOwn = require('./_baseForOwn'),\n    createBaseEach = require('./_createBaseEach');\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\nmodule.exports = baseEach;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n","var mapCacheClear = require('./_mapCacheClear'),\n    mapCacheDelete = require('./_mapCacheDelete'),\n    mapCacheGet = require('./_mapCacheGet'),\n    mapCacheHas = require('./_mapCacheHas'),\n    mapCacheSet = require('./_mapCacheSet');\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n","/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n","var baseIsEqualDeep = require('./_baseIsEqualDeep'),\n    isObjectLike = require('./isObjectLike');\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\nmodule.exports = baseIsEqual;\n","var baseIsTypedArray = require('./_baseIsTypedArray'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n","var root = require('./_root'),\n    stubFalse = require('./stubFalse');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n","var baseFlatten = require('./_baseFlatten'),\n    baseOrderBy = require('./_baseOrderBy'),\n    baseRest = require('./_baseRest'),\n    isIterateeCall = require('./_isIterateeCall');\n\n/**\n * Creates an array of elements, sorted in ascending order by the results of\n * running each element in a collection thru each iteratee. This method\n * performs a stable sort, that is, it preserves the original sort order of\n * equal elements. The iteratees are invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {...(Function|Function[])} [iteratees=[_.identity]]\n *  The iteratees to sort by.\n * @returns {Array} Returns the new sorted array.\n * @example\n *\n * var users = [\n *   { 'user': 'fred',   'age': 48 },\n *   { 'user': 'barney', 'age': 36 },\n *   { 'user': 'fred',   'age': 40 },\n *   { 'user': 'barney', 'age': 34 }\n * ];\n *\n * _.sortBy(users, [function(o) { return o.user; }]);\n * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n *\n * _.sortBy(users, ['user', 'age']);\n * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]\n */\nvar sortBy = baseRest(function(collection, iteratees) {\n  if (collection == null) {\n    return [];\n  }\n  var length = iteratees.length;\n  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n    iteratees = [];\n  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n    iteratees = [iteratees[0]];\n  }\n  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n});\n\nmodule.exports = sortBy;\n","var baseExtremum = require('./_baseExtremum'),\n    baseLt = require('./_baseLt'),\n    identity = require('./identity');\n\n/**\n * Computes the minimum value of `array`. If `array` is empty or falsey,\n * `undefined` is returned.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {*} Returns the minimum value.\n * @example\n *\n * _.min([4, 2, 8, 6]);\n * // => 2\n *\n * _.min([]);\n * // => undefined\n */\nfunction min(array) {\n  return (array && array.length)\n    ? baseExtremum(array, identity, baseLt)\n    : undefined;\n}\n\nmodule.exports = min;\n","var baseEach = require('./_baseEach'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\nmodule.exports = baseMap;\n","var arrayMap = require('./_arrayMap'),\n    baseIteratee = require('./_baseIteratee'),\n    baseMap = require('./_baseMap'),\n    isArray = require('./isArray');\n\n/**\n * Creates an array of values by running each element in `collection` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n *\n * The guarded methods are:\n * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n * @example\n *\n * function square(n) {\n *   return n * n;\n * }\n *\n * _.map([4, 8], square);\n * // => [16, 64]\n *\n * _.map({ 'a': 4, 'b': 8 }, square);\n * // => [16, 64] (iteration order is not guaranteed)\n *\n * var users = [\n *   { 'user': 'barney' },\n *   { 'user': 'fred' }\n * ];\n *\n * // The `_.property` iteratee shorthand.\n * _.map(users, 'user');\n * // => ['barney', 'fred']\n */\nfunction map(collection, iteratee) {\n  var func = isArray(collection) ? arrayMap : baseMap;\n  return func(collection, baseIteratee(iteratee, 3));\n}\n\nmodule.exports = map;\n","var arrayEach = require('./_arrayEach'),\n    baseEach = require('./_baseEach'),\n    castFunction = require('./_castFunction'),\n    isArray = require('./isArray');\n\n/**\n * Iterates over elements of `collection` and invokes `iteratee` for each element.\n * The iteratee is invoked with three arguments: (value, index|key, collection).\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n * property are iterated like arrays. To avoid this behavior use `_.forIn`\n * or `_.forOwn` for object iteration.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @alias each\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n * @see _.forEachRight\n * @example\n *\n * _.forEach([1, 2], function(value) {\n *   console.log(value);\n * });\n * // => Logs `1` then `2`.\n *\n * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n *   console.log(key);\n * });\n * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n */\nfunction forEach(collection, iteratee) {\n  var func = isArray(collection) ? arrayEach : baseEach;\n  return func(collection, castFunction(iteratee));\n}\n\nmodule.exports = forEach;\n","var createFind = require('./_createFind'),\n    findIndex = require('./findIndex');\n\n/**\n * Iterates over elements of `collection`, returning the first element\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {*} Returns the matched element, else `undefined`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'age': 36, 'active': true },\n *   { 'user': 'fred',    'age': 40, 'active': false },\n *   { 'user': 'pebbles', 'age': 1,  'active': true }\n * ];\n *\n * _.find(users, function(o) { return o.age < 40; });\n * // => object for 'barney'\n *\n * // The `_.matches` iteratee shorthand.\n * _.find(users, { 'age': 1, 'active': true });\n * // => object for 'pebbles'\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.find(users, ['active', false]);\n * // => object for 'fred'\n *\n * // The `_.property` iteratee shorthand.\n * _.find(users, 'active');\n * // => object for 'barney'\n */\nvar find = createFind(findIndex);\n\nmodule.exports = find;\n","var isArray = require('./isArray'),\n    isKey = require('./_isKey'),\n    stringToPath = require('./_stringToPath'),\n    toString = require('./toString');\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nmodule.exports = castPath;\n","var castPath = require('./_castPath'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n","/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\nmodule.exports = matchesStrictComparable;\n","var isObject = require('./isObject');\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\nmodule.exports = isStrictComparable;\n","var arrayFilter = require('./_arrayFilter'),\n    baseFilter = require('./_baseFilter'),\n    baseIteratee = require('./_baseIteratee'),\n    isArray = require('./isArray');\n\n/**\n * Iterates over elements of `collection`, returning an array of all elements\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * **Note:** Unlike `_.remove`, this method returns a new array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n * @see _.reject\n * @example\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': true },\n *   { 'user': 'fred',   'age': 40, 'active': false }\n * ];\n *\n * _.filter(users, function(o) { return !o.active; });\n * // => objects for ['fred']\n *\n * // The `_.matches` iteratee shorthand.\n * _.filter(users, { 'age': 36, 'active': true });\n * // => objects for ['barney']\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.filter(users, ['active', false]);\n * // => objects for ['fred']\n *\n * // The `_.property` iteratee shorthand.\n * _.filter(users, 'active');\n * // => objects for ['barney']\n */\nfunction filter(collection, predicate) {\n  var func = isArray(collection) ? arrayFilter : baseFilter;\n  return func(collection, baseIteratee(predicate, 3));\n}\n\nmodule.exports = filter;\n","/**\n * Checks if `value` is `null`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n * @example\n *\n * _.isNull(null);\n * // => true\n *\n * _.isNull(void 0);\n * // => false\n */\nfunction isNull(value) {\n  return value === null;\n}\n\nmodule.exports = isNull;\n","/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayFilter;\n","/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n","var SetCache = require('./_SetCache'),\n    arraySome = require('./_arraySome'),\n    cacheHas = require('./_cacheHas');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalArrays;\n","var ListCache = require('./_ListCache'),\n    stackClear = require('./_stackClear'),\n    stackDelete = require('./_stackDelete'),\n    stackGet = require('./_stackGet'),\n    stackHas = require('./_stackHas'),\n    stackSet = require('./_stackSet');\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nmodule.exports = Stack;\n","var baseIsEqual = require('./_baseIsEqual');\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\nmodule.exports = isEqual;\n","/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n","var DataView = require('./_DataView'),\n    Map = require('./_Map'),\n    Promise = require('./_Promise'),\n    Set = require('./_Set'),\n    WeakMap = require('./_WeakMap'),\n    baseGetTag = require('./_baseGetTag'),\n    toSource = require('./_toSource');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nmodule.exports = getTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n","var isPrototype = require('./_isPrototype'),\n    nativeKeys = require('./_nativeKeys');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n","var baseKeys = require('./_baseKeys'),\n    getTag = require('./_getTag'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isArrayLike = require('./isArrayLike'),\n    isBuffer = require('./isBuffer'),\n    isPrototype = require('./_isPrototype'),\n    isTypedArray = require('./isTypedArray');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    setTag = '[object Set]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if `value` is an empty object, collection, map, or set.\n *\n * Objects are considered empty if they have no own enumerable string keyed\n * properties.\n *\n * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n * jQuery-like collections are considered empty if they have a `length` of `0`.\n * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n * @example\n *\n * _.isEmpty(null);\n * // => true\n *\n * _.isEmpty(true);\n * // => true\n *\n * _.isEmpty(1);\n * // => true\n *\n * _.isEmpty([1, 2, 3]);\n * // => false\n *\n * _.isEmpty({ 'a': 1 });\n * // => false\n */\nfunction isEmpty(value) {\n  if (value == null) {\n    return true;\n  }\n  if (isArrayLike(value) &&\n      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n        isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n    return !value.length;\n  }\n  var tag = getTag(value);\n  if (tag == mapTag || tag == setTag) {\n    return !value.size;\n  }\n  if (isPrototype(value)) {\n    return !baseKeys(value).length;\n  }\n  for (var key in value) {\n    if (hasOwnProperty.call(value, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = isEmpty;\n","var toGeoJSON = (function() {\n    'use strict';\n\n    var removeSpace = /\\s*/g,\n        trimSpace = /^\\s*|\\s*$/g,\n        splitSpace = /\\s+/;\n    // generate a short, numeric hash of a string\n    function okhash(x) {\n        if (!x || !x.length) return 0;\n        for (var i = 0, h = 0; i < x.length; i++) {\n            h = ((h << 5) - h) + x.charCodeAt(i) | 0;\n        } return h;\n    }\n    // all Y children of X\n    function get(x, y) { return x.getElementsByTagName(y); }\n    function attr(x, y) { return x.getAttribute(y); }\n    function attrf(x, y) { return parseFloat(attr(x, y)); }\n    // one Y child of X, if any, otherwise null\n    function get1(x, y) { var n = get(x, y); return n.length ? n[0] : null; }\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node.normalize\n    function norm(el) { if (el.normalize) { el.normalize(); } return el; }\n    // cast array x into numbers\n    function numarray(x) {\n        for (var j = 0, o = []; j < x.length; j++) { o[j] = parseFloat(x[j]); }\n        return o;\n    }\n    // get the content of a text node, if any\n    function nodeVal(x) {\n        if (x) { norm(x); }\n        return (x && x.textContent) || '';\n    }\n    // get the contents of multiple text nodes, if present\n    function getMulti(x, ys) {\n        var o = {}, n, k;\n        for (k = 0; k < ys.length; k++) {\n            n = get1(x, ys[k]);\n            if (n) o[ys[k]] = nodeVal(n);\n        }\n        return o;\n    }\n    // add properties of Y to X, overwriting if present in both\n    function extend(x, y) { for (var k in y) x[k] = y[k]; }\n    // get one coordinate from a coordinate array, if any\n    function coord1(v) { return numarray(v.replace(removeSpace, '').split(',')); }\n    // get all coordinates from a coordinate array as [[],[]]\n    function coord(v) {\n        var coords = v.replace(trimSpace, '').split(splitSpace),\n            o = [];\n        for (var i = 0; i < coords.length; i++) {\n            o.push(coord1(coords[i]));\n        }\n        return o;\n    }\n    function coordPair(x) {\n        var ll = [attrf(x, 'lon'), attrf(x, 'lat')],\n            ele = get1(x, 'ele'),\n            // handle namespaced attribute in browser\n            heartRate = get1(x, 'gpxtpx:hr') || get1(x, 'hr'),\n            time = get1(x, 'time'),\n            e;\n        if (ele) {\n            e = parseFloat(nodeVal(ele));\n            if (!isNaN(e)) {\n                ll.push(e);\n            }\n        }\n        return {\n            coordinates: ll,\n            time: time ? nodeVal(time) : null,\n            heartRate: heartRate ? parseFloat(nodeVal(heartRate)) : null\n        };\n    }\n\n    // create a new feature collection parent object\n    function fc() {\n        return {\n            type: 'FeatureCollection',\n            features: []\n        };\n    }\n\n    var serializer;\n    if (typeof XMLSerializer !== 'undefined') {\n        /* istanbul ignore next */\n        serializer = new XMLSerializer();\n    // only require xmldom in a node environment\n    } else if (typeof exports === 'object' && typeof process === 'object' && !process.browser) {\n        serializer = new (require('xmldom').XMLSerializer)();\n    }\n    function xml2str(str) {\n        // IE9 will create a new XMLSerializer but it'll crash immediately.\n        // This line is ignored because we don't run coverage tests in IE9\n        /* istanbul ignore next */\n        if (str.xml !== undefined) return str.xml;\n        return serializer.serializeToString(str);\n    }\n\n    var t = {\n        kml: function(doc) {\n\n            var gj = fc(),\n                // styleindex keeps track of hashed styles in order to match features\n                styleIndex = {}, styleByHash = {},\n                // stylemapindex keeps track of style maps to expose in properties\n                styleMapIndex = {},\n                // atomic geospatial types supported by KML - MultiGeometry is\n                // handled separately\n                geotypes = ['Polygon', 'LineString', 'Point', 'Track', 'gx:Track'],\n                // all root placemarks in the file\n                placemarks = get(doc, 'Placemark'),\n                styles = get(doc, 'Style'),\n                styleMaps = get(doc, 'StyleMap');\n\n            for (var k = 0; k < styles.length; k++) {\n                var hash = okhash(xml2str(styles[k])).toString(16);\n                styleIndex['#' + attr(styles[k], 'id')] = hash;\n                styleByHash[hash] = styles[k];\n            }\n            for (var l = 0; l < styleMaps.length; l++) {\n                styleIndex['#' + attr(styleMaps[l], 'id')] = okhash(xml2str(styleMaps[l])).toString(16);\n                var pairs = get(styleMaps[l], 'Pair');\n                var pairsMap = {};\n                for (var m = 0; m < pairs.length; m++) {\n                    pairsMap[nodeVal(get1(pairs[m], 'key'))] = nodeVal(get1(pairs[m], 'styleUrl'));\n                }\n                styleMapIndex['#' + attr(styleMaps[l], 'id')] = pairsMap;\n\n            }\n            for (var j = 0; j < placemarks.length; j++) {\n                gj.features = gj.features.concat(getPlacemark(placemarks[j]));\n            }\n            function kmlColor(v) {\n                var color, opacity;\n                v = v || '';\n                if (v.substr(0, 1) === '#') { v = v.substr(1); }\n                if (v.length === 6 || v.length === 3) { color = v; }\n                if (v.length === 8) {\n                    opacity = parseInt(v.substr(0, 2), 16) / 255;\n                    color = '#' + v.substr(6, 2) +\n                        v.substr(4, 2) +\n                        v.substr(2, 2);\n                }\n                return [color, isNaN(opacity) ? undefined : opacity];\n            }\n            function gxCoord(v) { return numarray(v.split(' ')); }\n            function gxCoords(root) {\n                var elems = get(root, 'coord', 'gx'), coords = [], times = [];\n                if (elems.length === 0) elems = get(root, 'gx:coord');\n                for (var i = 0; i < elems.length; i++) coords.push(gxCoord(nodeVal(elems[i])));\n                var timeElems = get(root, 'when');\n                for (var j = 0; j < timeElems.length; j++) times.push(nodeVal(timeElems[j]));\n                return {\n                    coords: coords,\n                    times: times\n                };\n            }\n            function getGeometry(root) {\n                var geomNode, geomNodes, i, j, k, geoms = [], coordTimes = [];\n                if (get1(root, 'MultiGeometry')) { return getGeometry(get1(root, 'MultiGeometry')); }\n                if (get1(root, 'MultiTrack')) { return getGeometry(get1(root, 'MultiTrack')); }\n                if (get1(root, 'gx:MultiTrack')) { return getGeometry(get1(root, 'gx:MultiTrack')); }\n                for (i = 0; i < geotypes.length; i++) {\n                    geomNodes = get(root, geotypes[i]);\n                    if (geomNodes) {\n                        for (j = 0; j < geomNodes.length; j++) {\n                            geomNode = geomNodes[j];\n                            if (geotypes[i] === 'Point') {\n                                geoms.push({\n                                    type: 'Point',\n                                    coordinates: coord1(nodeVal(get1(geomNode, 'coordinates')))\n                                });\n                            } else if (geotypes[i] === 'LineString') {\n                                geoms.push({\n                                    type: 'LineString',\n                                    coordinates: coord(nodeVal(get1(geomNode, 'coordinates')))\n                                });\n                            } else if (geotypes[i] === 'Polygon') {\n                                var rings = get(geomNode, 'LinearRing'),\n                                    coords = [];\n                                for (k = 0; k < rings.length; k++) {\n                                    coords.push(coord(nodeVal(get1(rings[k], 'coordinates'))));\n                                }\n                                geoms.push({\n                                    type: 'Polygon',\n                                    coordinates: coords\n                                });\n                            } else if (geotypes[i] === 'Track' ||\n                                geotypes[i] === 'gx:Track') {\n                                var track = gxCoords(geomNode);\n                                geoms.push({\n                                    type: 'LineString',\n                                    coordinates: track.coords\n                                });\n                                if (track.times.length) coordTimes.push(track.times);\n                            }\n                        }\n                    }\n                }\n                return {\n                    geoms: geoms,\n                    coordTimes: coordTimes\n                };\n            }\n            function getPlacemark(root) {\n                var geomsAndTimes = getGeometry(root), i, properties = {},\n                    name = nodeVal(get1(root, 'name')),\n                    styleUrl = nodeVal(get1(root, 'styleUrl')),\n                    description = nodeVal(get1(root, 'description')),\n                    timeSpan = get1(root, 'TimeSpan'),\n                    timeStamp = get1(root, 'TimeStamp'),\n                    extendedData = get1(root, 'ExtendedData'),\n                    lineStyle = get1(root, 'LineStyle'),\n                    polyStyle = get1(root, 'PolyStyle'),\n                    visibility = get1(root, 'visibility');\n\n                if (!geomsAndTimes.geoms.length) return [];\n                if (name) properties.name = name;\n                if (styleUrl) {\n                    if (styleUrl[0] !== '#') {\n                        styleUrl = '#' + styleUrl;\n                    }\n\n                    properties.styleUrl = styleUrl;\n                    if (styleIndex[styleUrl]) {\n                        properties.styleHash = styleIndex[styleUrl];\n                    }\n                    if (styleMapIndex[styleUrl]) {\n                        properties.styleMapHash = styleMapIndex[styleUrl];\n                        properties.styleHash = styleIndex[styleMapIndex[styleUrl].normal];\n                    }\n                    // Try to populate the lineStyle or polyStyle since we got the style hash\n                    var style = styleByHash[properties.styleHash];\n                    if (style) {\n                        if (!lineStyle) lineStyle = get1(style, 'LineStyle');\n                        if (!polyStyle) polyStyle = get1(style, 'PolyStyle');\n                    }\n                }\n                if (description) properties.description = description;\n                if (timeSpan) {\n                    var begin = nodeVal(get1(timeSpan, 'begin'));\n                    var end = nodeVal(get1(timeSpan, 'end'));\n                    properties.timespan = { begin: begin, end: end };\n                }\n                if (timeStamp) {\n                    properties.timestamp = nodeVal(get1(timeStamp, 'when'));\n                }\n                if (lineStyle) {\n                    var linestyles = kmlColor(nodeVal(get1(lineStyle, 'color'))),\n                        color = linestyles[0],\n                        opacity = linestyles[1],\n                        width = parseFloat(nodeVal(get1(lineStyle, 'width')));\n                    if (color) properties.stroke = color;\n                    if (!isNaN(opacity)) properties['stroke-opacity'] = opacity;\n                    if (!isNaN(width)) properties['stroke-width'] = width;\n                }\n                if (polyStyle) {\n                    var polystyles = kmlColor(nodeVal(get1(polyStyle, 'color'))),\n                        pcolor = polystyles[0],\n                        popacity = polystyles[1],\n                        fill = nodeVal(get1(polyStyle, 'fill')),\n                        outline = nodeVal(get1(polyStyle, 'outline'));\n                    if (pcolor) properties.fill = pcolor;\n                    if (!isNaN(popacity)) properties['fill-opacity'] = popacity;\n                    if (fill) properties['fill-opacity'] = fill === '1' ? properties['fill-opacity'] || 1 : 0;\n                    if (outline) properties['stroke-opacity'] = outline === '1' ? properties['stroke-opacity'] || 1 : 0;\n                }\n                if (extendedData) {\n                    var datas = get(extendedData, 'Data'),\n                        simpleDatas = get(extendedData, 'SimpleData');\n\n                    for (i = 0; i < datas.length; i++) {\n                        properties[datas[i].getAttribute('name')] = nodeVal(get1(datas[i], 'value'));\n                    }\n                    for (i = 0; i < simpleDatas.length; i++) {\n                        properties[simpleDatas[i].getAttribute('name')] = nodeVal(simpleDatas[i]);\n                    }\n                }\n                if (visibility) {\n                    properties.visibility = nodeVal(visibility);\n                }\n                if (geomsAndTimes.coordTimes.length) {\n                    properties.coordTimes = (geomsAndTimes.coordTimes.length === 1) ?\n                        geomsAndTimes.coordTimes[0] : geomsAndTimes.coordTimes;\n                }\n                var feature = {\n                    type: 'Feature',\n                    geometry: (geomsAndTimes.geoms.length === 1) ? geomsAndTimes.geoms[0] : {\n                        type: 'GeometryCollection',\n                        geometries: geomsAndTimes.geoms\n                    },\n                    properties: properties\n                };\n                if (attr(root, 'id')) feature.id = attr(root, 'id');\n                return [feature];\n            }\n            return gj;\n        },\n        gpx: function(doc) {\n            var i,\n                tracks = get(doc, 'trk'),\n                routes = get(doc, 'rte'),\n                waypoints = get(doc, 'wpt'),\n                // a feature collection\n                gj = fc(),\n                feature;\n            for (i = 0; i < tracks.length; i++) {\n                feature = getTrack(tracks[i]);\n                if (feature) gj.features.push(feature);\n            }\n            for (i = 0; i < routes.length; i++) {\n                feature = getRoute(routes[i]);\n                if (feature) gj.features.push(feature);\n            }\n            for (i = 0; i < waypoints.length; i++) {\n                gj.features.push(getPoint(waypoints[i]));\n            }\n            function getPoints(node, pointname) {\n                var pts = get(node, pointname),\n                    line = [],\n                    times = [],\n                    heartRates = [],\n                    l = pts.length;\n                if (l < 2) return {};  // Invalid line in GeoJSON\n                for (var i = 0; i < l; i++) {\n                    var c = coordPair(pts[i]);\n                    line.push(c.coordinates);\n                    if (c.time) times.push(c.time);\n                    if (c.heartRate) heartRates.push(c.heartRate);\n                }\n                return {\n                    line: line,\n                    times: times,\n                    heartRates: heartRates\n                };\n            }\n            function getTrack(node) {\n                var segments = get(node, 'trkseg'),\n                    track = [],\n                    times = [],\n                    heartRates = [],\n                    line;\n                for (var i = 0; i < segments.length; i++) {\n                    line = getPoints(segments[i], 'trkpt');\n                    if (line) {\n                        if (line.line) track.push(line.line);\n                        if (line.times && line.times.length) times.push(line.times);\n                        if (line.heartRates && line.heartRates.length) heartRates.push(line.heartRates);\n                    }\n                }\n                if (track.length === 0) return;\n                var properties = getProperties(node);\n                if (times.length) properties.coordTimes = track.length === 1 ? times[0] : times;\n                if (heartRates.length) properties.heartRates = track.length === 1 ? heartRates[0] : heartRates;\n                return {\n                    type: 'Feature',\n                    properties: properties,\n                    geometry: {\n                        type: track.length === 1 ? 'LineString' : 'MultiLineString',\n                        coordinates: track.length === 1 ? track[0] : track\n                    }\n                };\n            }\n            function getRoute(node) {\n                var line = getPoints(node, 'rtept');\n                if (!line.line) return;\n                var routeObj = {\n                    type: 'Feature',\n                    properties: getProperties(node),\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: line.line\n                    }\n                };\n                return routeObj;\n            }\n            function getPoint(node) {\n                var prop = getProperties(node);\n                extend(prop, getMulti(node, ['sym', 'type']));\n                return {\n                    type: 'Feature',\n                    properties: prop,\n                    geometry: {\n                        type: 'Point',\n                        coordinates: coordPair(node).coordinates\n                    }\n                };\n            }\n            function getProperties(node) {\n                var prop, links;\n                prop = getMulti(node, ['name', 'cmt', 'desc', 'time', 'keywords']);\n                links = get(node, 'link');\n                if (links.length) prop.links = [];\n                for (var i = 0, link; i < links.length; i++) {\n                    link = { href: attr(links[i], 'href') };\n                    extend(link, getMulti(links[i], ['text', 'type']));\n                    prop.links.push(link);\n                }\n                return prop;\n            }\n            return gj;\n        }\n    };\n    return t;\n})();\n\nif (typeof module !== 'undefined') module.exports = toGeoJSON;\n","/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325,\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nvar unitsFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000,\n    millimetres: 1000,\n    centimeters: 100,\n    centimetres: 100,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    miles: 1 / 1609.344,\n    nauticalmiles: 1 / 1852,\n    inches: 39.370,\n    yards: 1 / 1.0936,\n    feet: 3.28084,\n    radians: 1 / earthRadius,\n    degrees: 1 / 111325,\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nvar areaFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    centimeters: 10000,\n    centimetres: 10000,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox) validateBBox(bbox);\n\n    // Main\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (length === null || length === undefined) throw new Error('length is required');\n    if (!(length >= 0)) throw new Error('length must be a positive number');\n\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) throw new Error('bbox is required');\n    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n    });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) throw new Error('id is required');\n    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nfunction degrees2radians() {\n    throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nfunction distanceToDegrees() {\n    throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nfunction distanceToRadians() {\n    throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nfunction radiansToDistance() {\n    throw new Error('method has been renamed to `radiansToLength`');\n}\n\nfunction bearingToAngle() {\n    throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nfunction convertDistance() {\n    throw new Error('method has been renamed to `convertLength`');\n}\n\nexport { earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId, radians2degrees, degrees2radians, distanceToDegrees, distanceToRadians, radiansToDistance, bearingToAngle, convertDistance };\n","import { feature, isObject, lineString, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    if (geomType === 'MultiPolygon') geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature$$1.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature$$1.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        if (coordEach(feature$$1, function (currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined) {\n                previousCoords = currentCoord;\n                return;\n            }\n            var currentSegment = lineString([previousCoords, currentCoord], feature$$1.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        if (feature$$1.geometry === null) return;\n        var type = feature$$1.geometry.type;\n        var coords = feature$$1.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(lineString(coords[geometryIndex], feature$$1.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexport { coordEach, coordReduce, propEach, propReduce, featureEach, featureReduce, coordAll, geomEach, geomReduce, flattenEach, flattenReduce, segmentEach, segmentReduce, lineEach, lineReduce, findSegment, findPoint };\n","/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325,\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nvar unitsFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000,\n    millimetres: 1000,\n    centimeters: 100,\n    centimetres: 100,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    miles: 1 / 1609.344,\n    nauticalmiles: 1 / 1852,\n    inches: 39.370,\n    yards: 1 / 1.0936,\n    feet: 3.28084,\n    radians: 1 / earthRadius,\n    degrees: 1 / 111325,\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nvar areaFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    centimeters: 10000,\n    centimetres: 10000,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox) validateBBox(bbox);\n\n    // Main\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (length === null || length === undefined) throw new Error('length is required');\n    if (!(length >= 0)) throw new Error('length must be a positive number');\n\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) throw new Error('bbox is required');\n    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n    });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) throw new Error('id is required');\n    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nfunction degrees2radians() {\n    throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nfunction distanceToDegrees() {\n    throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nfunction distanceToRadians() {\n    throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nfunction radiansToDistance() {\n    throw new Error('method has been renamed to `radiansToLength`');\n}\n\nfunction bearingToAngle() {\n    throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nfunction convertDistance() {\n    throw new Error('method has been renamed to `convertLength`');\n}\n\nexport { earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId, radians2degrees, degrees2radians, distanceToDegrees, distanceToRadians, radiansToDistance, bearingToAngle, convertDistance };\n","import { flattenEach } from '@turf/meta';\nimport { featureCollection } from '@turf/helpers';\n\n/**\n * Flattens any {@link GeoJSON} to a {@link FeatureCollection} inspired by [geojson-flatten](https://github.com/tmcw/geojson-flatten).\n *\n * @name flatten\n * @param {GeoJSON} geojson any valid GeoJSON Object\n * @returns {FeatureCollection<any>} all Multi-Geometries are flattened into single Features\n * @example\n * var multiGeometry = turf.multiPolygon([\n *   [[[102.0, 2.0], [103.0, 2.0], [103.0, 3.0], [102.0, 3.0], [102.0, 2.0]]],\n *   [[[100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0]],\n *   [[100.2, 0.2], [100.8, 0.2], [100.8, 0.8], [100.2, 0.8], [100.2, 0.2]]]\n * ]);\n *\n * var flatten = turf.flatten(multiGeometry);\n *\n * //addToMap\n * var addToMap = [flatten]\n */\nfunction flatten(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n\n    var results = [];\n    flattenEach(geojson, function (feature) {\n        results.push(feature);\n    });\n    return featureCollection(results);\n}\n\nexport default flatten;\n","import logger from 'loglevel';\nimport toGeoJSON from 'togeojson';\nimport flatten from '@turf/flatten';\nimport * as _ from './lodash';\n\n\nexport default class Helpers {\n    static getGeoJSON(kml) {\n        const extendedData = kml.getElementsByTagName('ExtendedData');\n        for (let index = extendedData.length - 1; index >= 0; index--) {\n            extendedData[index].parentNode.removeChild(extendedData[index]);\n        }\n        logger.log('KML (no ExtendedData):', kml);\n\n        let geoJson = toGeoJSON.kml(kml);\n        geoJson = flatten(geoJson);\n        logger.log('GeoJSON (flatten): ', geoJson);\n\n        return geoJson;\n    }\n\n    static getNumberOfFeatures(featureName, geoJson) {\n        const features = _.filter(geoJson.features,\n            feature => _.isEqual(feature.geometry.type, featureName));\n        return features.length;\n    }\n\n    static getLineString(geoJson) {\n        const lineString = _.find(geoJson.features,\n            feature => _.isEqual(feature.geometry.type, 'LineString'));\n        return lineString;\n    }\n\n    static reverseLineString(lineString) {\n        const newLineString = { ...lineString };\n        newLineString.geometry.coordinates = lineString.geometry.coordinates.reverse();\n        return newLineString;\n    }\n\n    static getPoints(geoJson) {\n        const points = _.filter(geoJson.features,\n            feature => _.isEqual(feature.geometry.type, 'Point'));\n        return points;\n    }\n\n    static getRoute(routeUrl) {\n        logger.debug('Fetching route from:', routeUrl);\n        return $.ajax(routeUrl);\n    }\n\n    static getGoogleMapsPath(lineString) {\n        const path = _.map(lineString.geometry.coordinates,\n            element => new google.maps.LatLng(element[1], element[0]));\n        return path;\n    }\n\n    static getPathElevations(lineString, useLocalElevations) {\n        if (useLocalElevations &&\n            lineString.geometry.coordinates[0].length === 3) {\n            // Elevation present in line string\n\n            logger.debug('Getting path elevations from line string...');\n            const elevations = _.map(lineString.geometry.coordinates,\n                element => ({ elevation: element[2] }));\n            logger.debug('Elevations:', elevations);\n            return new Promise((resolve, reject) => {\n                resolve(elevations);\n            });\n        }\n        // No elevation in line string\n        let path = this.getGoogleMapsPath(lineString);\n\n        // Optimize path array length\n        // This is done to send no more than\n        // MAXIMUM_NUMBER_OF_LATLNG_OBJECTS coordinates in KML path\n        const MAXIMUM_NUMBER_OF_SAMPLES = 512;\n        // Request to google.maps.ElevationService cannot be too long (2048 is too long)\n        const MAXIMUM_NUMBER_OF_LATLNG_OBJECTS = 1024;\n        logger.debug('Number of LatLng objects:', path.length);\n        if (path.length > MAXIMUM_NUMBER_OF_LATLNG_OBJECTS) {\n            const optimizedPath = [];\n            const delta = parseFloat(path.length / MAXIMUM_NUMBER_OF_LATLNG_OBJECTS);\n            for (let i = 0; i < path.length; i += delta) {\n                optimizedPath.push(path[Math.floor(i)]);\n            }\n            path = optimizedPath;\n            logger.debug('Number of LatLng objects after optimization:', path.length);\n        }\n\n        return new Promise((resolve, reject) => {\n            const elevator = new google.maps.ElevationService();\n            elevator.getElevationAlongPath({\n                path,\n                samples: MAXIMUM_NUMBER_OF_SAMPLES,\n            }, (elevations, status) => {\n                if (status === google.maps.ElevationStatus.OK) {\n                    resolve(elevations);\n                } else {\n                    reject(status);\n                }\n            });\n        });\n    }\n\n    static getRouteParameters(routeParamsUrl) {\n        return new Promise((resolve, reject) => {\n            $.ajax(routeParamsUrl)\n                .done(data => {\n                    logger.debug('Route parameters:', data);\n                    if (data.success === 1) {\n                        resolve(data);\n                    } else {\n                        reject(`Server side error: ${data.error}`);\n                    }\n                })\n                .fail((xhr, status) => {\n                    reject(status);\n                });\n        });\n    }\n\n    static approveRoute(routeApproveUrl) {\n        return new Promise((resolve, reject) => {\n            $.ajax(routeApproveUrl)\n                .done(data => {\n                    resolve({ success: true });\n                })\n                .fail((xhr, status) => {\n                    reject(status);\n                });\n        });\n    }\n}\n","const getGain = elevations => {\n    let elevationGain = 0.0;\n    for (let i = 1; i < elevations.length; i++) {\n        const elevationDifference = elevations[i].elevation - elevations[i - 1].elevation;\n        elevationGain += (elevationDifference > 0) ? elevationDifference : 0.0;\n    }\n    return Number(elevationGain);\n};\n\nconst getLoss = elevations => {\n    let elevationLoss = 0.0;\n    for (let i = 1; i < elevations.length; i++) {\n        const elevationDifference = elevations[i - 1].elevation - elevations[i].elevation;\n        elevationLoss += (elevationDifference > 0) ? elevationDifference : 0.0;\n    }\n    return Number(elevationLoss);\n};\n\n\nexport default class PathElevation {\n    constructor(elevations, length) {\n        this.gain = getGain(elevations);\n        this.loss = getLoss(elevations);\n        this.totalChange = this.loss + this.gain;\n        this.data = elevations;\n    }\n\n    enrichData(length) {\n        const elevationsWithDistance = [];\n        const resolution = length / this.data.length;\n        for (let i = 0; i < this.data.length; i++) {\n            elevationsWithDistance.push({\n                elevation: this.data[i].elevation, distance: i * resolution,\n            });\n        }\n        this.data = elevationsWithDistance;\n    }\n}\n\n","/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(obj) {\n    if (!obj) throw new Error('obj is required');\n\n    var coordinates = getCoords(obj);\n\n    // getCoord() must contain at least two numbers (Point)\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return coordinates;\n    } else {\n        throw new Error('Coordinate is not a valid Point');\n    }\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers\n *\n * @name getCoords\n * @param {Array<number>|Geometry|Feature} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coord = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(obj) {\n    if (!obj) throw new Error('obj is required');\n    var coordinates;\n\n    // Array of numbers\n    if (obj.length) {\n        coordinates = obj;\n\n    // Geometry Object\n    } else if (obj.coordinates) {\n        coordinates = obj.coordinates;\n\n    // Feature\n    } else if (obj.geometry && obj.geometry.coordinates) {\n        coordinates = obj.geometry.coordinates;\n    }\n    // Checks if coordinates contains a number\n    if (coordinates) {\n        containsNumber(coordinates);\n        return coordinates;\n    }\n    throw new Error('No valid coordinates');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\nexport function getGeomType() {\n    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n","import { getCoord } from '@turf/invariant';\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n\n/**\n * Takes two {@link Point|points} and finds the geographic bearing between them,\n * i.e. the angle measured in degrees from the north line (0 degrees)\n *\n * @name bearing\n * @param {Geometry|Feature<Point>|Array<number>} start starting Point\n * @param {Geometry|Feature<Point>|Array<number>} end ending Point\n * @param {Object} [options] Optional parameters\n * @param {boolean} [options.final=false] calculates the final bearing if true\n * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)\n * @example\n * var point1 = turf.point([-75.343, 39.984]);\n * var point2 = turf.point([-75.534, 39.123]);\n *\n * var bearing = turf.bearing(point1, point2);\n *\n * //addToMap\n * var addToMap = [point1, point2]\n * point1.properties['marker-color'] = '#f00'\n * point2.properties['marker-color'] = '#0f0'\n * point1.properties.bearing = bearing\n */\nfunction bearing(start, end, options) {\n    // Backwards compatible with v4.0\n    var final = (typeof options === 'object') ? options.final : options;\n    if (final === true) return calculateFinalBearing(start, end);\n\n    var degrees2radians = Math.PI / 180;\n    var radians2degrees = 180 / Math.PI;\n    var coordinates1 = getCoord(start);\n    var coordinates2 = getCoord(end);\n\n    var lon1 = degrees2radians * coordinates1[0];\n    var lon2 = degrees2radians * coordinates2[0];\n    var lat1 = degrees2radians * coordinates1[1];\n    var lat2 = degrees2radians * coordinates2[1];\n    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n    var b = Math.cos(lat1) * Math.sin(lat2) -\n        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n\n    var bear = radians2degrees * Math.atan2(a, b);\n\n    return bear;\n}\n\n/**\n * Calculates Final Bearing\n * @private\n * @param {Feature<Point>} start starting Point\n * @param {Feature<Point>} end ending Point\n * @returns {number} bearing\n */\nfunction calculateFinalBearing(start, end) {\n    // Swap start & end\n    var bear = bearing(end, start);\n    bear = (bear + 180) % 360;\n    return bear;\n}\n\nexport default bearing;\n","/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(obj) {\n    if (!obj) throw new Error('obj is required');\n\n    var coordinates = getCoords(obj);\n\n    // getCoord() must contain at least two numbers (Point)\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return coordinates;\n    } else {\n        throw new Error('Coordinate is not a valid Point');\n    }\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers\n *\n * @name getCoords\n * @param {Array<number>|Geometry|Feature} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coord = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(obj) {\n    if (!obj) throw new Error('obj is required');\n    var coordinates;\n\n    // Array of numbers\n    if (obj.length) {\n        coordinates = obj;\n\n    // Geometry Object\n    } else if (obj.coordinates) {\n        coordinates = obj.coordinates;\n\n    // Feature\n    } else if (obj.geometry && obj.geometry.coordinates) {\n        coordinates = obj.geometry.coordinates;\n    }\n    // Checks if coordinates contains a number\n    if (coordinates) {\n        containsNumber(coordinates);\n        return coordinates;\n    }\n    throw new Error('No valid coordinates');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\nexport function getGeomType() {\n    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n","/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geometry, properties, bbox, id) {\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nexport function geometry(type, coordinates, bbox) {\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Takes coordinates and properties (optional) and returns a new {@link Point} feature.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n    if (coordinates.length === undefined) throw new Error('Coordinates must be an array');\n    if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('Coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a {@link Polygon} feature.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<Polygon>} a Polygon feature\n * @throws {Error} throw an error if a LinearRing of the polygon has too few positions\n * or if a LinearRing of the Polygon does not have matching Positions at the beginning & end.\n * @example\n * var polygon = turf.polygon([[\n *   [-2.275543, 53.464547],\n *   [-2.275543, 53.489271],\n *   [-2.215118, 53.489271],\n *   [-2.215118, 53.464547],\n *   [-2.275543, 53.464547]\n * ]], { name: 'poly1', population: 400});\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('Coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link LineString} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<LineString>} a LineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var linestring1 = turf.lineString([\n *   [-21.964416, 64.148203],\n *   [-21.956176, 64.141316],\n *   [-21.93901, 64.135924],\n *   [-21.927337, 64.136673]\n * ]);\n * var linestring2 = turf.lineString([\n *   [-21.929054, 64.127985],\n *   [-21.912918, 64.134726],\n *   [-21.916007, 64.141016],\n *   [-21.930084, 64.14446]\n * ], {name: 'line 1', distance: 145});\n *\n * //=linestring1\n *\n * //=linestring2\n */\nexport function lineString(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('Coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {FeatureCollection} a FeatureCollection of input features\n * @example\n * var features = [\n *  turf.point([-75.343, 39.984], {name: 'Location A'}),\n *  turf.point([-75.833, 39.284], {name: 'Location B'}),\n *  turf.point([-75.534, 39.123], {name: 'Location C'})\n * ];\n *\n * var collection = turf.featureCollection(features);\n *\n * //=collection\n */\nexport function featureCollection(features, bbox, id) {\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nexport function geometryCollection(geometries, properties, bbox, id) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, bbox, id);\n}\n\n// https://en.wikipedia.org/wiki/Great-circle_distance#Radius_for_spherical_Earth\nvar factors = {\n    miles: 3960,\n    nauticalmiles: 3441.145,\n    degrees: 57.2957795,\n    radians: 1,\n    inches: 250905600,\n    yards: 6969600,\n    meters: 6373000,\n    metres: 6373000,\n    centimeters: 6.373e+8,\n    centimetres: 6.373e+8,\n    kilometers: 6373,\n    kilometres: 6373,\n    feet: 20908792.65\n};\n\nvar areaFactors = {\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    centimetres: 10000,\n    millimeter: 1000000,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToDistance\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToDistance(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name distanceToRadians\n * @param {number} distance in real units\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function distanceToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name distanceToDegrees\n * @param {number} distance in real units\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function distanceToDegrees(distance, units) {\n    return radians2degrees(distanceToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAngle\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAngle(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radians2degrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radians2degrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degrees2radians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degrees2radians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a distance to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} distance to be converted\n * @param {string} originalUnit of the distance\n * @param {string} [finalUnit=kilometers] returned unit\n * @returns {number} the converted distance\n */\nexport function convertDistance(distance, originalUnit, finalUnit) {\n    if (distance === null || distance === undefined) throw new Error('distance is required');\n    if (!(distance >= 0)) throw new Error('distance must be a positive number');\n\n    var convertedDistance = radiansToDistance(distanceToRadians(distance, originalUnit), finalUnit || 'kilometers');\n    return convertedDistance;\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeter, acre, mile, yard, foot, inch\n * @param {number} area to be converted\n * @param {string} [originalUnit=meters] of the distance\n * @param {string} [finalUnit=kilometers] returned unit\n * @returns {number} the converted distance\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nexport var earthRadius = 6371008.8;\n","import { getCoord } from '@turf/invariant';\nimport { radiansToDistance } from '@turf/helpers';\n\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians,\n * miles, or kilometers. This uses the\n * [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula)\n * to account for global curvature.\n *\n * @name distance\n * @param {Geometry|Feature<Point>|Array<number>} from origin point\n * @param {Geometry|Feature<Point>|Array<number>} to destination point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n *\n * var distance = turf.distance(from, to, \"miles\");\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n    // Backwards compatible with v4.0\n    var units = (typeof options === 'object') ? options.units : options;\n\n    var degrees2radians = Math.PI / 180;\n    var coordinates1 = getCoord(from);\n    var coordinates2 = getCoord(to);\n    var dLat = degrees2radians * (coordinates2[1] - coordinates1[1]);\n    var dLon = degrees2radians * (coordinates2[0] - coordinates1[0]);\n    var lat1 = degrees2radians * coordinates1[1];\n    var lat2 = degrees2radians * coordinates2[1];\n\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n          Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n\n    return radiansToDistance(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), units);\n}\n\nexport default distance;\n","/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(obj) {\n    if (!obj) throw new Error('obj is required');\n\n    var coordinates = getCoords(obj);\n\n    // getCoord() must contain at least two numbers (Point)\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return coordinates;\n    } else {\n        throw new Error('Coordinate is not a valid Point');\n    }\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers\n *\n * @name getCoords\n * @param {Array<number>|Geometry|Feature} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coord = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(obj) {\n    if (!obj) throw new Error('obj is required');\n    var coordinates;\n\n    // Array of numbers\n    if (obj.length) {\n        coordinates = obj;\n\n    // Geometry Object\n    } else if (obj.coordinates) {\n        coordinates = obj.coordinates;\n\n    // Feature\n    } else if (obj.geometry && obj.geometry.coordinates) {\n        coordinates = obj.geometry.coordinates;\n    }\n    // Checks if coordinates contains a number\n    if (coordinates) {\n        containsNumber(coordinates);\n        return coordinates;\n    }\n    throw new Error('No valid coordinates');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\nexport function getGeomType() {\n    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n","/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geometry, properties, bbox, id) {\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nexport function geometry(type, coordinates, bbox) {\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Takes coordinates and properties (optional) and returns a new {@link Point} feature.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n    if (coordinates.length === undefined) throw new Error('Coordinates must be an array');\n    if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('Coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a {@link Polygon} feature.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<Polygon>} a Polygon feature\n * @throws {Error} throw an error if a LinearRing of the polygon has too few positions\n * or if a LinearRing of the Polygon does not have matching Positions at the beginning & end.\n * @example\n * var polygon = turf.polygon([[\n *   [-2.275543, 53.464547],\n *   [-2.275543, 53.489271],\n *   [-2.215118, 53.489271],\n *   [-2.215118, 53.464547],\n *   [-2.275543, 53.464547]\n * ]], { name: 'poly1', population: 400});\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('Coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link LineString} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<LineString>} a LineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var linestring1 = turf.lineString([\n *   [-21.964416, 64.148203],\n *   [-21.956176, 64.141316],\n *   [-21.93901, 64.135924],\n *   [-21.927337, 64.136673]\n * ]);\n * var linestring2 = turf.lineString([\n *   [-21.929054, 64.127985],\n *   [-21.912918, 64.134726],\n *   [-21.916007, 64.141016],\n *   [-21.930084, 64.14446]\n * ], {name: 'line 1', distance: 145});\n *\n * //=linestring1\n *\n * //=linestring2\n */\nexport function lineString(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('Coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {FeatureCollection} a FeatureCollection of input features\n * @example\n * var features = [\n *  turf.point([-75.343, 39.984], {name: 'Location A'}),\n *  turf.point([-75.833, 39.284], {name: 'Location B'}),\n *  turf.point([-75.534, 39.123], {name: 'Location C'})\n * ];\n *\n * var collection = turf.featureCollection(features);\n *\n * //=collection\n */\nexport function featureCollection(features, bbox, id) {\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nexport function geometryCollection(geometries, properties, bbox, id) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, bbox, id);\n}\n\n// https://en.wikipedia.org/wiki/Great-circle_distance#Radius_for_spherical_Earth\nvar factors = {\n    miles: 3960,\n    nauticalmiles: 3441.145,\n    degrees: 57.2957795,\n    radians: 1,\n    inches: 250905600,\n    yards: 6969600,\n    meters: 6373000,\n    metres: 6373000,\n    centimeters: 6.373e+8,\n    centimetres: 6.373e+8,\n    kilometers: 6373,\n    kilometres: 6373,\n    feet: 20908792.65\n};\n\nvar areaFactors = {\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    centimetres: 10000,\n    millimeter: 1000000,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToDistance\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToDistance(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name distanceToRadians\n * @param {number} distance in real units\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function distanceToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name distanceToDegrees\n * @param {number} distance in real units\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function distanceToDegrees(distance, units) {\n    return radians2degrees(distanceToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAngle\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAngle(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radians2degrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radians2degrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degrees2radians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degrees2radians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a distance to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} distance to be converted\n * @param {string} originalUnit of the distance\n * @param {string} [finalUnit=kilometers] returned unit\n * @returns {number} the converted distance\n */\nexport function convertDistance(distance, originalUnit, finalUnit) {\n    if (distance === null || distance === undefined) throw new Error('distance is required');\n    if (!(distance >= 0)) throw new Error('distance must be a positive number');\n\n    var convertedDistance = radiansToDistance(distanceToRadians(distance, originalUnit), finalUnit || 'kilometers');\n    return convertedDistance;\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeter, acre, mile, yard, foot, inch\n * @param {number} area to be converted\n * @param {string} [originalUnit=meters] of the distance\n * @param {string} [finalUnit=kilometers] returned unit\n * @returns {number} the converted distance\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nexport var earthRadius = 6371008.8;\n","//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\nimport { getCoord } from '@turf/invariant';\nimport { point, distanceToRadians } from '@turf/helpers';\n\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in degrees, radians, miles, or kilometers; and bearing in degrees. This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Geometry|Feature<Point>|Array<number>} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} options Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var units = 'miles';\n *\n * var destination = turf.destination(point, distance, bearing, units);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\nfunction destination(origin, distance, bearing, options) {\n    // Backwards compatible with v4.0\n    var units = (typeof options === 'object') ? options.units : options;\n\n    var degrees2radians = Math.PI / 180;\n    var radians2degrees = 180 / Math.PI;\n    var coordinates1 = getCoord(origin);\n    var longitude1 = degrees2radians * coordinates1[0];\n    var latitude1 = degrees2radians * coordinates1[1];\n    var bearing_rad = degrees2radians * bearing;\n\n    var radians = distanceToRadians(distance, units);\n\n    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearing_rad));\n    var longitude2 = longitude1 + Math.atan2(Math.sin(bearing_rad) * Math.sin(radians) * Math.cos(latitude1),\n        Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n\n    return point([radians2degrees * longitude2, radians2degrees * latitude2]);\n}\n\nexport default destination;\n","function quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nexport default quickselect;\n","import quickselect from './quickselect';\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n\nexport default rbush;\n","/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0.\n * @param {number} featureIndex The current index of the feature being processed.\n * @param {number} featureSubIndex The current subIndex of the feature being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, featureSubIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=featureSubIndex\n * });\n */\nexport function coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var featureIndex, geometryIndex, j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (geometryIndex = 0; geometryIndex < stopG; geometryIndex++) {\n            var featureSubIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geometryIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                callback(coords, coordIndex, featureIndex, featureSubIndex);\n                coordIndex++;\n                featureSubIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    callback(coords[j], coordIndex, featureIndex, featureSubIndex);\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') featureSubIndex++;\n                }\n                if (geomType === 'LineString') featureSubIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        callback(coords[j][k], coordIndex, featureIndex, featureSubIndex);\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') featureSubIndex++;\n                }\n                if (geomType === 'Polygon') featureSubIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length; k++)\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            callback(coords[j][k][l], coordIndex, featureIndex, featureSubIndex);\n                            coordIndex++;\n                        }\n                    featureSubIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    coordEach(geometry.geometries[j], callback, excludeWrapCoord);\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the feature being processed.\n * @param {number} featureSubIndex The current subIndex of the feature being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=featureSubIndex\n *   return currentCoord;\n * });\n */\nexport function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current properties being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {(FeatureCollection|Feature)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nexport function propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            callback(geojson.features[i].properties, i);\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current properties being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {(FeatureCollection|Feature)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nexport function propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nexport function featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            callback(geojson.features[i], i);\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nexport function featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nexport function coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current geometry being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} currentProperties The current feature properties being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, currentProperties)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, currentProperties) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=currentProperties\n * });\n */\nexport function geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        geometryProperties,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        geometryProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                callback(null, featureIndex, geometryProperties);\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                callback(geometry, featureIndex, geometryProperties);\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    callback(geometry.geometries[j], featureIndex, geometryProperties);\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Feature being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {Object} currentProperties The current feature properties being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, currentProperties)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, currentProperties) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=currentProperties\n *   return currentGeometry\n * });\n */\nexport function geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, currentIndex, currentProperties) {\n        if (currentIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, currentIndex, currentProperties);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureSubIndex The subindex of the current element being processed in the\n * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, featureSubIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, featureSubIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=featureSubIndex\n * });\n */\nexport function flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            callback(feature(geometry, properties), featureIndex, 0);\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        geometry.coordinates.forEach(function (coordinate, featureSubIndex) {\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            callback(feature(geom, properties), featureIndex, featureSubIndex);\n        });\n\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureSubIndex The subindex of the current element being processed in the\n * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, featureSubIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, featureSubIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=featureSubIndex\n *   return currentFeature\n * });\n */\nexport function flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, featureSubIndex) {\n        if (featureIndex === 0 && featureSubIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, featureSubIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current segment being processed.\n * @param {number} featureIndex The featureIndex currently being processed, starts at index 0.\n * @param {number} featureSubIndex The featureSubIndex currently being processed, starts at index 0.\n * @param {number} segmentIndex The segmentIndex currently being processed, starts at index 0.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, featureSubIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, featureSubIndex, segmentIndex) {\n *   //= currentSegment\n *   //= featureIndex\n *   //= featureSubIndex\n *   //= segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nexport function segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, featureSubIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        coordReduce(feature, function (previousCoords, currentCoord) {\n            var currentSegment = lineString([previousCoords, currentCoord], feature.properties);\n            callback(currentSegment, featureIndex, featureSubIndex, segmentIndex);\n            segmentIndex++;\n            return currentCoord;\n        });\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} [previousValue] The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} [currentSegment] The current segment being processed.\n * @param {number} featureIndex The featureIndex currently being processed, starts at index 0.\n * @param {number} featureSubIndex The featureSubIndex currently being processed, starts at index 0.\n * @param {number} segmentIndex The segmentIndex currently being processed, starts at index 0.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, featureSubIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= featureSubIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nexport function segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, featureSubIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, featureSubIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Create Feature\n *\n * @private\n * @param {Geometry} geometry GeoJSON Geometry\n * @param {Object} properties Properties\n * @returns {Feature} GeoJSON Feature\n */\nfunction feature(geometry, properties) {\n    if (geometry === undefined) throw new Error('No geometry passed');\n\n    return {\n        type: 'Feature',\n        properties: properties || {},\n        geometry: geometry\n    };\n}\n\n/**\n * Create LineString\n *\n * @private\n * @param {Array<Array<number>>} coordinates Line Coordinates\n * @param {Object} properties Properties\n * @returns {Feature<LineString>} GeoJSON LineString Feature\n */\nfunction lineString(coordinates, properties) {\n    if (!coordinates) throw new Error('No coordinates passed');\n    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');\n\n    return {\n        type: 'Feature',\n        properties: properties || {},\n        geometry: {\n            type: 'LineString',\n            coordinates: coordinates\n        }\n    };\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} lineIndex The index of the current element being processed in the array, starts at index 0.\n * @param {number} lineSubIndex The sub-index of the current line being processed at index 0\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, lineIndex, lineSubIndex)\n * @example\n * var mtLn = turf.multiLineString([\n *   turf.lineString([[26, 37], [35, 45]]),\n *   turf.lineString([[36, 53], [38, 50], [41, 55]])\n * ]);\n *\n * turf.lineEach(mtLn, function (currentLine, lineIndex) {\n *   //=currentLine\n *   //=lineIndex\n * });\n */\nexport function lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n    var type = geojson.geometry ? geojson.geometry.type : geojson.type;\n    if (!type) throw new Error('invalid geojson');\n    if (type === 'FeatureCollection') throw new Error('FeatureCollection is not supported');\n    if (type === 'GeometryCollection') throw new Error('GeometryCollection is not supported');\n    var coordinates = geojson.geometry ? geojson.geometry.coordinates : geojson.coordinates;\n    if (!coordinates) throw new Error('geojson must contain coordinates');\n\n    switch (type) {\n    case 'LineString':\n        callback(coordinates, 0, 0);\n        return;\n    case 'Polygon':\n    case 'MultiLineString':\n        var subIndex = 0;\n        for (var line = 0; line < coordinates.length; line++) {\n            if (type === 'MultiLineString') subIndex = line;\n            callback(coordinates[line], line, subIndex);\n        }\n        return;\n    case 'MultiPolygon':\n        for (var multi = 0; multi < coordinates.length; multi++) {\n            for (var ring = 0; ring < coordinates[multi].length; ring++) {\n                callback(coordinates[multi][ring], ring, multi);\n            }\n        }\n        return;\n    default:\n        throw new Error(type + ' geometry not supported');\n    }\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} lineIndex The index of the current element being processed in the\n * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} lineSubIndex The sub-index of the current line being processed at index 0\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var mtp = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(mtp, function (previousValue, currentLine, lineIndex, lineSubIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=lineIndex\n *   //=lineSubIndex\n *   return currentLine\n * }, 2);\n */\nexport function lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, lineIndex, lineSubIndex) {\n        if (lineIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, lineIndex, lineSubIndex);\n    });\n    return previousValue;\n}\n","import rbush from './rbush';\nimport {featureEach, coordEach} from '@turf/meta';\n\n/**\n * GeoJSON implementation of [RBush](https://github.com/mourner/rbush#rbush) spatial index.\n *\n * @name rbush\n * @param {number} [maxEntries=9] defines the maximum number of entries in a tree node. 9 (used by default) is a\n * reasonable choice for most applications. Higher value means faster insertion and slower search, and vice versa.\n * @returns {RBush} GeoJSON RBush\n * @example\n * import geojsonRbush from 'geojson-rbush';\n * var tree = geojsonRbush();\n */\nfunction geojsonRbush(maxEntries) {\n    var tree = rbush(maxEntries);\n    /**\n     * [insert](https://github.com/mourner/rbush#data-format)\n     *\n     * @param {Feature<any>} feature insert single GeoJSON Feature\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.insert(polygon)\n     */\n    tree.insert = function (feature) {\n        if (Array.isArray(feature)) {\n            var bbox = feature;\n            feature = bboxPolygon(bbox);\n            feature.bbox = bbox;\n        } else {\n            feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        }\n        return rbush.prototype.insert.call(this, feature);\n    };\n\n    /**\n     * [load](https://github.com/mourner/rbush#bulk-inserting-data)\n     *\n     * @param {BBox[]|FeatureCollection<any>} features load entire GeoJSON FeatureCollection\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polygons = {\n     *   \"type\": \"FeatureCollection\",\n     *   \"features\": [\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"properties\": {},\n     *       \"geometry\": {\n     *         \"type\": \"Polygon\",\n     *         \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *       }\n     *     },\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"properties\": {},\n     *       \"geometry\": {\n     *         \"type\": \"Polygon\",\n     *         \"coordinates\": [[[-93, 32], [-83, 32], [-83, 39], [-93, 39], [-93, 32]]]\n     *       }\n     *     }\n     *   ]\n     * }\n     * tree.load(polygons)\n     */\n    tree.load = function (features) {\n        var load = [];\n        // Load an Array of BBox\n        if (Array.isArray(features)) {\n            features.forEach(function (bbox) {\n                var feature = bboxPolygon(bbox);\n                feature.bbox = bbox;\n                load.push(feature);\n            });\n        } else {\n            // Load FeatureCollection\n            featureEach(features, function (feature) {\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        }\n        return rbush.prototype.load.call(this, load);\n    };\n\n    /**\n     * [remove](https://github.com/mourner/rbush#removing-data)\n     *\n     * @param {BBox|Feature<any>} feature remove single GeoJSON Feature\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.remove(polygon)\n     */\n    tree.remove = function (feature) {\n        if (Array.isArray(feature)) {\n            var bbox = feature;\n            feature = bboxPolygon(bbox);\n            feature.bbox = bbox;\n        }\n        return rbush.prototype.remove.call(this, feature);\n    };\n\n    /**\n     * [clear](https://github.com/mourner/rbush#removing-data)\n     *\n     * @returns {RBush} GeoJSON Rbush\n     * @example\n     * tree.clear()\n     */\n    tree.clear = function () {\n        return rbush.prototype.clear.call(this);\n    };\n\n    /**\n     * [search](https://github.com/mourner/rbush#search)\n     *\n     * @param {BBox|FeatureCollection|Feature<any>} geojson search with GeoJSON\n     * @returns {FeatureCollection<any>} all features that intersects with the given GeoJSON.\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.search(polygon)\n     */\n    tree.search = function (geojson) {\n        var features = rbush.prototype.search.call(this, this.toBBox(geojson));\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    };\n\n    /**\n     * [collides](https://github.com/mourner/rbush#collisions)\n     *\n     * @param {BBox|FeatureCollection|Feature<any>} geojson collides with GeoJSON\n     * @returns {boolean} true if there are any items intersecting the given GeoJSON, otherwise false.\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.collides(polygon)\n     */\n    tree.collides = function (geojson) {\n        return rbush.prototype.collides.call(this, this.toBBox(geojson));\n    };\n\n    /**\n     * [all](https://github.com/mourner/rbush#search)\n     *\n     * @returns {FeatureCollection<any>} all the features in RBush\n     * @example\n     * tree.all()\n     * //=FeatureCollection\n     */\n    tree.all = function () {\n        var features = rbush.prototype.all.call(this);\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    };\n\n    /**\n     * [toJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @returns {any} export data as JSON object\n     * @example\n     * var exported = tree.toJSON()\n     * //=JSON object\n     */\n    tree.toJSON = function () {\n        return rbush.prototype.toJSON.call(this);\n    };\n\n    /**\n     * [fromJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @param {any} json import previously exported data\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var exported = {\n     *   \"children\": [\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"geometry\": {\n     *         \"type\": \"Point\",\n     *         \"coordinates\": [110, 50]\n     *       },\n     *       \"properties\": {},\n     *       \"bbox\": [110, 50, 110, 50]\n     *     }\n     *   ],\n     *   \"height\": 1,\n     *   \"leaf\": true,\n     *   \"minX\": 110,\n     *   \"minY\": 50,\n     *   \"maxX\": 110,\n     *   \"maxY\": 50\n     * }\n     * tree.fromJSON(exported)\n     */\n    tree.fromJSON = function (json) {\n        return rbush.prototype.fromJSON.call(this, json);\n    };\n\n    /**\n     * Converts GeoJSON to {minX, minY, maxX, maxY} schema\n     *\n     * @private\n     * @param {BBox|FeatureCollectio|Feature<any>} geojson feature(s) to retrieve BBox from\n     * @returns {Object} converted to {minX, minY, maxX, maxY}\n     */\n    tree.toBBox = function (geojson) {\n        var bbox;\n        if (geojson.bbox) bbox = geojson.bbox;\n        else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;\n        else bbox = turfBBox(geojson);\n\n        return {\n            minX: bbox[0],\n            minY: bbox[1],\n            maxX: bbox[2],\n            maxY: bbox[3]\n        };\n    };\n    return tree;\n}\n\n/**\n * Takes a bbox and returns an equivalent {@link Polygon|polygon}.\n *\n * @private\n * @name bboxPolygon\n * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order\n * @returns {Feature<Polygon>} a Polygon representation of the bounding box\n * @example\n * var bbox = [0, 0, 10, 10];\n *\n * var poly = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [poly]\n */\nfunction bboxPolygon(bbox) {\n    var lowLeft = [bbox[0], bbox[1]];\n    var topLeft = [bbox[0], bbox[3]];\n    var topRight = [bbox[2], bbox[3]];\n    var lowRight = [bbox[2], bbox[1]];\n    var coordinates = [[lowLeft, lowRight, topRight, topLeft, lowLeft]];\n\n    return {\n        type: 'Feature',\n        bbox: bbox,\n        properties: {},\n        geometry: {\n            type: 'Polygon',\n            coordinates: coordinates\n        }\n    };\n}\n\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @private\n * @name bbox\n * @param {FeatureCollection|Feature<any>} geojson input features\n * @returns {Array<number>} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction turfBBox(geojson) {\n    var bbox = [Infinity, Infinity, -Infinity, -Infinity];\n    coordEach(geojson, function (coord) {\n        if (bbox[0] > coord[0]) bbox[0] = coord[0];\n        if (bbox[1] > coord[1]) bbox[1] = coord[1];\n        if (bbox[2] < coord[0]) bbox[2] = coord[0];\n        if (bbox[3] < coord[1]) bbox[3] = coord[1];\n    });\n    return bbox;\n}\n\nexport default geojsonRbush;\n","/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325,\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nvar unitsFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000,\n    millimetres: 1000,\n    centimeters: 100,\n    centimetres: 100,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    miles: 1 / 1609.344,\n    nauticalmiles: 1 / 1852,\n    inches: 39.370,\n    yards: 1 / 1.0936,\n    feet: 3.28084,\n    radians: 1 / earthRadius,\n    degrees: 1 / 111325,\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nvar areaFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    centimeters: 10000,\n    centimetres: 10000,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox) validateBBox(bbox);\n\n    // Main\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (length === null || length === undefined) throw new Error('length is required');\n    if (!(length >= 0)) throw new Error('length must be a positive number');\n\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) throw new Error('bbox is required');\n    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n    });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) throw new Error('id is required');\n    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nfunction degrees2radians() {\n    throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nfunction distanceToDegrees() {\n    throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nfunction distanceToRadians() {\n    throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nfunction radiansToDistance() {\n    throw new Error('method has been renamed to `radiansToLength`');\n}\n\nfunction bearingToAngle() {\n    throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nfunction convertDistance() {\n    throw new Error('method has been renamed to `convertLength`');\n}\n\nexport { earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId, radians2degrees, degrees2radians, distanceToDegrees, distanceToRadians, radiansToDistance, bearingToAngle, convertDistance };\n","import { isNumber } from '@turf/helpers';\n\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(coord) {\n    if (!coord) throw new Error('coord is required');\n    if (coord.type === 'Feature' && coord.geometry !== null && coord.geometry.type === 'Point') return coord.geometry.coordinates;\n    if (coord.type === 'Point') return coord.coordinates;\n    if (Array.isArray(coord) && coord.length >= 2 && coord[0].length === undefined && coord[1].length === undefined) return coord;\n\n    throw new Error('coord must be GeoJSON Point or an Array of numbers');\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nfunction getCoords(coords) {\n    if (!coords) throw new Error('coords is required');\n\n    // Feature\n    if (coords.type === 'Feature' && coords.geometry !== null) return coords.geometry.coordinates;\n\n    // Geometry\n    if (coords.coordinates) return coords.coordinates;\n\n    // Array of numbers\n    if (Array.isArray(coords)) return coords;\n\n    throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates) {\n    if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nfunction getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\nfunction getGeomType() {\n    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nfunction getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n\nexport { getCoord, getCoords, containsNumber, geojsonType, featureOf, collectionOf, getGeom, getGeomType, getType };\n","import { feature, isObject, lineString, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    if (geomType === 'MultiPolygon') geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature$$1.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature$$1.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        if (coordEach(feature$$1, function (currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined) {\n                previousCoords = currentCoord;\n                return;\n            }\n            var currentSegment = lineString([previousCoords, currentCoord], feature$$1.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        if (feature$$1.geometry === null) return;\n        var type = feature$$1.geometry.type;\n        var coords = feature$$1.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(lineString(coords[geometryIndex], feature$$1.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexport { coordEach, coordReduce, propEach, propReduce, featureEach, featureReduce, coordAll, geomEach, geomReduce, flattenEach, flattenReduce, segmentEach, segmentReduce, lineEach, lineReduce, findSegment, findPoint };\n","import { featureCollection, lineString } from '@turf/helpers';\nimport { getCoords } from '@turf/invariant';\nimport { flattenEach } from '@turf/meta';\n\n/**\n * Creates a {@link FeatureCollection} of 2-vertex {@link LineString} segments from a {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon}.\n *\n * @name lineSegment\n * @param {Geometry|FeatureCollection|Feature<LineString|MultiLineString|MultiPolygon|Polygon>} geojson GeoJSON Polygon or LineString\n * @returns {FeatureCollection<LineString>} 2-vertex line segments\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n * var segments = turf.lineSegment(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, segments]\n */\nfunction lineSegment(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n\n    var results = [];\n    flattenEach(geojson, function (feature) {\n        lineSegmentFeature(feature, results);\n    });\n    return featureCollection(results);\n}\n\n/**\n * Line Segment\n *\n * @private\n * @param {Feature<LineString|Polygon>} geojson Line or polygon feature\n * @param {Array} results push to results\n * @returns {void}\n */\nfunction lineSegmentFeature(geojson, results) {\n    var coords = [];\n    var geometry = geojson.geometry;\n    switch (geometry.type) {\n    case 'Polygon':\n        coords = getCoords(geometry);\n        break;\n    case 'LineString':\n        coords = [getCoords(geometry)];\n    }\n    coords.forEach(function (coord) {\n        var segments = createSegments(coord, geojson.properties);\n        segments.forEach(function (segment) {\n            segment.id = results.length;\n            results.push(segment);\n        });\n    });\n}\n\n/**\n * Create Segments from LineString coordinates\n *\n * @private\n * @param {LineString} coords LineString coordinates\n * @param {*} properties GeoJSON properties\n * @returns {Array<Feature<LineString>>} line segments\n */\nfunction createSegments(coords, properties) {\n    var segments = [];\n    coords.reduce(function (previousCoords, currentCoords) {\n        var segment = lineString([previousCoords, currentCoords], properties);\n        segment.bbox = bbox(previousCoords, currentCoords);\n        segments.push(segment);\n        return currentCoords;\n    });\n    return segments;\n}\n\n/**\n * Create BBox between two coordinates (faster than @turf/bbox)\n *\n * @private\n * @param {Array<number>} coords1 Point coordinate\n * @param {Array<number>} coords2 Point coordinate\n * @returns {BBox} [west, south, east, north]\n */\nfunction bbox(coords1, coords2) {\n    var x1 = coords1[0];\n    var y1 = coords1[1];\n    var x2 = coords2[0];\n    var y2 = coords2[1];\n    var west = (x1 < x2) ? x1 : x2;\n    var south = (y1 < y2) ? y1 : y2;\n    var east = (x1 > x2) ? x1 : x2;\n    var north = (y1 > y2) ? y1 : y2;\n    return [west, south, east, north];\n}\n\nexport default lineSegment;\n","/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325,\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nvar unitsFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000,\n    millimetres: 1000,\n    centimeters: 100,\n    centimetres: 100,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    miles: 1 / 1609.344,\n    nauticalmiles: 1 / 1852,\n    inches: 39.370,\n    yards: 1 / 1.0936,\n    feet: 3.28084,\n    radians: 1 / earthRadius,\n    degrees: 1 / 111325,\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nvar areaFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    centimeters: 10000,\n    centimetres: 10000,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox) validateBBox(bbox);\n\n    // Main\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (length === null || length === undefined) throw new Error('length is required');\n    if (!(length >= 0)) throw new Error('length must be a positive number');\n\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) throw new Error('bbox is required');\n    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n    });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) throw new Error('id is required');\n    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nfunction degrees2radians() {\n    throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nfunction distanceToDegrees() {\n    throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nfunction distanceToRadians() {\n    throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nfunction radiansToDistance() {\n    throw new Error('method has been renamed to `radiansToLength`');\n}\n\nfunction bearingToAngle() {\n    throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nfunction convertDistance() {\n    throw new Error('method has been renamed to `convertLength`');\n}\n\nexport { earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId, radians2degrees, degrees2radians, distanceToDegrees, distanceToRadians, radiansToDistance, bearingToAngle, convertDistance };\n","import { isNumber } from '@turf/helpers';\n\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(coord) {\n    if (!coord) throw new Error('coord is required');\n    if (coord.type === 'Feature' && coord.geometry !== null && coord.geometry.type === 'Point') return coord.geometry.coordinates;\n    if (coord.type === 'Point') return coord.coordinates;\n    if (Array.isArray(coord) && coord.length >= 2 && coord[0].length === undefined && coord[1].length === undefined) return coord;\n\n    throw new Error('coord must be GeoJSON Point or an Array of numbers');\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nfunction getCoords(coords) {\n    if (!coords) throw new Error('coords is required');\n\n    // Feature\n    if (coords.type === 'Feature' && coords.geometry !== null) return coords.geometry.coordinates;\n\n    // Geometry\n    if (coords.coordinates) return coords.coordinates;\n\n    // Array of numbers\n    if (Array.isArray(coords)) return coords;\n\n    throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates) {\n    if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nfunction getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\nfunction getGeomType() {\n    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nfunction getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n\nexport { getCoord, getCoords, containsNumber, geojsonType, featureOf, collectionOf, getGeom, getGeomType, getType };\n","import { feature, isObject, lineString, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    if (geomType === 'MultiPolygon') geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature$$1.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature$$1.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        if (coordEach(feature$$1, function (currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined) {\n                previousCoords = currentCoord;\n                return;\n            }\n            var currentSegment = lineString([previousCoords, currentCoord], feature$$1.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        if (feature$$1.geometry === null) return;\n        var type = feature$$1.geometry.type;\n        var coords = feature$$1.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(lineString(coords[geometryIndex], feature$$1.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexport { coordEach, coordReduce, propEach, propReduce, featureEach, featureReduce, coordAll, geomEach, geomReduce, flattenEach, flattenReduce, segmentEach, segmentReduce, lineEach, lineReduce, findSegment, findPoint };\n","import rbush from 'geojson-rbush';\nimport lineSegment from '@turf/line-segment';\nimport { getCoords } from '@turf/invariant';\nimport { featureEach } from '@turf/meta';\nimport { feature, featureCollection, point } from '@turf/helpers';\n\n/**\n * Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).\n *\n * @name lineIntersect\n * @param {Geometry|FeatureCollection|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line1 any LineString or Polygon\n * @param {Geometry|FeatureCollection|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line2 any LineString or Polygon\n * @returns {FeatureCollection<Point>} point(s) that intersect both\n * @example\n * var line1 = turf.lineString([[126, -11], [129, -21]]);\n * var line2 = turf.lineString([[123, -18], [131, -14]]);\n * var intersects = turf.lineIntersect(line1, line2);\n *\n * //addToMap\n * var addToMap = [line1, line2, intersects]\n */\nfunction lineIntersect(line1, line2) {\n    var unique = {};\n    var results = [];\n\n    // First, normalize geometries to features\n    // Then, handle simple 2-vertex segments\n    if (line1.type === 'LineString') line1 = feature(line1);\n    if (line2.type === 'LineString') line2 = feature(line2);\n    if (line1.type === 'Feature' &&\n        line2.type === 'Feature' &&\n        line1.geometry.type === 'LineString' &&\n        line2.geometry.type === 'LineString' &&\n        line1.geometry.coordinates.length === 2 &&\n        line2.geometry.coordinates.length === 2) {\n        var intersect = intersects(line1, line2);\n        if (intersect) results.push(intersect);\n        return featureCollection(results);\n    }\n\n    // Handles complex GeoJSON Geometries\n    var tree = rbush();\n    tree.load(lineSegment(line2));\n    featureEach(lineSegment(line1), function (segment) {\n        featureEach(tree.search(segment), function (match) {\n            var intersect = intersects(segment, match);\n            if (intersect) {\n                // prevent duplicate points https://github.com/Turfjs/turf/issues/688\n                var key = getCoords(intersect).join(',');\n                if (!unique[key]) {\n                    unique[key] = true;\n                    results.push(intersect);\n                }\n            }\n        });\n    });\n    return featureCollection(results);\n}\n\n/**\n * Find a point that intersects LineStrings with two coordinates each\n *\n * @private\n * @param {Feature<LineString>} line1 GeoJSON LineString (Must only contain 2 coordinates)\n * @param {Feature<LineString>} line2 GeoJSON LineString (Must only contain 2 coordinates)\n * @returns {Feature<Point>} intersecting GeoJSON Point\n */\nfunction intersects(line1, line2) {\n    var coords1 = getCoords(line1);\n    var coords2 = getCoords(line2);\n    if (coords1.length !== 2) {\n        throw new Error('<intersects> line1 must only contain 2 coordinates');\n    }\n    if (coords2.length !== 2) {\n        throw new Error('<intersects> line2 must only contain 2 coordinates');\n    }\n    var x1 = coords1[0][0];\n    var y1 = coords1[0][1];\n    var x2 = coords1[1][0];\n    var y2 = coords1[1][1];\n    var x3 = coords2[0][0];\n    var y3 = coords2[0][1];\n    var x4 = coords2[1][0];\n    var y4 = coords2[1][1];\n    var denom = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));\n    var numeA = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3));\n    var numeB = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3));\n\n    if (denom === 0) {\n        if (numeA === 0 && numeB === 0) {\n            return null;\n        }\n        return null;\n    }\n\n    var uA = numeA / denom;\n    var uB = numeB / denom;\n\n    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n        var x = x1 + (uA * (x2 - x1));\n        var y = y1 + (uA * (y2 - y1));\n        return point([x, y]);\n    }\n    return null;\n}\n\nexport default lineIntersect;\n","import bearing from '@turf/bearing';\nimport distance from '@turf/distance';\nimport destination from '@turf/destination';\nimport lineIntersects from '@turf/line-intersect';\nimport { flattenEach } from '@turf/meta';\nimport { point, lineString } from '@turf/helpers';\nimport { getCoords } from '@turf/invariant';\n\n/**\n * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the (Multi)LineString.\n *\n * @name pointOnLine\n * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to\n * @param {Geometry|Feature<Point>|number[]} pt point to snap from\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain three values: `index`: closest point was found on nth line part, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.\n * @example\n * var line = turf.lineString([\n *     [-77.031669, 38.878605],\n *     [-77.029609, 38.881946],\n *     [-77.020339, 38.884084],\n *     [-77.025661, 38.885821],\n *     [-77.021884, 38.889563],\n *     [-77.019824, 38.892368]\n * ]);\n * var pt = turf.point([-77.037076, 38.884017]);\n *\n * var snapped = turf.pointOnLine(line, pt, 'miles');\n *\n * //addToMap\n * var addToMap = [line, pt, snapped];\n * snapped.properties['marker-color'] = '#00f';\n */\nfunction pointOnLine(lines, pt, options) {\n    // Backwards compatible with v4.0\n    var units = (typeof options === 'object') ? options.units : options;\n\n    // validation\n    var type = (lines.geometry) ? lines.geometry.type : lines.type;\n    if (type !== 'LineString' && type !== 'MultiLineString') {\n        throw new Error('lines must be LineString or MultiLineString');\n    }\n\n    var closestPt = point([Infinity, Infinity], {\n        dist: Infinity\n    });\n\n    var length = 0.0;\n    flattenEach(lines, function (line) {\n        var coords = getCoords(line);\n\n        for (var i = 0; i < coords.length - 1; i++) {\n            //start\n            var start = point(coords[i]);\n            start.properties.dist = distance(pt, start, units);\n            //stop\n            var stop = point(coords[i + 1]);\n            stop.properties.dist = distance(pt, stop, units);\n            // sectionLength\n            var sectionLength = distance(start, stop, units);\n            //perpendicular\n            var heightDistance = Math.max(start.properties.dist, stop.properties.dist);\n            var direction = bearing(start, stop);\n            var perpendicularPt1 = destination(pt, heightDistance, direction + 90, units);\n            var perpendicularPt2 = destination(pt, heightDistance, direction - 90, units);\n            var intersect = lineIntersects(lineString([perpendicularPt1.geometry.coordinates, perpendicularPt2.geometry.coordinates]), lineString([start.geometry.coordinates, stop.geometry.coordinates]));\n            var intersectPt = null;\n            if (intersect.features.length > 0) {\n                intersectPt = intersect.features[0];\n                intersectPt.properties.dist = distance(pt, intersectPt, units);\n                intersectPt.properties.location = length + distance(start, intersectPt, units);\n            }\n\n            if (start.properties.dist < closestPt.properties.dist) {\n                closestPt = start;\n                closestPt.properties.index = i;\n                closestPt.properties.location = length;\n            }\n            if (stop.properties.dist < closestPt.properties.dist) {\n                closestPt = stop;\n                closestPt.properties.index = i + 1;\n                closestPt.properties.location = length + sectionLength;\n            }\n            if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {\n                closestPt = intersectPt;\n                closestPt.properties.index = i;\n            }\n            // update length\n            length += sectionLength;\n        }\n\n    });\n\n    return closestPt;\n}\n\nexport default pointOnLine;\n","/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325,\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nvar unitsFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000,\n    millimetres: 1000,\n    centimeters: 100,\n    centimetres: 100,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    miles: 1 / 1609.344,\n    nauticalmiles: 1 / 1852,\n    inches: 39.370,\n    yards: 1 / 1.0936,\n    feet: 3.28084,\n    radians: 1 / earthRadius,\n    degrees: 1 / 111325,\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nvar areaFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    centimeters: 10000,\n    centimetres: 10000,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox) validateBBox(bbox);\n\n    // Main\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (length === null || length === undefined) throw new Error('length is required');\n    if (!(length >= 0)) throw new Error('length must be a positive number');\n\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) throw new Error('bbox is required');\n    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n    });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) throw new Error('id is required');\n    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nfunction degrees2radians() {\n    throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nfunction distanceToDegrees() {\n    throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nfunction distanceToRadians() {\n    throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nfunction radiansToDistance() {\n    throw new Error('method has been renamed to `radiansToLength`');\n}\n\nfunction bearingToAngle() {\n    throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nfunction convertDistance() {\n    throw new Error('method has been renamed to `convertLength`');\n}\n\nexport { earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId, radians2degrees, degrees2radians, distanceToDegrees, distanceToRadians, radiansToDistance, bearingToAngle, convertDistance };\n","import { isNumber } from '@turf/helpers';\n\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(coord) {\n    if (!coord) throw new Error('coord is required');\n    if (coord.type === 'Feature' && coord.geometry !== null && coord.geometry.type === 'Point') return coord.geometry.coordinates;\n    if (coord.type === 'Point') return coord.coordinates;\n    if (Array.isArray(coord) && coord.length >= 2 && coord[0].length === undefined && coord[1].length === undefined) return coord;\n\n    throw new Error('coord must be GeoJSON Point or an Array of numbers');\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nfunction getCoords(coords) {\n    if (!coords) throw new Error('coords is required');\n\n    // Feature\n    if (coords.type === 'Feature' && coords.geometry !== null) return coords.geometry.coordinates;\n\n    // Geometry\n    if (coords.coordinates) return coords.coordinates;\n\n    // Array of numbers\n    if (Array.isArray(coords)) return coords;\n\n    throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates) {\n    if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nfunction getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\nfunction getGeomType() {\n    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nfunction getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n\nexport { getCoord, getCoords, containsNumber, geojsonType, featureOf, collectionOf, getGeom, getGeomType, getType };\n","import { getCoord } from '@turf/invariant';\nimport { degreesToRadians, isObject, radiansToLength } from '@turf/helpers';\n\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians,\n * miles, or kilometers. This uses the\n * [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula)\n * to account for global curvature.\n *\n * @name distance\n * @param {Coord} from origin point\n * @param {Coord} to destination point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.distance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var units = options.units;\n\n    var coordinates1 = getCoord(from);\n    var coordinates2 = getCoord(to);\n    var dLat = degreesToRadians((coordinates2[1] - coordinates1[1]));\n    var dLon = degreesToRadians((coordinates2[0] - coordinates1[0]));\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n          Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n\n    return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), units);\n}\n\nexport default distance;\n","import logger from 'loglevel';\nimport pointOnLine from '@turf/point-on-line';\nimport distance from '@turf/distance/';\nimport { point } from '@turf/helpers';\nimport * as _ from './lodash';\n\n\nconst turf = {\n    pointOnLine,\n    distance,\n    point,\n};\n\n\nconst CONSTS = {\n    START_INDEX: 0,\n    FIRST_STATION_INDEX: 1,\n    LAST_STATION_INDEX: 14,\n    END_INDEX: 15,\n};\n\n\nexport default class Stations {\n    constructor(points, lineString) {\n        this.points = points;\n        this.path = lineString;\n        this.pathReversed = false;\n        this.pathCircular = false;\n        this.pathStart = turf.point(this.path.geometry.coordinates[0]);\n        this.pathEnd = turf\n            .point(this.path.geometry.coordinates[this.path.geometry.coordinates.length - 1]);\n\n        this._sortPoints();\n        this._addIndexes();\n        this._updateCircularity();\n        if (!this.pathCircular) {\n            this._updateDirection();\n        }\n    }\n\n\n    _sortPoints() {\n        const path = this.path;\n        const enhancedPoints = _.map(this.points, point => {\n            point.properties.nearestOnLine = turf.pointOnLine(path, point, 'meters');\n            return point;\n        });\n\n        const sortedPoints = _.sortBy(enhancedPoints,\n            point => point.properties.nearestOnLine.properties.location);\n\n        this.points = sortedPoints;\n    }\n\n    _addIndexes() {\n        const getIndex = str => {\n            /** Regular expressions for extracting station number\n             *  from a given string (which might be represented by different types\n             *  of numbers and different delimiters)\n             */\n            const START_NAMES_REGEX = /^(wstęp|wprowadzenie|początek|start)$/ig;\n            const END_NAMES_REGEX = /^(zakończenie|koniec|podsumowanie)$/ig;\n            const ROMAN_NUMBERS_REGEX = /^(I|II|III|IV|V|VI|VII|VIII|IX|X|XI|XII|XIII|XIV)$/g;\n            const EUROPEAN_NUMBERS_REGEX = /^\\d+$/g;\n            const SPLITTER_REGEX = /[ ,\\._\\-:;]+/;\n            const ROMAN_EUROPEAN_MAP = {\n                I: 1,\n                II: 2,\n                III: 3,\n                IV: 4,\n                V: 5,\n                VI: 6,\n                VII: 7,\n                VIII: 8,\n                IX: 9,\n                X: 10,\n                XI: 11,\n                XII: 12,\n                XIII: 13,\n                XIV: 14,\n            };\n\n            let index = null;\n\n            logger.debug(`Checking station index for string: ${str}`);\n\n            // noname station\n            if (!str) {\n                return index;\n            }\n\n            // split\n            const parts = str.trim().split(SPLITTER_REGEX);\n\n            _.forEach(parts, part => {\n                // try roman numbers\n                // it isn't clear why there are for matches declaration\n                let matches = part.match(ROMAN_NUMBERS_REGEX);\n                if (!_.isNull(matches)) {\n                    index = ROMAN_EUROPEAN_MAP[matches[0]];\n                    return false;\n                }\n\n                // try european numbers\n                matches = part.match(EUROPEAN_NUMBERS_REGEX);\n                if (!_.isNull(matches)) {\n                    const stationNumber = parseInt(matches[0]);\n                    if (stationNumber >= CONSTS.FIRST_STATION_INDEX &&\n                        stationNumber <= CONSTS.LAST_STATION_INDEX) {\n                        index = stationNumber;\n                        return false;\n                    }\n                    return true;\n                }\n\n                // try start names\n                matches = part.match(START_NAMES_REGEX);\n                if (!_.isNull(matches)) {\n                    index = CONSTS.START_INDEX;\n                    return false;\n                }\n\n                // try end names\n                matches = part.match(END_NAMES_REGEX);\n                if (!_.isNull(matches)) {\n                    index = CONSTS.END_INDEX;\n                    return false;\n                }\n            });\n\n            return index;\n        };\n\n        this.points = _.map(this.points, point => {\n            const name = point.properties.name;\n            const number = getIndex(name);\n\n            point.properties.index = number;\n            return point;\n        });\n    }\n\n    _updateDirection() {\n        const pathReversed = false;\n\n        const startPoint = _.filter(this.points,\n            point => point.properties.index === CONSTS.START_INDEX);\n        const endPoint = _.filter(this.points,\n            point => point.properties.index === CONSTS.END_INDEX);\n        const options = { units: 'kilometers' };\n\n        if (!_.isEmpty(startPoint)) {\n            logger.debug('Start point detected. Checking if it is closer to path start or path end...');\n            const startPointToPathStartDistance = turf.distance(this.pathStart,\n                startPoint[0], options);\n            const startPointToPathEndDistance = turf.distance(this.pathEnd, startPoint[0], options);\n            if (startPointToPathStartDistance > startPointToPathEndDistance) {\n                logger.debug('Reversed path detected. Start point is closer to path end.');\n                this.pathReversed = true;\n            }\n        } else if (!_.isEmpty(endPoint)) {\n            logger.debug('End point detected. Checking if it is closer to path start or path end...');\n            const endPointToPathStartDistance = turf.distance(this.pathStart, endPoint[0], options);\n            const endPointToPathEndDistance = turf.distance(this.pathEnd, endPoint[0], options);\n            if (endPointToPathEndDistance > endPointToPathStartDistance) {\n                logger.debug('Reversed path detected. Start point is closer to path end.');\n                this.pathReversed = true;\n            }\n        }\n        if (this.pathReversed) {\n            logger.debug('Reversing points.');\n            this.points = this.points.reverse();\n        }\n    }\n\n    _updateCircularity() {\n        const MAXIMUM_DISTANCE_START_END_IN_CIRCULAR_PATH = 500; // meters\n        const options = { units: 'kilometers' };\n\n        let distance = turf.distance(this.pathStart, this.pathEnd, options);\n        distance *= 1000;\n\n        if (distance <= MAXIMUM_DISTANCE_START_END_IN_CIRCULAR_PATH) {\n            logger.debug('Circular path detected. Distance between path start and end points:', distance.toFixed(2), 'meters.');\n            this.pathCircular = true;\n        }\n    }\n\n    getCount() {\n        let numberOfStations = 0;\n        for (let stationNumber = CONSTS.FIRST_STATION_INDEX;\n            stationNumber <= CONSTS.LAST_STATION_INDEX; stationNumber++) {\n            let firstStationName = '';\n            const stationsOfNumber = _.filter(this.points, station => {\n                if (station.properties.index === stationNumber) {\n                    firstStationName = station.properties.name;\n                    return true;\n                }\n                return false;\n            });\n            if (stationsOfNumber.length !== 1) {\n                logger.warn(`Station ${stationNumber} found ${stationsOfNumber.length} times.`);\n            } else {\n                logger.debug(`Station ${stationNumber} found. Station name: ${firstStationName}`);\n                numberOfStations++;\n            }\n        }\n        return numberOfStations;\n    }\n\n    isOrderCorrect() {\n        let result = true;\n        for (let i = 1; i < this.points.length; i++) {\n            const currentStationNumber = this.points[i].properties.index;\n            const previousStationNumber = this.points[i - 1].properties.index;\n            logger.debug(`Point ${i - 1}`);\n            if (currentStationNumber === null) {\n                logger.debug(`Not checking order for unrecognized point: ${this.points[i].properties.name}`);\n            } else if (previousStationNumber === null) {\n                logger.debug(`Not checking order for unrecognized point: ${this.points[i - 1].properties.name}`);\n            } else if (this.pathCircular &&\n                (\n                    (previousStationNumber === CONSTS.FIRST_STATION_INDEX &&\n                    currentStationNumber === CONSTS.LAST_STATION_INDEX) ||\n                    (currentStationNumber === CONSTS.FIRST_STATION_INDEX &&\n                    previousStationNumber === CONSTS.LAST_STATION_INDEX)\n                )\n            ) {\n                logger.debug('Not checking order for station', CONSTS.FIRST_STATION_INDEX, 'and', CONSTS.LAST_STATION_INDEX, 'when route is circular.');\n            } else if (currentStationNumber <= previousStationNumber) {\n                logger.warn(`Detected invalid order of stations. Station ${currentStationNumber} is after station ${previousStationNumber}.`);\n                result = false;\n            } else {\n                logger.debug(`Station ${currentStationNumber} is after station ${previousStationNumber}.`);\n            }\n        }\n        return result;\n    }\n\n    areAllOnThePath(maximumDistanceFromPath) {\n        let result = true;\n\n        _.forEach(this.points, (station, index) => {\n            const stationNumber = station.properties.index;\n            const distanceFromStationToPath = station.properties.nearestOnLine.properties.dist;\n            logger.debug(`Point ${index}`);\n            if (stationNumber === null) {\n                logger.debug(`Not checking distance for: ${station.properties.name}`);\n            } else if (distanceFromStationToPath > maximumDistanceFromPath) {\n                logger.warn(`Station ${stationNumber} is too far from path. Expected maximum distance from path: ${maximumDistanceFromPath} meter(s).`);\n                result = false;\n            } else {\n                logger.debug(`Station ${stationNumber} is on the path.`);\n            }\n        });\n\n        return result;\n    }\n\n    isPathReversed() {\n        return this.pathReversed;\n    }\n}\n\n","import logger from 'loglevel';\nimport * as _ from './lodash';\nimport helpers from './helpers';\nimport PathElevation from './PathElevation';\nimport Stations from './Stations';\n\n// Constants\nconst EXPECTED_NUMBER_OF_PATHS = 1;\nconst EXPECTED_NUMBER_OF_STATIONS = 14;\nconst MAXIMUM_DISTANCE_FROM_STATION_TO_PATH = 100; // meters\n\n\nexport default class Route {\n    constructor(geoJson) {\n        this.geoJson = geoJson;\n        this.lineString = helpers.getLineString(this.geoJson);\n        this.points = helpers.getPoints(this.geoJson);\n        this.isRouteVerifiable = true;\n\n        if (_.isEmpty(this.lineString)) {\n            logger.error('No line string in route.');\n            this.isRouteVerifiable = false;\n        }\n        if (_.isEmpty(this.points)) {\n            logger.error('No points in route.');\n            this.isRouteVerifiable = false;\n        }\n        if (this.isRouteVerifiable) {\n            this.stations = new Stations(this.points, this.lineString);\n            this.path = this.stations.isPathReversed()\n                ? helpers.reverseLineString(this.lineString)\n                : this.lineString;\n            this.numberOfPaths = helpers.getNumberOfFeatures('LineString', this.geoJson);\n        }\n    }\n\n\n    isVerifiable() {\n        return this.isRouteVerifiable;\n    }\n\n    isSinglePath() {\n        const result = _.isEqual(this.numberOfPaths, EXPECTED_NUMBER_OF_PATHS);\n        if (!result) {\n            logger.warn('No single path defined.');\n        }\n        logger.debug('isSinglePath:', result, ', numberOfPaths:', this.numberOfPaths);\n        return result;\n    }\n\n    areAllStationsPresent() {\n        const numberOfStations = this.stations.getCount();\n        const result = _.isEqual(numberOfStations, EXPECTED_NUMBER_OF_STATIONS);\n        logger.debug('areAllStationsPresent:', result, ', numberOfStations:', numberOfStations);\n        return result;\n    }\n\n    areStationsOnThePath() {\n        const result = this.stations.areAllOnThePath(MAXIMUM_DISTANCE_FROM_STATION_TO_PATH);\n        logger.debug('areStationsOnThePath:', result);\n        return result;\n    }\n\n    isStationOrderCorrect() {\n        const result = this.stations.isOrderCorrect();\n        logger.debug('isStationOrderCorrect:', result);\n        return result;\n    }\n\n    getPathLength() {\n        let result = 0;\n\n        const googleMapsPath = helpers.getGoogleMapsPath(this.path);\n        result = google.maps.geometry.spherical.computeLength(googleMapsPath);\n        result /= 1000;\n\n        logger.debug('getPathLength [km]:', result);\n        return result;\n    }\n\n    fetchPathElevationData() {\n        return helpers.getPathElevations(this.path)\n            .then(elevations => {\n                logger.debug('Path elevations:', elevations);\n                this.pathElevation = new PathElevation(elevations);\n                return this.pathElevation;\n            })\n            .catch(error => {\n                throw new Error(error);\n            });\n    }\n\n\n    getPathElevation() {\n        logger.debug('getPathElevation:', this.pathElevation);\n        return this.pathElevation;\n    }\n}\n\n","\nexport default function () {\n    this.routeUrl = $('div#map-canvas').attr('data-what');\n    this.routeParamsUrl = $('div#map-canvas').attr('data-route-params');\n    this.routeApproveUrl = $('div#map-canvas').attr('data-route-approve');\n}\n\n","import logger from 'loglevel';\nimport * as _ from './lodash';\n\n// Constants\nconst ROUTE_TYPE_ID = 'div#routeType';\nconst SINGLE_PATH_ID = 'div#singlePath';\nconst PATH_LENGTH_ID = 'div#pathLength';\nconst ELEVATION_GAIN_ID = 'div#elevationGain';\nconst ELEVATION_LOSS_ID = 'div#elevationLoss';\nconst ELEVATION_TOTAL_CHANGE_ID = 'div#elevationTotalChange';\nconst NUMBER_OF_STATIONS_ID = 'div#numberOfStations';\nconst STATIONS_ORDER_ID = 'div#stationsOrder';\nconst STATIONS_ON_PATH_ID = 'div#stationsOnPath';\nconst DATA_CONSISTENCY_ID = 'div#dataConsistency';\nconst ELEVATION_CHART_ID = 'canvas#elevationChart';\nconst VERIFY_BUTTON_ID = 'button#verifyRoute';\nconst LOADER_ID = 'div#loader';\nconst LOADER_ELEMENT = '<div id=\"loader\" class=\"overlay\"><i class=\"fa fa-refresh fa-spin\"></i></div>';\nconst ELEVATION_CHART_ELEMENT = '<canvas id=\"elevationChart\"></canvas>';\n\n\nconst updateControlColor = (element, isValid) => {\n    const VALID_COLOR_CLASS = 'bg-green';\n    const INVALID_COLOR_CLASS = 'bg-yellow';\n    const INFO_BOX_ICON = 'span.info-box-icon';\n\n    if (_.isNull(isValid)) {\n        $(`${element} ${INFO_BOX_ICON}`).removeClass([INVALID_COLOR_CLASS, VALID_COLOR_CLASS].join(' '));\n    } else {\n        (isValid)\n            ? $(`${element} ${INFO_BOX_ICON}`).removeClass(INVALID_COLOR_CLASS).addClass(VALID_COLOR_CLASS)\n            : $(`${element} ${INFO_BOX_ICON}`).removeClass(VALID_COLOR_CLASS).addClass(INVALID_COLOR_CLASS);\n    }\n};\n\nconst updateControlValue = (element, value, unit) => {\n    const INFO_BOX_NUMBER = 'span.info-box-number';\n\n    logger.debug('Updating control element', element, 'with:', value, unit);\n    $(`${element} ${INFO_BOX_NUMBER}`).html(`${value} ${unit ? `<small>${unit}</small>` : ''}`);\n};\n\nconst removeControlChildren = element => {\n    $(ELEVATION_CHART_ID).empty();\n};\n\n\nexport default class Controls {\n    // Constructor\n\n\n    updateRouteType(isNormalRoute) {\n        const normalRouteString = $('input#normalRouteString').attr('value');\n        const inspiredRouteString = $('input#inspiredRouteString').attr('value');\n        updateControlValue(ROUTE_TYPE_ID, isNormalRoute ? normalRouteString : inspiredRouteString);\n    }\n\n    updatePathLength(isLengthValid, length) {\n        updateControlValue(PATH_LENGTH_ID, length.toFixed(2), 'km');\n        updateControlColor(PATH_LENGTH_ID, isLengthValid);\n    }\n\n    updateElevationGain(isElevationGainValid, elevationGain) {\n        updateControlValue(ELEVATION_GAIN_ID, elevationGain.toFixed(2), 'm');\n        updateControlColor(ELEVATION_GAIN_ID, isElevationGainValid);\n    }\n\n    updateElevationLoss(isElevationLossValid, elevationLoss) {\n        updateControlValue(ELEVATION_LOSS_ID, elevationLoss.toFixed(2), 'm');\n        updateControlColor(ELEVATION_LOSS_ID, isElevationLossValid);\n    }\n\n    updateElevationTotalChange(isElevationTotalChangeValid, elevationTotalChange) {\n        updateControlValue(ELEVATION_TOTAL_CHANGE_ID, elevationTotalChange.toFixed(2), 'm');\n        updateControlColor(ELEVATION_TOTAL_CHANGE_ID, isElevationTotalChangeValid);\n    }\n\n    updateNumberOfStations(areAllStationsPresent) {\n        updateControlColor(NUMBER_OF_STATIONS_ID, areAllStationsPresent);\n    }\n\n    updateStationsOrder(isStationOrderCorrect) {\n        updateControlColor(STATIONS_ORDER_ID, isStationOrderCorrect);\n    }\n\n    updateStationsOnPath(areAllStationsOnPath) {\n        updateControlColor(STATIONS_ON_PATH_ID, areAllStationsOnPath);\n    }\n\n    updateSinglePath(isSinglePath) {\n        updateControlColor(SINGLE_PATH_ID, isSinglePath);\n    }\n\n    updateDataConsistency(isDataConsistent) {\n        updateControlColor(DATA_CONSISTENCY_ID, isDataConsistent);\n    }\n\n    drawElevationChart(pathElevation) {\n        const X_AXIS_NUMBER_OF_LABELS = 10;\n        const X_AXIS_LABEL_STRING = '[km]';\n        const Y_AXIS_LABEL_STRING = '[m]';\n        const CHART_BACKGROUND_COLOR = 'rgb(32, 77, 116)';\n\n        const labelWidth = parseInt(pathElevation.data.length / X_AXIS_NUMBER_OF_LABELS);\n        const labels = _.map(pathElevation.data, elevation => elevation.distance.toFixed());\n        const data = _.map(pathElevation.data, elevation => elevation.elevation);\n\n        logger.debug('Drawing elevation chart. Input:', pathElevation);\n\n        const elevationChart = new Chart($(ELEVATION_CHART_ID), {\n            type: 'line',\n            data: {\n                labels,\n                datasets: [{\n                    label: '',\n                    data,\n                    fill: 'start',\n                    radius: 0,\n                    backgroundColor: CHART_BACKGROUND_COLOR,\n                }],\n            },\n            options: {\n                scales: {\n                    xAxes: [{\n                        scaleLabel: {\n                            display: true,\n                            labelString: X_AXIS_LABEL_STRING,\n                        },\n                        ticks: {\n                            /* eslint no-unused-expressions:0 */\n                            callback: (dataLabel, index) => {\n                                (index % labelWidth === 0\n                                ||\n                                (index === pathElevation.data.length - 1) ? dataLabel : null);\n                            },\n                        },\n                    }],\n                    yAxes: [{\n                        scaleLabel: {\n                            display: true,\n                            labelString: Y_AXIS_LABEL_STRING,\n                        },\n                    }],\n                },\n                legend: {\n                    display: false,\n                },\n                tooltips: {\n                    enabled: false,\n                },\n            },\n        });\n    }\n\n    resetElevationChart() {\n        const elevationChartParentElement = $(ELEVATION_CHART_ID).parent();\n        $(ELEVATION_CHART_ID).remove();\n        elevationChartParentElement.append(ELEVATION_CHART_ELEMENT);\n    }\n\n    addLoaderToButton() {\n        $(VERIFY_BUTTON_ID).append(LOADER_ELEMENT);\n    }\n\n    removeLoaderFromButton() {\n        $(`${VERIFY_BUTTON_ID} ${LOADER_ID}`).remove();\n    }\n\n    resetAll(value) {\n        const text = '';\n        const isValid = value === undefined ? null : value;\n\n        updateControlValue(ROUTE_TYPE_ID, text);\n        updateControlValue(PATH_LENGTH_ID, text);\n        updateControlColor(PATH_LENGTH_ID, isValid);\n        updateControlValue(ELEVATION_GAIN_ID, text);\n        updateControlColor(ELEVATION_GAIN_ID, isValid);\n        updateControlValue(ELEVATION_LOSS_ID, text);\n        updateControlColor(ELEVATION_LOSS_ID, isValid);\n        updateControlValue(ELEVATION_TOTAL_CHANGE_ID, text);\n        updateControlColor(ELEVATION_TOTAL_CHANGE_ID, isValid);\n        updateControlColor(NUMBER_OF_STATIONS_ID, isValid);\n        updateControlColor(STATIONS_ORDER_ID, isValid);\n        updateControlColor(STATIONS_ON_PATH_ID, isValid);\n        updateControlColor(SINGLE_PATH_ID, isValid);\n        updateControlColor(DATA_CONSISTENCY_ID, isValid);\n        this.resetElevationChart();\n    }\n}\n\n","import logger from 'loglevel';\nimport helpers from './helpers';\nimport Route from './Route';\nimport Context from './Context';\nimport Controls from './Controls';\n\n\n// Constants\nconst NORMAL_ROUTE_MIN_LENGTH = 40; // kilometers\nconst SHORT_NORMAL_ROUTE_MIN_LENGTH = 30; // kilometers\nconst SHORT_NORMAL_ROUTE_MIN_ELEVATION_GAIN = 500; // meters\n\n\nfunction verifyRoute() {\n    if (!window.google || !window.google.maps) {\n        logger.error('Google Maps API is not loaded.');\n        return;\n    }\n    const context = new Context();\n    const controls = new Controls();\n\n    controls.resetAll();\n    controls.addLoaderToButton();\n\n    helpers.getRoute(context.routeUrl)\n        .done(data => {\n            const geoJson = helpers.getGeoJSON(data);\n            const route = new Route(geoJson);\n\n            if (!route.isVerifiable()) {\n                logger.error('Route is unverifiable.');\n                controls.resetAll(false);\n                return;\n            }\n\n            // Path basic checks\n            const isSinglePath = route.isSinglePath();\n            controls.updateSinglePath(isSinglePath);\n\n            const routeLength = route.getPathLength();\n\n            const isPathLengthValid = true;\n            controls.updatePathLength(isPathLengthValid, routeLength);\n\n            // Station checks\n            const areAllStationsPresent = route.areAllStationsPresent();\n            controls.updateNumberOfStations(areAllStationsPresent);\n            const isStationOrderCorrect = route.isStationOrderCorrect();\n            controls.updateStationsOrder(isStationOrderCorrect);\n            const areStationsOnThePath = route.areStationsOnThePath();\n            controls.updateStationsOnPath(areStationsOnThePath);\n\n            // Elevation checks\n            route.fetchPathElevationData()\n                .then(() => {\n                    const pathElevation = route.getPathElevation();\n                    pathElevation.enrichData(routeLength);\n\n                    const isPathElevationGainValid = true;\n                    controls.updateElevationGain(isPathElevationGainValid, pathElevation.gain);\n\n                    const isNormalRoute = routeLength >= NORMAL_ROUTE_MIN_LENGTH ||\n                        pathElevation.gain > SHORT_NORMAL_ROUTE_MIN_ELEVATION_GAIN\n                        && routeLength >= SHORT_NORMAL_ROUTE_MIN_LENGTH;\n                    controls.updateRouteType(isNormalRoute);\n\n                    const isPathElevationLossValid = true;\n                    controls.updateElevationLoss(isPathElevationLossValid, pathElevation.loss);\n\n                    const isPathElevationTotalChangeValid = true;\n                    controls.updateElevationTotalChange(isPathElevationTotalChangeValid,\n                        pathElevation.totalChange);\n\n                    controls.drawElevationChart(pathElevation);\n\n                    helpers.getRouteParameters(context.routeParamsUrl)\n                        .then(parameters => {\n                            const ACCEPTED_ROUTE_LENGTH_DIFF = 1; // km\n                            const ACCEPTED_ELEVATION_GAIN_DIFF = 50; // m\n                            const NORMAL_ROUTE_TYPE = 0;\n                            const INSPIRED_ROUTE_TYPE = 1;\n                            /* eslint-disable max-len */\n                            const isLengthConsistent = (routeLength - ACCEPTED_ROUTE_LENGTH_DIFF <= parameters.length &&\n                                parameters.length <= routeLength + ACCEPTED_ROUTE_LENGTH_DIFF);\n                            const isElevationGainConsistent = (pathElevation.gain - ACCEPTED_ELEVATION_GAIN_DIFF <= parameters.ascent &&\n                                parameters.ascent <= pathElevation.gain + ACCEPTED_ELEVATION_GAIN_DIFF);\n                            const isRouteTypeConsistent = parameters.type === (isNormalRoute ? NORMAL_ROUTE_TYPE : INSPIRED_ROUTE_TYPE);\n                            const isDataConsistent = isLengthConsistent && isElevationGainConsistent && isRouteTypeConsistent;\n                            /* eslint-enable max-len */\n                            logger.debug('isLengthConsistent:', isLengthConsistent,\n                                ', isElevationGainConsistent:', isElevationGainConsistent,\n                                ', isRouteTypeConsistent:', isRouteTypeConsistent);\n                            controls.updateDataConsistency(isDataConsistent);\n\n                            const canRouteBeAutomaticallyApproved =\n                                isSinglePath && isPathLengthValid &&\n                                areAllStationsPresent && isStationOrderCorrect &&\n                                areStationsOnThePath && isPathElevationGainValid &&\n                                isPathElevationLossValid && isPathElevationTotalChangeValid &&\n                                isDataConsistent;\n\n                            if (canRouteBeAutomaticallyApproved) {\n                                logger.info('Route verification success. Approving...');\n                                helpers.approveRoute(context.routeApproveUrl)\n                                    .then(() => {\n                                        logger.info('Route approved.');\n                                        const reloadTimeout = setTimeout(() => {\n                                            window.location.reload(1);\n                                        }, 5000);\n                                        $('div#pageReloadModal').on('hide.bs.modal', e => {\n                                            clearTimeout(reloadTimeout);\n                                        });\n                                        $('div#pageReloadModal').modal();\n                                    })\n                                    .catch(error => {\n                                        logger.error('Route approval error.', error);\n                                    });\n                            } else {\n                                logger.info('Route verification failed. Cannot be approved.');\n                            }\n                        })\n                        .catch(error => {\n                            logger.error('Route parameters data fetching error.', error);\n                        });\n                })\n                .catch(error => {\n                    logger.error('Path elevation data fetching error.', error);\n                    controls.updateElevationGain(false, 0);\n                    controls.updateElevationLoss(false, 0);\n                    controls.updateElevationTotalChange(false, 0);\n                    controls.updateDataConsistency(false);\n                });\n        }).fail((xhr, status) => {\n            logger.error('Route fetching error. Status:', status);\n        }).always(() => {\n            controls.removeLoaderFromButton();\n        });\n}\n\nif (process.env.NODE_ENV === 'production') {\n    logger.setLevel('warn');\n} else {\n    logger.setLevel('debug');\n}\nwindow.setLogLevel = (logLevel = 'debug') => logger.setLevel(logLevel);\n\n$('button#verifyRoute').bind('click', verifyRoute);\n","var eq = require('./eq'),\n    isArrayLike = require('./isArrayLike'),\n    isIndex = require('./_isIndex'),\n    isObject = require('./isObject');\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\nmodule.exports = isIterateeCall;\n","/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeNow = Date.now;\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\nmodule.exports = shortOut;\n","var getNative = require('./_getNative');\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nmodule.exports = defineProperty;\n","/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\nmodule.exports = constant;\n","var constant = require('./constant'),\n    defineProperty = require('./_defineProperty'),\n    identity = require('./identity');\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\nmodule.exports = baseSetToString;\n","var baseSetToString = require('./_baseSetToString'),\n    shortOut = require('./_shortOut');\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\nmodule.exports = setToString;\n","/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\nmodule.exports = apply;\n","var apply = require('./_apply');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\nmodule.exports = overRest;\n","var identity = require('./identity'),\n    overRest = require('./_overRest'),\n    setToString = require('./_setToString');\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\nmodule.exports = baseRest;\n","var isSymbol = require('./isSymbol');\n\n/**\n * Compares values to sort them in ascending order.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {number} Returns the sort order indicator for `value`.\n */\nfunction compareAscending(value, other) {\n  if (value !== other) {\n    var valIsDefined = value !== undefined,\n        valIsNull = value === null,\n        valIsReflexive = value === value,\n        valIsSymbol = isSymbol(value);\n\n    var othIsDefined = other !== undefined,\n        othIsNull = other === null,\n        othIsReflexive = other === other,\n        othIsSymbol = isSymbol(other);\n\n    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n        (valIsNull && othIsDefined && othIsReflexive) ||\n        (!valIsDefined && othIsReflexive) ||\n        !valIsReflexive) {\n      return 1;\n    }\n    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n        (othIsNull && valIsDefined && valIsReflexive) ||\n        (!othIsDefined && valIsReflexive) ||\n        !othIsReflexive) {\n      return -1;\n    }\n  }\n  return 0;\n}\n\nmodule.exports = compareAscending;\n","var compareAscending = require('./_compareAscending');\n\n/**\n * Used by `_.orderBy` to compare multiple properties of a value to another\n * and stable sort them.\n *\n * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n * of corresponding values.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {boolean[]|string[]} orders The order to sort by for each property.\n * @returns {number} Returns the sort order indicator for `object`.\n */\nfunction compareMultiple(object, other, orders) {\n  var index = -1,\n      objCriteria = object.criteria,\n      othCriteria = other.criteria,\n      length = objCriteria.length,\n      ordersLength = orders.length;\n\n  while (++index < length) {\n    var result = compareAscending(objCriteria[index], othCriteria[index]);\n    if (result) {\n      if (index >= ordersLength) {\n        return result;\n      }\n      var order = orders[index];\n      return result * (order == 'desc' ? -1 : 1);\n    }\n  }\n  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n  // that causes it, under certain circumstances, to provide the same value for\n  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n  // for more details.\n  //\n  // This also ensures a stable sort in V8 and other engines.\n  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n  return object.index - other.index;\n}\n\nmodule.exports = compareMultiple;\n","/**\n * The base implementation of `_.sortBy` which uses `comparer` to define the\n * sort order of `array` and replaces criteria objects with their corresponding\n * values.\n *\n * @private\n * @param {Array} array The array to sort.\n * @param {Function} comparer The function to define sort order.\n * @returns {Array} Returns `array`.\n */\nfunction baseSortBy(array, comparer) {\n  var length = array.length;\n\n  array.sort(comparer);\n  while (length--) {\n    array[length] = array[length].value;\n  }\n  return array;\n}\n\nmodule.exports = baseSortBy;\n","var arrayMap = require('./_arrayMap'),\n    baseIteratee = require('./_baseIteratee'),\n    baseMap = require('./_baseMap'),\n    baseSortBy = require('./_baseSortBy'),\n    baseUnary = require('./_baseUnary'),\n    compareMultiple = require('./_compareMultiple'),\n    identity = require('./identity');\n\n/**\n * The base implementation of `_.orderBy` without param guards.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n * @param {string[]} orders The sort orders of `iteratees`.\n * @returns {Array} Returns the new sorted array.\n */\nfunction baseOrderBy(collection, iteratees, orders) {\n  var index = -1;\n  iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));\n\n  var result = baseMap(collection, function(value, key, collection) {\n    var criteria = arrayMap(iteratees, function(iteratee) {\n      return iteratee(value);\n    });\n    return { 'criteria': criteria, 'index': ++index, 'value': value };\n  });\n\n  return baseSortBy(result, function(object, other) {\n    return compareMultiple(object, other, orders);\n  });\n}\n\nmodule.exports = baseOrderBy;\n","var Symbol = require('./_Symbol'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray');\n\n/** Built-in value references. */\nvar spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\nmodule.exports = isFlattenable;\n","var arrayPush = require('./_arrayPush'),\n    isFlattenable = require('./_isFlattenable');\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseFlatten;\n","/**\n * The base implementation of `_.lt` which doesn't coerce arguments.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if `value` is less than `other`,\n *  else `false`.\n */\nfunction baseLt(value, other) {\n  return value < other;\n}\n\nmodule.exports = baseLt;\n","var isSymbol = require('./isSymbol');\n\n/**\n * The base implementation of methods like `_.max` and `_.min` which accepts a\n * `comparator` to determine the extremum value.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The iteratee invoked per iteration.\n * @param {Function} comparator The comparator used to compare values.\n * @returns {*} Returns the extremum value.\n */\nfunction baseExtremum(array, iteratee, comparator) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    var value = array[index],\n        current = iteratee(value);\n\n    if (current != null && (computed === undefined\n          ? (current === current && !isSymbol(current))\n          : comparator(current, computed)\n        )) {\n      var computed = current,\n          result = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseExtremum;\n","var identity = require('./identity');\n\n/**\n * Casts `value` to `identity` if it's not a function.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Function} Returns cast function.\n */\nfunction castFunction(value) {\n  return typeof value == 'function' ? value : identity;\n}\n\nmodule.exports = castFunction;\n","/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n","var isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n","var toNumber = require('./toNumber');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nmodule.exports = toFinite;\n","var toFinite = require('./toFinite');\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nmodule.exports = toInteger;\n","/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = baseFindIndex;\n","var baseFindIndex = require('./_baseFindIndex'),\n    baseIteratee = require('./_baseIteratee'),\n    toInteger = require('./toInteger');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\n * // => 0\n *\n * // The `_.matches` iteratee shorthand.\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findIndex(users, ['active', false]);\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.findIndex(users, 'active');\n * // => 2\n */\nfunction findIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index);\n}\n\nmodule.exports = findIndex;\n","var baseIteratee = require('./_baseIteratee'),\n    isArrayLike = require('./isArrayLike'),\n    keys = require('./keys');\n\n/**\n * Creates a `_.find` or `_.findLast` function.\n *\n * @private\n * @param {Function} findIndexFunc The function to find the collection index.\n * @returns {Function} Returns the new find function.\n */\nfunction createFind(findIndexFunc) {\n  return function(collection, predicate, fromIndex) {\n    var iterable = Object(collection);\n    if (!isArrayLike(collection)) {\n      var iteratee = baseIteratee(predicate, 3);\n      collection = keys(collection);\n      predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n    }\n    var index = findIndexFunc(collection, predicate, fromIndex);\n    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n  };\n}\n\nmodule.exports = createFind;\n","var baseGet = require('./_baseGet');\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\nmodule.exports = basePropertyDeep;\n","/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = baseProperty;\n","var baseProperty = require('./_baseProperty'),\n    basePropertyDeep = require('./_basePropertyDeep'),\n    isKey = require('./_isKey'),\n    toKey = require('./_toKey');\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nmodule.exports = property;\n","var castPath = require('./_castPath'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isIndex = require('./_isIndex'),\n    isLength = require('./isLength'),\n    toKey = require('./_toKey');\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\nmodule.exports = hasPath;\n","/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\nmodule.exports = baseHasIn;\n","var baseHasIn = require('./_baseHasIn'),\n    hasPath = require('./_hasPath');\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\nmodule.exports = hasIn;\n","var Symbol = require('./_Symbol'),\n    arrayMap = require('./_arrayMap'),\n    isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = baseToString;\n","var baseToString = require('./_baseToString');\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nmodule.exports = toString;\n","var MapCache = require('./_MapCache');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n","var memoize = require('./memoize');\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nmodule.exports = memoizeCapped;\n","var memoizeCapped = require('./_memoizeCapped');\n\n/** Used to match property names within property paths. */\nvar reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nmodule.exports = stringToPath;\n","var baseGet = require('./_baseGet');\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n","var baseIsEqual = require('./_baseIsEqual'),\n    get = require('./get'),\n    hasIn = require('./hasIn'),\n    isKey = require('./_isKey'),\n    isStrictComparable = require('./_isStrictComparable'),\n    matchesStrictComparable = require('./_matchesStrictComparable'),\n    toKey = require('./_toKey');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\nmodule.exports = baseMatchesProperty;\n","var isStrictComparable = require('./_isStrictComparable'),\n    keys = require('./keys');\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\nmodule.exports = getMatchData;\n","var Stack = require('./_Stack'),\n    baseIsEqual = require('./_baseIsEqual');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nmodule.exports = baseIsMatch;\n","var baseIsMatch = require('./_baseIsMatch'),\n    getMatchData = require('./_getMatchData'),\n    matchesStrictComparable = require('./_matchesStrictComparable');\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\nmodule.exports = baseMatches;\n","var isArrayLike = require('./isArrayLike');\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\nmodule.exports = createBaseEach;\n","/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n","var createBaseFor = require('./_createBaseFor');\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n","var baseFor = require('./_baseFor'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n","var baseEach = require('./_baseEach');\n\n/**\n * The base implementation of `_.filter` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction baseFilter(collection, predicate) {\n  var result = [];\n  baseEach(collection, function(value, index, collection) {\n    if (predicate(value, index, collection)) {\n      result.push(value);\n    }\n  });\n  return result;\n}\n\nmodule.exports = baseFilter;\n","/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n","var baseTimes = require('./_baseTimes'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isIndex = require('./_isIndex'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n","/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\nmodule.exports = stubArray;\n","var arrayFilter = require('./_arrayFilter'),\n    stubArray = require('./stubArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\nmodule.exports = getSymbols;\n","var arrayPush = require('./_arrayPush'),\n    isArray = require('./isArray');\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\nmodule.exports = baseGetAllKeys;\n","var baseGetAllKeys = require('./_baseGetAllKeys'),\n    getSymbols = require('./_getSymbols'),\n    keys = require('./keys');\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\nmodule.exports = getAllKeys;\n","var getAllKeys = require('./_getAllKeys');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalObjects;\n","/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nmodule.exports = setToArray;\n","/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\nmodule.exports = mapToArray;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Uint8Array = root.Uint8Array;\n\nmodule.exports = Uint8Array;\n","var Symbol = require('./_Symbol'),\n    Uint8Array = require('./_Uint8Array'),\n    eq = require('./eq'),\n    equalArrays = require('./_equalArrays'),\n    mapToArray = require('./_mapToArray'),\n    setToArray = require('./_setToArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]';\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\nmodule.exports = equalByTag;\n","/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\nmodule.exports = cacheHas;\n","/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arraySome;\n","/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\nmodule.exports = setCacheHas;\n","/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\nmodule.exports = setCacheAdd;\n","var MapCache = require('./_MapCache'),\n    setCacheAdd = require('./_setCacheAdd'),\n    setCacheHas = require('./_setCacheHas');\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\nmodule.exports = SetCache;\n","var getMapData = require('./_getMapData');\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n","var getMapData = require('./_getMapData');\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n","var getMapData = require('./_getMapData');\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n","/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n","var getMapData = require('./_getMapData');\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n","/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n","var nativeCreate = require('./_nativeCreate');\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n","var hashClear = require('./_hashClear'),\n    hashDelete = require('./_hashDelete'),\n    hashGet = require('./_hashGet'),\n    hashHas = require('./_hashHas'),\n    hashSet = require('./_hashSet');\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n","var Hash = require('./_Hash'),\n    ListCache = require('./_ListCache'),\n    Map = require('./_Map');\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n","var ListCache = require('./_ListCache'),\n    Map = require('./_Map'),\n    MapCache = require('./_MapCache');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nmodule.exports = stackSet;\n","/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nmodule.exports = stackHas;\n","/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nmodule.exports = stackGet;\n","/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\nmodule.exports = stackDelete;\n","var ListCache = require('./_ListCache');\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\nmodule.exports = stackClear;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n","/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n","var Stack = require('./_Stack'),\n    equalArrays = require('./_equalArrays'),\n    equalByTag = require('./_equalByTag'),\n    equalObjects = require('./_equalObjects'),\n    getTag = require('./_getTag'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\nmodule.exports = baseIsEqualDeep;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n","var baseGetTag = require('./_baseGetTag'),\n    isLength = require('./isLength'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n","/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nmodule.exports = WeakMap;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nmodule.exports = Set;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nmodule.exports = Promise;\n","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n","var root = require('./_root');\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n","var coreJsData = require('./_coreJsData');\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","var isFunction = require('./isFunction'),\n    isMasked = require('./_isMasked'),\n    isObject = require('./isObject'),\n    toSource = require('./_toSource');\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nmodule.exports = DataView;\n","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n","var overArg = require('./_overArg');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n"],"sourceRoot":""}