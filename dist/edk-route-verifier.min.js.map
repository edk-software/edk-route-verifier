{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/loglevel/lib/loglevel.js","webpack:///./node_modules/@turf/helpers/index.js","webpack:///./node_modules/lodash/isArray.js","webpack:///./node_modules/lodash/_root.js","webpack:///./node_modules/@turf/invariant/index.js","webpack:///./node_modules/lodash/_getNative.js","webpack:///./node_modules/lodash/isArrayLike.js","webpack:///./node_modules/lodash/isSymbol.js","webpack:///./node_modules/lodash/identity.js","webpack:///./node_modules/lodash/_baseGetTag.js","webpack:///./node_modules/lodash/_Symbol.js","webpack:///./node_modules/lodash/isObject.js","webpack:///./node_modules/lodash/isObjectLike.js","webpack:///./node_modules/lodash/_baseIteratee.js","webpack:///./node_modules/@turf/distance/index.js","webpack:///./node_modules/lodash/isArguments.js","webpack:///./node_modules/lodash/_ListCache.js","webpack:///./node_modules/lodash/_assocIndexOf.js","webpack:///./node_modules/lodash/_nativeCreate.js","webpack:///./node_modules/lodash/_getMapData.js","webpack:///./node_modules/lodash/keys.js","webpack:///./node_modules/lodash/_toKey.js","webpack:///./node_modules/lodash/_Map.js","webpack:///./node_modules/lodash/isLength.js","webpack:///./node_modules/lodash/isBuffer.js","webpack:///./node_modules/lodash/isTypedArray.js","webpack:///./node_modules/lodash/_baseIsEqual.js","webpack:///./node_modules/lodash/eq.js","webpack:///./node_modules/lodash/_MapCache.js","webpack:///./node_modules/lodash/_isIndex.js","webpack:///./node_modules/lodash/_baseEach.js","webpack:///./node_modules/lodash/get.js","webpack:///./node_modules/lodash/_isKey.js","webpack:///./node_modules/lodash/_arrayMap.js","webpack:///./node_modules/lodash/isEmpty.js","webpack:///./node_modules/lodash/_baseKeys.js","webpack:///./node_modules/lodash/_isPrototype.js","webpack:///./node_modules/lodash/_getTag.js","webpack:///./node_modules/lodash/isFunction.js","webpack:///./node_modules/lodash/_freeGlobal.js","webpack:///./node_modules/lodash/_toSource.js","webpack:///(webpack)/buildin/module.js","webpack:///./node_modules/lodash/_baseUnary.js","webpack:///./node_modules/lodash/isEqual.js","webpack:///./node_modules/lodash/_Stack.js","webpack:///./node_modules/lodash/_equalArrays.js","webpack:///./node_modules/lodash/_arrayPush.js","webpack:///./node_modules/lodash/_arrayFilter.js","webpack:///./node_modules/lodash/isNull.js","webpack:///./node_modules/lodash/filter.js","webpack:///./node_modules/lodash/_isStrictComparable.js","webpack:///./node_modules/lodash/_matchesStrictComparable.js","webpack:///./node_modules/lodash/_baseGet.js","webpack:///./node_modules/lodash/_castPath.js","webpack:///./node_modules/lodash/find.js","webpack:///./node_modules/lodash/forEach.js","webpack:///./node_modules/lodash/map.js","webpack:///./node_modules/lodash/_baseMap.js","webpack:///./node_modules/lodash/min.js","webpack:///./node_modules/lodash/sortBy.js","webpack:///./node_modules/togeojson/togeojson.js","webpack:///./node_modules/@turf/length/index.js","webpack:///./node_modules/@turf/nearest-point-on-line/index.js","webpack:///./node_modules/@turf/point-to-line-distance/index.js","webpack:///./node_modules/process/browser.js","webpack:///./node_modules/lodash/_nativeKeys.js","webpack:///./node_modules/lodash/_overArg.js","webpack:///./node_modules/lodash/_DataView.js","webpack:///./node_modules/lodash/_baseIsNative.js","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/lodash/_getRawTag.js","webpack:///./node_modules/lodash/_objectToString.js","webpack:///./node_modules/lodash/_isMasked.js","webpack:///./node_modules/lodash/_coreJsData.js","webpack:///./node_modules/lodash/_getValue.js","webpack:///./node_modules/lodash/_Promise.js","webpack:///./node_modules/lodash/_Set.js","webpack:///./node_modules/lodash/_WeakMap.js","webpack:///./node_modules/lodash/_baseIsArguments.js","webpack:///./node_modules/lodash/stubFalse.js","webpack:///./node_modules/lodash/_baseIsTypedArray.js","webpack:///./node_modules/lodash/_nodeUtil.js","webpack:///./node_modules/lodash/_baseIsEqualDeep.js","webpack:///./node_modules/lodash/_listCacheClear.js","webpack:///./node_modules/lodash/_listCacheDelete.js","webpack:///./node_modules/lodash/_listCacheGet.js","webpack:///./node_modules/lodash/_listCacheHas.js","webpack:///./node_modules/lodash/_listCacheSet.js","webpack:///./node_modules/lodash/_stackClear.js","webpack:///./node_modules/lodash/_stackDelete.js","webpack:///./node_modules/lodash/_stackGet.js","webpack:///./node_modules/lodash/_stackHas.js","webpack:///./node_modules/lodash/_stackSet.js","webpack:///./node_modules/lodash/_mapCacheClear.js","webpack:///./node_modules/lodash/_Hash.js","webpack:///./node_modules/lodash/_hashClear.js","webpack:///./node_modules/lodash/_hashDelete.js","webpack:///./node_modules/lodash/_hashGet.js","webpack:///./node_modules/lodash/_hashHas.js","webpack:///./node_modules/lodash/_hashSet.js","webpack:///./node_modules/lodash/_mapCacheDelete.js","webpack:///./node_modules/lodash/_isKeyable.js","webpack:///./node_modules/lodash/_mapCacheGet.js","webpack:///./node_modules/lodash/_mapCacheHas.js","webpack:///./node_modules/lodash/_mapCacheSet.js","webpack:///./node_modules/lodash/_SetCache.js","webpack:///./node_modules/lodash/_setCacheAdd.js","webpack:///./node_modules/lodash/_setCacheHas.js","webpack:///./node_modules/lodash/_arraySome.js","webpack:///./node_modules/lodash/_cacheHas.js","webpack:///./node_modules/lodash/_equalByTag.js","webpack:///./node_modules/lodash/_Uint8Array.js","webpack:///./node_modules/lodash/_mapToArray.js","webpack:///./node_modules/lodash/_setToArray.js","webpack:///./node_modules/lodash/_equalObjects.js","webpack:///./node_modules/lodash/_getAllKeys.js","webpack:///./node_modules/lodash/_baseGetAllKeys.js","webpack:///./node_modules/lodash/_getSymbols.js","webpack:///./node_modules/lodash/stubArray.js","webpack:///./node_modules/lodash/_arrayLikeKeys.js","webpack:///./node_modules/lodash/_baseTimes.js","webpack:///./node_modules/lodash/_baseFilter.js","webpack:///./node_modules/lodash/_baseForOwn.js","webpack:///./node_modules/lodash/_baseFor.js","webpack:///./node_modules/lodash/_createBaseFor.js","webpack:///./node_modules/lodash/_createBaseEach.js","webpack:///./node_modules/lodash/_baseMatches.js","webpack:///./node_modules/lodash/_baseIsMatch.js","webpack:///./node_modules/lodash/_getMatchData.js","webpack:///./node_modules/lodash/_baseMatchesProperty.js","webpack:///./node_modules/lodash/_stringToPath.js","webpack:///./node_modules/lodash/_memoizeCapped.js","webpack:///./node_modules/lodash/memoize.js","webpack:///./node_modules/lodash/toString.js","webpack:///./node_modules/lodash/_baseToString.js","webpack:///./node_modules/lodash/hasIn.js","webpack:///./node_modules/lodash/_baseHasIn.js","webpack:///./node_modules/lodash/_hasPath.js","webpack:///./node_modules/lodash/property.js","webpack:///./node_modules/lodash/_baseProperty.js","webpack:///./node_modules/lodash/_basePropertyDeep.js","webpack:///./node_modules/lodash/_createFind.js","webpack:///./node_modules/lodash/findIndex.js","webpack:///./node_modules/lodash/_baseFindIndex.js","webpack:///./node_modules/lodash/toInteger.js","webpack:///./node_modules/lodash/toFinite.js","webpack:///./node_modules/lodash/toNumber.js","webpack:///./node_modules/lodash/_arrayEach.js","webpack:///./node_modules/lodash/_castFunction.js","webpack:///./node_modules/lodash/_baseExtremum.js","webpack:///./node_modules/lodash/_baseLt.js","webpack:///./node_modules/lodash/_baseFlatten.js","webpack:///./node_modules/lodash/_isFlattenable.js","webpack:///./node_modules/lodash/_baseOrderBy.js","webpack:///./node_modules/lodash/_baseSortBy.js","webpack:///./node_modules/lodash/_compareMultiple.js","webpack:///./node_modules/lodash/_compareAscending.js","webpack:///./node_modules/lodash/_baseRest.js","webpack:///./node_modules/lodash/_overRest.js","webpack:///./node_modules/lodash/_apply.js","webpack:///./node_modules/lodash/_setToString.js","webpack:///./node_modules/lodash/_baseSetToString.js","webpack:///./node_modules/lodash/constant.js","webpack:///./node_modules/lodash/_defineProperty.js","webpack:///./node_modules/lodash/_shortOut.js","webpack:///./node_modules/lodash/_isIterateeCall.js","webpack:///./node_modules/@turf/length/node_modules/@turf/meta/index.js","webpack:///./node_modules/@turf/nearest-point-on-line/node_modules/@turf/bearing/index.js","webpack:///./node_modules/@turf/nearest-point-on-line/node_modules/@turf/destination/index.js","webpack:///./node_modules/@turf/line-intersect/index.js","webpack:///./node_modules/@turf/line-segment/index.js","webpack:///./node_modules/@turf/line-segment/node_modules/@turf/meta/index.js","webpack:///./node_modules/@turf/line-intersect/node_modules/@turf/meta/index.js","webpack:///./node_modules/geojson-rbush/index.js","webpack:///./node_modules/rbush/index.js","webpack:///./node_modules/quickselect/quickselect.js","webpack:///./node_modules/geojson-rbush/node_modules/@turf/meta/index.js","webpack:///./node_modules/@turf/bbox/index.js","webpack:///./node_modules/@turf/bbox/node_modules/@turf/meta/index.js","webpack:///./node_modules/@turf/nearest-point-on-line/node_modules/@turf/meta/index.js","webpack:///./node_modules/@turf/point-to-line-distance/node_modules/@turf/meta/index.js","webpack:///./node_modules/@turf/rhumb-distance/index.js","webpack:///./node_modules/@turf/meta/node_modules/@turf/helpers/main.es.js","webpack:///./node_modules/@turf/meta/main.es.js","webpack:///./node_modules/@turf/flatten/node_modules/@turf/helpers/main.es.js","webpack:///./node_modules/@turf/flatten/main.es.js","webpack:///./src/helpers.js","webpack:///./src/PathElevation.js","webpack:///./node_modules/@turf/line-slice-along/node_modules/@turf/helpers/main.es.js","webpack:///./node_modules/@turf/line-slice-along/node_modules/@turf/invariant/main.es.js","webpack:///./node_modules/@turf/line-slice-along/node_modules/@turf/bearing/main.es.js","webpack:///./node_modules/@turf/line-slice-along/node_modules/@turf/distance/main.es.js","webpack:///./node_modules/@turf/line-slice-along/node_modules/@turf/destination/main.es.js","webpack:///./node_modules/@turf/line-slice-along/main.es.js","webpack:///./src/Stations.js","webpack:///./src/Route.js","webpack:///./src/Context.js","webpack:///./src/Controls.js","webpack:///./src/routeVerifier.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","root","definition","undefined","noop","undefinedType","logMethods","bindMethod","obj","methodName","method","Function","e","apply","arguments","replaceLoggingMethods","level","loggerName","length","this","methodFactory","log","debug","defaultMethodFactory","console","realMethod","Logger","defaultLevel","factory","currentLevel","self","storageKey","getPersistedLevel","storedLevel","window","localStorage","ignore","cookie","document","location","indexOf","encodeURIComponent","exec","slice","levels","TRACE","DEBUG","INFO","WARN","ERROR","SILENT","getLevel","setLevel","persist","toUpperCase","levelNum","levelName","persistLevelIfPossible","setDefaultLevel","enableAll","disableAll","initialLevel","defaultLogger","_loggersByName","getLogger","TypeError","logger","_log","noConflict","getLoggers","feature","geom","properties","options","feat","type","id","bbox","geometry","point","coordinates","polygon","_i","coordinates_1","ring","Error","j","lineString","featureCollection","features","fc","multiLineString","multiPoint","multiPolygon","radiansToLength","radians","units","factor","factors","lengthToRadians","distance","radiansToDegrees","Math","PI","isNumber","num","isNaN","Array","isArray","test","earthRadius","centimeters","centimetres","degrees","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","yards","unitsFactors","areaFactors","acres","points","map","coords","polygons","lineStrings","geometryCollection","geometries","round","precision","multiplier","pow","lengthToDegrees","bearingToAzimuth","bearing","angle","degreesToRadians","convertLength","originalUnit","finalUnit","convertArea","area","startFactor","finalFactor","isObject","input","constructor","validateBBox","forEach","validateId","radians2degrees","degrees2radians","distanceToDegrees","distanceToRadians","radiansToDistance","bearingToAngle","convertDistance","freeGlobal","freeSelf","helpers_1","getCoord","coord","getCoords","containsNumber","geojsonType","featureOf","collectionOf","_a","getGeom","geojson","getType","baseIsNative","getValue","isFunction","isLength","baseGetTag","isObjectLike","symbolTag","getRawTag","objectToString","nullTag","undefinedTag","symToStringTag","baseMatches","baseMatchesProperty","identity","invariant_1","default","from","to","coordinates1","coordinates2","dLat","dLon","lat1","lat2","a","sin","cos","atan2","sqrt","baseIsArguments","objectProto","propertyIsEnumerable","isArguments","listCacheClear","listCacheDelete","listCacheGet","listCacheHas","listCacheSet","ListCache","entries","index","clear","entry","set","has","eq","array","nativeCreate","getNative","isKeyable","data","__data__","arrayLikeKeys","baseKeys","isArrayLike","isSymbol","INFINITY","result","Map","MAX_SAFE_INTEGER","stubFalse","freeExports","nodeType","freeModule","Buffer","isBuffer","baseIsTypedArray","baseUnary","nodeUtil","nodeIsTypedArray","isTypedArray","baseIsEqualDeep","baseIsEqual","other","bitmask","customizer","stack","mapCacheClear","mapCacheDelete","mapCacheGet","mapCacheHas","mapCacheSet","MapCache","reIsUint","baseForOwn","baseEach","createBaseEach","baseGet","path","defaultValue","reIsDeepProp","reIsPlainProp","iteratee","getTag","isPrototype","mapTag","setTag","splice","tag","size","nativeKeys","push","Ctor","DataView","Promise","Set","WeakMap","toSource","dataViewCtorString","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","ArrayBuffer","resolve","ctorString","asyncTag","funcTag","genTag","proxyTag","global","funcToString","toString","func","webpackPolyfill","deprecate","paths","children","stackClear","stackDelete","stackGet","stackHas","stackSet","Stack","SetCache","arraySome","cacheHas","COMPARE_PARTIAL_FLAG","COMPARE_UNORDERED_FLAG","equalFunc","isPartial","arrLength","othLength","stacked","seen","arrValue","othValue","compared","othIndex","values","offset","predicate","resIndex","arrayFilter","baseFilter","baseIteratee","collection","srcValue","castPath","toKey","isKey","stringToPath","find","createFind","arrayEach","castFunction","arrayMap","baseMap","baseExtremum","baseLt","baseFlatten","baseOrderBy","baseRest","isIterateeCall","sortBy","iteratees","process","toGeoJSON","serializer","removeSpace","trimSpace","splitSpace","okhash","x","h","charCodeAt","y","getElementsByTagName","attr","getAttribute","attrf","parseFloat","get1","numarray","nodeVal","el","normalize","textContent","getMulti","ys","k","extend","coord1","v","replace","split","coordPair","ll","ele","heartRate","time","xml2str","str","xml","serializeToString","XMLSerializer","browser","kml","doc","gj","styleIndex","styleByHash","styleMapIndex","geotypes","placemarks","styles","styleMaps","hash","pairs","pairsMap","concat","getPlacemark","kmlColor","color","opacity","substr","parseInt","gxCoords","elems","times","timeElems","geomsAndTimes","getGeometry","geomNode","geomNodes","geoms","coordTimes","rings","track","styleUrl","description","timeSpan","timeStamp","extendedData","lineStyle","polyStyle","visibility","styleHash","styleMapHash","normal","style","begin","end","timespan","timestamp","linestyles","width","stroke","polystyles","pcolor","popacity","fill","outline","datas","simpleDatas","gpx","tracks","routes","waypoints","getTrack","getRoute","getPoint","getPoints","node","pointname","pts","line","heartRates","segments","getProperties","prop","links","link","href","__importDefault","mod","distance_1","meta_1","segmentReduce","previousValue","segment","bearing_1","destination_1","line_intersect_1","lines","pt","closestPt","Infinity","dist","flattenEach","start","stop_1","sectionLength","heightDistance","max","direction","perpendicularPt1","perpendicularPt2","intersect","intersectPt","rhumb_distance_1","dot","u","calcDistance","b","segmentEach","c1","c2","b2","Pb","distanceToSegment","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","len","run","marker","runClearTimeout","Item","nextTick","args","title","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","overArg","keys","transform","arg","isMasked","reIsHostCtor","funcProto","reIsNative","RegExp","g","nativeObjectToString","isOwn","unmasked","uid","coreJsData","maskSrcKey","IE_PROTO","argsTag","typedArrayTags","freeProcess","types","require","equalArrays","equalByTag","equalObjects","arrayTag","objectTag","objIsArr","othIsArr","objTag","othTag","objIsObj","othIsObj","isSameTag","objIsWrapped","othIsWrapped","objUnwrapped","othUnwrapped","assocIndexOf","pop","LARGE_ARRAY_SIZE","Hash","string","hashClear","hashDelete","hashGet","hashHas","hashSet","HASH_UNDEFINED","getMapData","setCacheAdd","setCacheHas","add","cache","Uint8Array","mapToArray","setToArray","boolTag","dateTag","errorTag","numberTag","regexpTag","stringTag","arrayBufferTag","dataViewTag","symbolProto","symbolValueOf","valueOf","byteLength","byteOffset","buffer","message","convert","getAllKeys","objProps","objLength","skipCtor","objValue","objCtor","othCtor","baseGetAllKeys","getSymbols","arrayPush","keysFunc","symbolsFunc","stubArray","nativeGetSymbols","getOwnPropertySymbols","symbol","baseTimes","isIndex","inherited","isArr","isArg","isBuff","isType","skipIndexes","String","baseFor","createBaseFor","fromRight","iterable","props","eachFunc","baseIsMatch","getMatchData","matchesStrictComparable","source","matchData","noCustomizer","isStrictComparable","hasIn","memoizeCapped","rePropName","reEscapeChar","match","number","quote","subString","memoize","MAX_MEMOIZE_SIZE","FUNC_ERROR_TEXT","resolver","memoized","Cache","baseToString","symbolToString","baseHasIn","hasPath","hasFunc","baseProperty","basePropertyDeep","findIndexFunc","fromIndex","baseFindIndex","toInteger","nativeMax","toFinite","remainder","toNumber","MAX_INTEGER","NAN","reTrim","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","isBinary","comparator","current","computed","isFlattenable","depth","isStrict","spreadableSymbol","isConcatSpreadable","baseSortBy","compareMultiple","orders","criteria","comparer","sort","compareAscending","objCriteria","othCriteria","ordersLength","valIsDefined","valIsNull","valIsReflexive","valIsSymbol","othIsDefined","othIsNull","othIsReflexive","othIsSymbol","overRest","setToString","otherArgs","thisArg","baseSetToString","shortOut","constant","configurable","writable","HOT_COUNT","HOT_SPAN","nativeNow","Date","now","count","lastCalled","stamp","remaining","helpers","coordEach","callback","excludeWrapCoord","stopG","geometryMaybeCollection","isGeometryCollection","wrapShrink","coordIndex","isFeatureCollection","isFeature","stop","featureIndex","geomIndex","multiFeatureIndex","geometryIndex","geomType","propEach","featureEach","geomEach","featureProperties","featureBBox","featureId","segmentIndex","previousCoords","previousFeatureIndex","previousMultiIndex","prevGeomIndex","currentCoord","featureIndexCoord","multiPartIndexCoord","currentSegment","lineEach","coordReduce","initialValue","propReduce","currentProperties","featureReduce","currentFeature","coordAll","geomReduce","currentGeometry","flattenReduce","started","lineReduce","currentLine","findSegment","findPoint","final","bear","calculateFinalBearing","lon1","lon2","origin","longitude1","latitude1","bearingRad","latitude2","asin","longitude2","lng","lat","line_segment_1","geojson_rbush_1","intersects","line1","line2","coords1","coords2","x1","y1","x2","y2","x3","y3","x4","y4","denom","numeA","numeB","uA","uB","unique","results","tree","load","search","join","reduce","currentCoords","createSegments","lineSegmentFeature","rbush","meta","turfBBox","geojsonRbush","maxEntries","insert","remove","equals","toBBox","collides","all","toJSON","fromJSON","json","minX","minY","maxX","maxY","quickselect","format","_maxEntries","_minEntries","ceil","_initFormat","findItem","item","items","equalsFn","calcBBox","distBBox","destNode","createNode","child","leaf","min","compareNodeMinX","compareNodeMinY","bboxArea","bboxMargin","contains","height","multiSelect","arr","left","right","compare","mid","_all","childBBox","nodesToSearch","_build","_splitRoot","tmpNode","_insert","parent","goingUp","indexes","_condense","compareMinX","compareMinY","N","M","right2","right3","N2","N1","_chooseSubtree","targetNode","enlargement","minArea","minEnlargement","isNode","insertPath","_split","_adjustParentBBoxes","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","bbox1","bbox2","overlap","minOverlap","_allDistMargin","leftBBox","rightBBox","margin","siblings","compareArr","swap","tmp","defaultCompare","quickselectStep","z","exp","sd","newLeft","floor","newRight","destination","distanceInMeters","radius","R","Number","phi1","phi2","DeltaPhi","DeltaLambda","abs","DeltaPsi","tan","q","calculateRhumbDistance","main_es_feature","coordinate","main_es_featureCollection","main_es_isObject","main_es_validateBBox","main_es_validateId","main_es_isNumber","main_es","Helpers","parentNode","removeChild","geoJson","flatten","featureName","_","MAX_VALUE","newLineString","reverse","routeUrl","$","ajax","google","maps","LatLng","element","getGoogleMapsLatLng","useLocalElevations","elevations","elevation","reject","getGoogleMapsPath","optimizedPath","delta","ElevationService","getElevationAlongPath","samples","status","ElevationStatus","OK","routeParamsUrl","done","success","error","fail","xhr","routeApproveUrl","getGain","elevationGain","elevationDifference","getLoss","elevationLoss","PathElevation","PathElevation_classCallCheck","gain","loss","totalChange","elevationsWithDistance","resolution","helpers_main_es_factors","helpers_main_es_earthRadius","_turf_helpers_main_es_feature","helpers_main_es_isObject","helpers_main_es_validateBBox","helpers_main_es_validateId","_turf_helpers_main_es_point","helpers_main_es_isNumber","_turf_helpers_main_es_lineString","helpers_main_es_radiansToLength","helpers_main_es_lengthToRadians","helpers_main_es_radiansToDegrees","helpers_main_es_degreesToRadians","main_es_bearing","bearing_main_es","distance_main_es","destination_main_es","bearing_rad","line_slice_along_main_es","startDist","stopDist","overshot","interpolated","travelled","turf","lineSliceAlong","pointToLineDistance","nearestPointOnLine","CONSTS","Stations","Stations_classCallCheck","pathReversed","pathCircular","addIndexes","sortByIndex","pathStart","pathEnd","updateCircularity","updateDirection","findNearestPointsOnPath","sortByLocationOnPath","_this","stepDistance","sampleDistance","nearestPointOnSlicedPath","nearestOnLine","startPointDistance","stopPointDistance","oldDistanceToPath","newDistanceToPath","slicedPath","toFixed","addDebugInformationToMap","originalPoint","nearestPoint","Marker","position","label","fontWeight","text","icon","getIndex","getLocation","START_NAMES_REGEX","END_NAMES_REGEX","ROMAN_NUMBERS_REGEX","EUROPEAN_NUMBERS_REGEX","ROMAN_EUROPEAN_MAP","I","II","III","IV","V","VI","VII","VIII","IX","X","XI","XII","XIII","XIV","parts","trim","part","matches","stationNumber","isIndexEqual","startPoint","endPoint","endPointToPathStartDistance","reverseLineString","_this2","numberOfStations","_loop","firstStationName","stationsOfNumber","station","warn","currentStationNumber","previousStationNumber","maximumDistanceFromPath","distanceFromStationToPath","getDistanceToNearestPointOnLine","lastStationPoint","lastStationLocation","getLocationOfNearestPointOnLine","Route","Route_classCallCheck","getLineString","isRouteVerifiable","stations","getUpdatedPath","numberOfPaths","getNumberOfFeatures","getCount","areAllOnThePath","isOrderCorrect","googleMapsPath","spherical","computeLength","getPathElevations","then","pathElevation","catch","Context","mapCanvasElement","updateControlColor","isValid","VALID_COLOR_CLASS","INVALID_COLOR_CLASS","removeClass","addClass","updateControlValue","unit","html","Controls","isNormalRoute","normalRouteString","inspiredRouteString","isLengthValid","isElevationGainValid","isElevationLossValid","isElevationTotalChangeValid","elevationTotalChange","areAllStationsPresent","isStationOrderCorrect","areAllStationsOnPath","isSinglePath","isDataConsistent","labelWidth","labels","Chart","datasets","backgroundColor","scales","xAxes","scaleLabel","display","labelString","ticks","dataLabel","yAxes","legend","tooltips","enabled","elevationChartParentElement","append","VERIFY_BUTTON_ID","resetElevationChart","NORMAL_ROUTE_MIN_LENGTH","SHORT_NORMAL_ROUTE_MIN_LENGTH","SHORT_NORMAL_ROUTE_MIN_ELEVATION_GAIN","GOOGLE_MAPS_API_LOADED","gm_authFailure","setLogLevel","logLevel","context","controls","resetAll","addLoaderToButton","getGeoJSON","route","isVerifiable","updateSinglePath","routeLength","getPathLength","updatePathLength","updateNumberOfStations","updateStationsOrder","areStationsOnThePath","updateStationsOnPath","fetchPathElevationData","getPathElevation","enrichData","updateElevationGain","updateRouteType","updateElevationLoss","updateElevationTotalChange","drawElevationChart","getRouteParameters","parameters","isLengthConsistent","isElevationGainConsistent","ascent","isRouteTypeConsistent","updateDataConsistency","info","approveRoute","pageReloadModalElement","reloadTimeout","reload","modal","always","removeLoaderFromButton"],"mappings":"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","file":"edk-route-verifier.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 183);\n","/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      var storageKey = \"loglevel\";\n      if (name) {\n        storageKey += \":\" + name;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"string\" || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    return defaultLogger;\n}));\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.370,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.370,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, options) {\n    if (options === void 0) { options = {}; }\n    switch (type) {\n        case \"Point\": return point(coordinates).geometry;\n        case \"LineString\": return lineString(coordinates).geometry;\n        case \"Polygon\": return polygon(coordinates).geometry;\n        case \"MultiPoint\": return multiPoint(coordinates).geometry;\n        case \"MultiLineString\": return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\": return multiPolygon(coordinates).geometry;\n        default: throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\\s*$/.test(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error(\"method has been renamed to `radiansToDegrees`\");\n}\nexports.radians2degrees = radians2degrees;\nfunction degrees2radians() {\n    throw new Error(\"method has been renamed to `degreesToRadians`\");\n}\nexports.degrees2radians = degrees2radians;\nfunction distanceToDegrees() {\n    throw new Error(\"method has been renamed to `lengthToDegrees`\");\n}\nexports.distanceToDegrees = distanceToDegrees;\nfunction distanceToRadians() {\n    throw new Error(\"method has been renamed to `lengthToRadians`\");\n}\nexports.distanceToRadians = distanceToRadians;\nfunction radiansToDistance() {\n    throw new Error(\"method has been renamed to `radiansToLength`\");\n}\nexports.radiansToDistance = radiansToDistance;\nfunction bearingToAngle() {\n    throw new Error(\"method has been renamed to `bearingToAzimuth`\");\n}\nexports.bearingToAngle = bearingToAngle;\nfunction convertDistance() {\n    throw new Error(\"method has been renamed to `convertLength`\");\n}\nexports.convertDistance = convertDistance;\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"@turf/helpers\");\r\n/**\r\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\r\n *\r\n * @name getCoord\r\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\r\n * @returns {Array<number>} coordinates\r\n * @example\r\n * var pt = turf.point([10, 10]);\r\n *\r\n * var coord = turf.getCoord(pt);\r\n * //= [10, 10]\r\n */\r\nfunction getCoord(coord) {\r\n    if (!coord) {\r\n        throw new Error(\"coord is required\");\r\n    }\r\n    if (!Array.isArray(coord)) {\r\n        if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\r\n            return coord.geometry.coordinates;\r\n        }\r\n        if (coord.type === \"Point\") {\r\n            return coord.coordinates;\r\n        }\r\n    }\r\n    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\r\n        return coord;\r\n    }\r\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\r\n}\r\nexports.getCoord = getCoord;\r\n/**\r\n * Unwrap coordinates from a Feature, Geometry Object or an Array\r\n *\r\n * @name getCoords\r\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\r\n * @returns {Array<any>} coordinates\r\n * @example\r\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\r\n *\r\n * var coords = turf.getCoords(poly);\r\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\r\n */\r\nfunction getCoords(coords) {\r\n    if (Array.isArray(coords)) {\r\n        return coords;\r\n    }\r\n    // Feature\r\n    if (coords.type === \"Feature\") {\r\n        if (coords.geometry !== null) {\r\n            return coords.geometry.coordinates;\r\n        }\r\n    }\r\n    else {\r\n        // Geometry\r\n        if (coords.coordinates) {\r\n            return coords.coordinates;\r\n        }\r\n    }\r\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\r\n}\r\nexports.getCoords = getCoords;\r\n/**\r\n * Checks if coordinates contains a number\r\n *\r\n * @name containsNumber\r\n * @param {Array<any>} coordinates GeoJSON Coordinates\r\n * @returns {boolean} true if Array contains a number\r\n */\r\nfunction containsNumber(coordinates) {\r\n    if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\r\n        return containsNumber(coordinates[0]);\r\n    }\r\n    throw new Error(\"coordinates must only contain numbers\");\r\n}\r\nexports.containsNumber = containsNumber;\r\n/**\r\n * Enforce expectations about types of GeoJSON objects for Turf.\r\n *\r\n * @name geojsonType\r\n * @param {GeoJSON} value any GeoJSON object\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction geojsonType(value, type, name) {\r\n    if (!type || !name) {\r\n        throw new Error(\"type and name required\");\r\n    }\r\n    if (!value || value.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type);\r\n    }\r\n}\r\nexports.geojsonType = geojsonType;\r\n/**\r\n * Enforce expectations about types of {@link Feature} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name featureOf\r\n * @param {Feature} feature a feature with an expected geometry type\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} error if value is not the expected type.\r\n */\r\nfunction featureOf(feature, type, name) {\r\n    if (!feature) {\r\n        throw new Error(\"No feature passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".featureOf() requires a name\");\r\n    }\r\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n    }\r\n    if (!feature.geometry || feature.geometry.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n    }\r\n}\r\nexports.featureOf = featureOf;\r\n/**\r\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name collectionOf\r\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction collectionOf(featureCollection, type, name) {\r\n    if (!featureCollection) {\r\n        throw new Error(\"No featureCollection passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".collectionOf() requires a name\");\r\n    }\r\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\r\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\r\n    }\r\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\r\n        var feature = _a[_i];\r\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n        }\r\n        if (!feature.geometry || feature.geometry.type !== type) {\r\n            throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n        }\r\n    }\r\n}\r\nexports.collectionOf = collectionOf;\r\n/**\r\n * Get Geometry from Feature or Geometry Object\r\n *\r\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\r\n * @returns {Geometry|null} GeoJSON Geometry Object\r\n * @throws {Error} if geojson is not a Feature or Geometry Object\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getGeom(point)\r\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\r\n */\r\nfunction getGeom(geojson) {\r\n    if (geojson.type === \"Feature\") {\r\n        return geojson.geometry;\r\n    }\r\n    return geojson;\r\n}\r\nexports.getGeom = getGeom;\r\n/**\r\n * Get GeoJSON object's type, Geometry type is prioritize.\r\n *\r\n * @param {GeoJSON} geojson GeoJSON object\r\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\r\n * @returns {string} GeoJSON type\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getType(point)\r\n * //=\"Point\"\r\n */\r\nfunction getType(geojson, name) {\r\n    if (geojson.type === \"FeatureCollection\") {\r\n        return \"FeatureCollection\";\r\n    }\r\n    if (geojson.type === \"GeometryCollection\") {\r\n        return \"GeometryCollection\";\r\n    }\r\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\r\n        return geojson.geometry.type;\r\n    }\r\n    return geojson.type;\r\n}\r\nexports.getType = getType;\r\n","var baseIsNative = require('./_baseIsNative'),\n    getValue = require('./_getValue');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n","var isFunction = require('./isFunction'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var baseMatches = require('./_baseMatches'),\n    baseMatchesProperty = require('./_baseMatchesProperty'),\n    identity = require('./identity'),\n    isArray = require('./isArray'),\n    property = require('./property');\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\nmodule.exports = baseIteratee;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar invariant_1 = require(\"@turf/invariant\");\nvar helpers_1 = require(\"@turf/helpers\");\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians, miles, or kilometers.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name distance\n * @param {Coord} from origin point\n * @param {Coord} to destination point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.distance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n    if (options === void 0) { options = {}; }\n    var coordinates1 = invariant_1.getCoord(from);\n    var coordinates2 = invariant_1.getCoord(to);\n    var dLat = helpers_1.degreesToRadians((coordinates2[1] - coordinates1[1]));\n    var dLon = helpers_1.degreesToRadians((coordinates2[0] - coordinates1[0]));\n    var lat1 = helpers_1.degreesToRadians(coordinates1[1]);\n    var lat2 = helpers_1.degreesToRadians(coordinates2[1]);\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n        Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n    return helpers_1.radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);\n}\nexports.default = distance;\n","var baseIsArguments = require('./_baseIsArguments'),\n    isObjectLike = require('./isObjectLike');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n","var listCacheClear = require('./_listCacheClear'),\n    listCacheDelete = require('./_listCacheDelete'),\n    listCacheGet = require('./_listCacheGet'),\n    listCacheHas = require('./_listCacheHas'),\n    listCacheSet = require('./_listCacheSet');\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n","var eq = require('./eq');\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n","var getNative = require('./_getNative');\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n","var isKeyable = require('./_isKeyable');\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeys = require('./_baseKeys'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n","var isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = toKey;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n","var root = require('./_root'),\n    stubFalse = require('./stubFalse');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n","var baseIsTypedArray = require('./_baseIsTypedArray'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n","var baseIsEqualDeep = require('./_baseIsEqualDeep'),\n    isObjectLike = require('./isObjectLike');\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\nmodule.exports = baseIsEqual;\n","/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n","var mapCacheClear = require('./_mapCacheClear'),\n    mapCacheDelete = require('./_mapCacheDelete'),\n    mapCacheGet = require('./_mapCacheGet'),\n    mapCacheHas = require('./_mapCacheHas'),\n    mapCacheSet = require('./_mapCacheSet');\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n","var baseForOwn = require('./_baseForOwn'),\n    createBaseEach = require('./_createBaseEach');\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\nmodule.exports = baseEach;\n","var baseGet = require('./_baseGet');\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n","var isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nmodule.exports = isKey;\n","/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n","var baseKeys = require('./_baseKeys'),\n    getTag = require('./_getTag'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isArrayLike = require('./isArrayLike'),\n    isBuffer = require('./isBuffer'),\n    isPrototype = require('./_isPrototype'),\n    isTypedArray = require('./isTypedArray');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    setTag = '[object Set]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if `value` is an empty object, collection, map, or set.\n *\n * Objects are considered empty if they have no own enumerable string keyed\n * properties.\n *\n * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n * jQuery-like collections are considered empty if they have a `length` of `0`.\n * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n * @example\n *\n * _.isEmpty(null);\n * // => true\n *\n * _.isEmpty(true);\n * // => true\n *\n * _.isEmpty(1);\n * // => true\n *\n * _.isEmpty([1, 2, 3]);\n * // => false\n *\n * _.isEmpty({ 'a': 1 });\n * // => false\n */\nfunction isEmpty(value) {\n  if (value == null) {\n    return true;\n  }\n  if (isArrayLike(value) &&\n      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n        isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n    return !value.length;\n  }\n  var tag = getTag(value);\n  if (tag == mapTag || tag == setTag) {\n    return !value.size;\n  }\n  if (isPrototype(value)) {\n    return !baseKeys(value).length;\n  }\n  for (var key in value) {\n    if (hasOwnProperty.call(value, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = isEmpty;\n","var isPrototype = require('./_isPrototype'),\n    nativeKeys = require('./_nativeKeys');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n","var DataView = require('./_DataView'),\n    Map = require('./_Map'),\n    Promise = require('./_Promise'),\n    Set = require('./_Set'),\n    WeakMap = require('./_WeakMap'),\n    baseGetTag = require('./_baseGetTag'),\n    toSource = require('./_toSource');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nmodule.exports = getTag;\n","var baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n","var baseIsEqual = require('./_baseIsEqual');\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\nmodule.exports = isEqual;\n","var ListCache = require('./_ListCache'),\n    stackClear = require('./_stackClear'),\n    stackDelete = require('./_stackDelete'),\n    stackGet = require('./_stackGet'),\n    stackHas = require('./_stackHas'),\n    stackSet = require('./_stackSet');\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nmodule.exports = Stack;\n","var SetCache = require('./_SetCache'),\n    arraySome = require('./_arraySome'),\n    cacheHas = require('./_cacheHas');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalArrays;\n","/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n","/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayFilter;\n","/**\n * Checks if `value` is `null`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n * @example\n *\n * _.isNull(null);\n * // => true\n *\n * _.isNull(void 0);\n * // => false\n */\nfunction isNull(value) {\n  return value === null;\n}\n\nmodule.exports = isNull;\n","var arrayFilter = require('./_arrayFilter'),\n    baseFilter = require('./_baseFilter'),\n    baseIteratee = require('./_baseIteratee'),\n    isArray = require('./isArray');\n\n/**\n * Iterates over elements of `collection`, returning an array of all elements\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * **Note:** Unlike `_.remove`, this method returns a new array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n * @see _.reject\n * @example\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': true },\n *   { 'user': 'fred',   'age': 40, 'active': false }\n * ];\n *\n * _.filter(users, function(o) { return !o.active; });\n * // => objects for ['fred']\n *\n * // The `_.matches` iteratee shorthand.\n * _.filter(users, { 'age': 36, 'active': true });\n * // => objects for ['barney']\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.filter(users, ['active', false]);\n * // => objects for ['fred']\n *\n * // The `_.property` iteratee shorthand.\n * _.filter(users, 'active');\n * // => objects for ['barney']\n */\nfunction filter(collection, predicate) {\n  var func = isArray(collection) ? arrayFilter : baseFilter;\n  return func(collection, baseIteratee(predicate, 3));\n}\n\nmodule.exports = filter;\n","var isObject = require('./isObject');\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\nmodule.exports = isStrictComparable;\n","/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\nmodule.exports = matchesStrictComparable;\n","var castPath = require('./_castPath'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n","var isArray = require('./isArray'),\n    isKey = require('./_isKey'),\n    stringToPath = require('./_stringToPath'),\n    toString = require('./toString');\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nmodule.exports = castPath;\n","var createFind = require('./_createFind'),\n    findIndex = require('./findIndex');\n\n/**\n * Iterates over elements of `collection`, returning the first element\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {*} Returns the matched element, else `undefined`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'age': 36, 'active': true },\n *   { 'user': 'fred',    'age': 40, 'active': false },\n *   { 'user': 'pebbles', 'age': 1,  'active': true }\n * ];\n *\n * _.find(users, function(o) { return o.age < 40; });\n * // => object for 'barney'\n *\n * // The `_.matches` iteratee shorthand.\n * _.find(users, { 'age': 1, 'active': true });\n * // => object for 'pebbles'\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.find(users, ['active', false]);\n * // => object for 'fred'\n *\n * // The `_.property` iteratee shorthand.\n * _.find(users, 'active');\n * // => object for 'barney'\n */\nvar find = createFind(findIndex);\n\nmodule.exports = find;\n","var arrayEach = require('./_arrayEach'),\n    baseEach = require('./_baseEach'),\n    castFunction = require('./_castFunction'),\n    isArray = require('./isArray');\n\n/**\n * Iterates over elements of `collection` and invokes `iteratee` for each element.\n * The iteratee is invoked with three arguments: (value, index|key, collection).\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n * property are iterated like arrays. To avoid this behavior use `_.forIn`\n * or `_.forOwn` for object iteration.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @alias each\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n * @see _.forEachRight\n * @example\n *\n * _.forEach([1, 2], function(value) {\n *   console.log(value);\n * });\n * // => Logs `1` then `2`.\n *\n * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n *   console.log(key);\n * });\n * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n */\nfunction forEach(collection, iteratee) {\n  var func = isArray(collection) ? arrayEach : baseEach;\n  return func(collection, castFunction(iteratee));\n}\n\nmodule.exports = forEach;\n","var arrayMap = require('./_arrayMap'),\n    baseIteratee = require('./_baseIteratee'),\n    baseMap = require('./_baseMap'),\n    isArray = require('./isArray');\n\n/**\n * Creates an array of values by running each element in `collection` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n *\n * The guarded methods are:\n * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n * @example\n *\n * function square(n) {\n *   return n * n;\n * }\n *\n * _.map([4, 8], square);\n * // => [16, 64]\n *\n * _.map({ 'a': 4, 'b': 8 }, square);\n * // => [16, 64] (iteration order is not guaranteed)\n *\n * var users = [\n *   { 'user': 'barney' },\n *   { 'user': 'fred' }\n * ];\n *\n * // The `_.property` iteratee shorthand.\n * _.map(users, 'user');\n * // => ['barney', 'fred']\n */\nfunction map(collection, iteratee) {\n  var func = isArray(collection) ? arrayMap : baseMap;\n  return func(collection, baseIteratee(iteratee, 3));\n}\n\nmodule.exports = map;\n","var baseEach = require('./_baseEach'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\nmodule.exports = baseMap;\n","var baseExtremum = require('./_baseExtremum'),\n    baseLt = require('./_baseLt'),\n    identity = require('./identity');\n\n/**\n * Computes the minimum value of `array`. If `array` is empty or falsey,\n * `undefined` is returned.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {*} Returns the minimum value.\n * @example\n *\n * _.min([4, 2, 8, 6]);\n * // => 2\n *\n * _.min([]);\n * // => undefined\n */\nfunction min(array) {\n  return (array && array.length)\n    ? baseExtremum(array, identity, baseLt)\n    : undefined;\n}\n\nmodule.exports = min;\n","var baseFlatten = require('./_baseFlatten'),\n    baseOrderBy = require('./_baseOrderBy'),\n    baseRest = require('./_baseRest'),\n    isIterateeCall = require('./_isIterateeCall');\n\n/**\n * Creates an array of elements, sorted in ascending order by the results of\n * running each element in a collection thru each iteratee. This method\n * performs a stable sort, that is, it preserves the original sort order of\n * equal elements. The iteratees are invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {...(Function|Function[])} [iteratees=[_.identity]]\n *  The iteratees to sort by.\n * @returns {Array} Returns the new sorted array.\n * @example\n *\n * var users = [\n *   { 'user': 'fred',   'age': 48 },\n *   { 'user': 'barney', 'age': 36 },\n *   { 'user': 'fred',   'age': 40 },\n *   { 'user': 'barney', 'age': 34 }\n * ];\n *\n * _.sortBy(users, [function(o) { return o.user; }]);\n * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n *\n * _.sortBy(users, ['user', 'age']);\n * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]\n */\nvar sortBy = baseRest(function(collection, iteratees) {\n  if (collection == null) {\n    return [];\n  }\n  var length = iteratees.length;\n  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n    iteratees = [];\n  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n    iteratees = [iteratees[0]];\n  }\n  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n});\n\nmodule.exports = sortBy;\n","var toGeoJSON = (function() {\n    'use strict';\n\n    var removeSpace = /\\s*/g,\n        trimSpace = /^\\s*|\\s*$/g,\n        splitSpace = /\\s+/;\n    // generate a short, numeric hash of a string\n    function okhash(x) {\n        if (!x || !x.length) return 0;\n        for (var i = 0, h = 0; i < x.length; i++) {\n            h = ((h << 5) - h) + x.charCodeAt(i) | 0;\n        } return h;\n    }\n    // all Y children of X\n    function get(x, y) { return x.getElementsByTagName(y); }\n    function attr(x, y) { return x.getAttribute(y); }\n    function attrf(x, y) { return parseFloat(attr(x, y)); }\n    // one Y child of X, if any, otherwise null\n    function get1(x, y) { var n = get(x, y); return n.length ? n[0] : null; }\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node.normalize\n    function norm(el) { if (el.normalize) { el.normalize(); } return el; }\n    // cast array x into numbers\n    function numarray(x) {\n        for (var j = 0, o = []; j < x.length; j++) { o[j] = parseFloat(x[j]); }\n        return o;\n    }\n    // get the content of a text node, if any\n    function nodeVal(x) {\n        if (x) { norm(x); }\n        return (x && x.textContent) || '';\n    }\n    // get the contents of multiple text nodes, if present\n    function getMulti(x, ys) {\n        var o = {}, n, k;\n        for (k = 0; k < ys.length; k++) {\n            n = get1(x, ys[k]);\n            if (n) o[ys[k]] = nodeVal(n);\n        }\n        return o;\n    }\n    // add properties of Y to X, overwriting if present in both\n    function extend(x, y) { for (var k in y) x[k] = y[k]; }\n    // get one coordinate from a coordinate array, if any\n    function coord1(v) { return numarray(v.replace(removeSpace, '').split(',')); }\n    // get all coordinates from a coordinate array as [[],[]]\n    function coord(v) {\n        var coords = v.replace(trimSpace, '').split(splitSpace),\n            o = [];\n        for (var i = 0; i < coords.length; i++) {\n            o.push(coord1(coords[i]));\n        }\n        return o;\n    }\n    function coordPair(x) {\n        var ll = [attrf(x, 'lon'), attrf(x, 'lat')],\n            ele = get1(x, 'ele'),\n            // handle namespaced attribute in browser\n            heartRate = get1(x, 'gpxtpx:hr') || get1(x, 'hr'),\n            time = get1(x, 'time'),\n            e;\n        if (ele) {\n            e = parseFloat(nodeVal(ele));\n            if (!isNaN(e)) {\n                ll.push(e);\n            }\n        }\n        return {\n            coordinates: ll,\n            time: time ? nodeVal(time) : null,\n            heartRate: heartRate ? parseFloat(nodeVal(heartRate)) : null\n        };\n    }\n\n    // create a new feature collection parent object\n    function fc() {\n        return {\n            type: 'FeatureCollection',\n            features: []\n        };\n    }\n\n    var serializer;\n    if (typeof XMLSerializer !== 'undefined') {\n        /* istanbul ignore next */\n        serializer = new XMLSerializer();\n    // only require xmldom in a node environment\n    } else if (typeof exports === 'object' && typeof process === 'object' && !process.browser) {\n        serializer = new (require('xmldom').XMLSerializer)();\n    }\n    function xml2str(str) {\n        // IE9 will create a new XMLSerializer but it'll crash immediately.\n        // This line is ignored because we don't run coverage tests in IE9\n        /* istanbul ignore next */\n        if (str.xml !== undefined) return str.xml;\n        return serializer.serializeToString(str);\n    }\n\n    var t = {\n        kml: function(doc) {\n\n            var gj = fc(),\n                // styleindex keeps track of hashed styles in order to match features\n                styleIndex = {}, styleByHash = {},\n                // stylemapindex keeps track of style maps to expose in properties\n                styleMapIndex = {},\n                // atomic geospatial types supported by KML - MultiGeometry is\n                // handled separately\n                geotypes = ['Polygon', 'LineString', 'Point', 'Track', 'gx:Track'],\n                // all root placemarks in the file\n                placemarks = get(doc, 'Placemark'),\n                styles = get(doc, 'Style'),\n                styleMaps = get(doc, 'StyleMap');\n\n            for (var k = 0; k < styles.length; k++) {\n                var hash = okhash(xml2str(styles[k])).toString(16);\n                styleIndex['#' + attr(styles[k], 'id')] = hash;\n                styleByHash[hash] = styles[k];\n            }\n            for (var l = 0; l < styleMaps.length; l++) {\n                styleIndex['#' + attr(styleMaps[l], 'id')] = okhash(xml2str(styleMaps[l])).toString(16);\n                var pairs = get(styleMaps[l], 'Pair');\n                var pairsMap = {};\n                for (var m = 0; m < pairs.length; m++) {\n                    pairsMap[nodeVal(get1(pairs[m], 'key'))] = nodeVal(get1(pairs[m], 'styleUrl'));\n                }\n                styleMapIndex['#' + attr(styleMaps[l], 'id')] = pairsMap;\n\n            }\n            for (var j = 0; j < placemarks.length; j++) {\n                gj.features = gj.features.concat(getPlacemark(placemarks[j]));\n            }\n            function kmlColor(v) {\n                var color, opacity;\n                v = v || '';\n                if (v.substr(0, 1) === '#') { v = v.substr(1); }\n                if (v.length === 6 || v.length === 3) { color = v; }\n                if (v.length === 8) {\n                    opacity = parseInt(v.substr(0, 2), 16) / 255;\n                    color = '#' + v.substr(6, 2) +\n                        v.substr(4, 2) +\n                        v.substr(2, 2);\n                }\n                return [color, isNaN(opacity) ? undefined : opacity];\n            }\n            function gxCoord(v) { return numarray(v.split(' ')); }\n            function gxCoords(root) {\n                var elems = get(root, 'coord', 'gx'), coords = [], times = [];\n                if (elems.length === 0) elems = get(root, 'gx:coord');\n                for (var i = 0; i < elems.length; i++) coords.push(gxCoord(nodeVal(elems[i])));\n                var timeElems = get(root, 'when');\n                for (var j = 0; j < timeElems.length; j++) times.push(nodeVal(timeElems[j]));\n                return {\n                    coords: coords,\n                    times: times\n                };\n            }\n            function getGeometry(root) {\n                var geomNode, geomNodes, i, j, k, geoms = [], coordTimes = [];\n                if (get1(root, 'MultiGeometry')) { return getGeometry(get1(root, 'MultiGeometry')); }\n                if (get1(root, 'MultiTrack')) { return getGeometry(get1(root, 'MultiTrack')); }\n                if (get1(root, 'gx:MultiTrack')) { return getGeometry(get1(root, 'gx:MultiTrack')); }\n                for (i = 0; i < geotypes.length; i++) {\n                    geomNodes = get(root, geotypes[i]);\n                    if (geomNodes) {\n                        for (j = 0; j < geomNodes.length; j++) {\n                            geomNode = geomNodes[j];\n                            if (geotypes[i] === 'Point') {\n                                geoms.push({\n                                    type: 'Point',\n                                    coordinates: coord1(nodeVal(get1(geomNode, 'coordinates')))\n                                });\n                            } else if (geotypes[i] === 'LineString') {\n                                geoms.push({\n                                    type: 'LineString',\n                                    coordinates: coord(nodeVal(get1(geomNode, 'coordinates')))\n                                });\n                            } else if (geotypes[i] === 'Polygon') {\n                                var rings = get(geomNode, 'LinearRing'),\n                                    coords = [];\n                                for (k = 0; k < rings.length; k++) {\n                                    coords.push(coord(nodeVal(get1(rings[k], 'coordinates'))));\n                                }\n                                geoms.push({\n                                    type: 'Polygon',\n                                    coordinates: coords\n                                });\n                            } else if (geotypes[i] === 'Track' ||\n                                geotypes[i] === 'gx:Track') {\n                                var track = gxCoords(geomNode);\n                                geoms.push({\n                                    type: 'LineString',\n                                    coordinates: track.coords\n                                });\n                                if (track.times.length) coordTimes.push(track.times);\n                            }\n                        }\n                    }\n                }\n                return {\n                    geoms: geoms,\n                    coordTimes: coordTimes\n                };\n            }\n            function getPlacemark(root) {\n                var geomsAndTimes = getGeometry(root), i, properties = {},\n                    name = nodeVal(get1(root, 'name')),\n                    styleUrl = nodeVal(get1(root, 'styleUrl')),\n                    description = nodeVal(get1(root, 'description')),\n                    timeSpan = get1(root, 'TimeSpan'),\n                    timeStamp = get1(root, 'TimeStamp'),\n                    extendedData = get1(root, 'ExtendedData'),\n                    lineStyle = get1(root, 'LineStyle'),\n                    polyStyle = get1(root, 'PolyStyle'),\n                    visibility = get1(root, 'visibility');\n\n                if (!geomsAndTimes.geoms.length) return [];\n                if (name) properties.name = name;\n                if (styleUrl) {\n                    if (styleUrl[0] !== '#') {\n                        styleUrl = '#' + styleUrl;\n                    }\n\n                    properties.styleUrl = styleUrl;\n                    if (styleIndex[styleUrl]) {\n                        properties.styleHash = styleIndex[styleUrl];\n                    }\n                    if (styleMapIndex[styleUrl]) {\n                        properties.styleMapHash = styleMapIndex[styleUrl];\n                        properties.styleHash = styleIndex[styleMapIndex[styleUrl].normal];\n                    }\n                    // Try to populate the lineStyle or polyStyle since we got the style hash\n                    var style = styleByHash[properties.styleHash];\n                    if (style) {\n                        if (!lineStyle) lineStyle = get1(style, 'LineStyle');\n                        if (!polyStyle) polyStyle = get1(style, 'PolyStyle');\n                    }\n                }\n                if (description) properties.description = description;\n                if (timeSpan) {\n                    var begin = nodeVal(get1(timeSpan, 'begin'));\n                    var end = nodeVal(get1(timeSpan, 'end'));\n                    properties.timespan = { begin: begin, end: end };\n                }\n                if (timeStamp) {\n                    properties.timestamp = nodeVal(get1(timeStamp, 'when'));\n                }\n                if (lineStyle) {\n                    var linestyles = kmlColor(nodeVal(get1(lineStyle, 'color'))),\n                        color = linestyles[0],\n                        opacity = linestyles[1],\n                        width = parseFloat(nodeVal(get1(lineStyle, 'width')));\n                    if (color) properties.stroke = color;\n                    if (!isNaN(opacity)) properties['stroke-opacity'] = opacity;\n                    if (!isNaN(width)) properties['stroke-width'] = width;\n                }\n                if (polyStyle) {\n                    var polystyles = kmlColor(nodeVal(get1(polyStyle, 'color'))),\n                        pcolor = polystyles[0],\n                        popacity = polystyles[1],\n                        fill = nodeVal(get1(polyStyle, 'fill')),\n                        outline = nodeVal(get1(polyStyle, 'outline'));\n                    if (pcolor) properties.fill = pcolor;\n                    if (!isNaN(popacity)) properties['fill-opacity'] = popacity;\n                    if (fill) properties['fill-opacity'] = fill === '1' ? properties['fill-opacity'] || 1 : 0;\n                    if (outline) properties['stroke-opacity'] = outline === '1' ? properties['stroke-opacity'] || 1 : 0;\n                }\n                if (extendedData) {\n                    var datas = get(extendedData, 'Data'),\n                        simpleDatas = get(extendedData, 'SimpleData');\n\n                    for (i = 0; i < datas.length; i++) {\n                        properties[datas[i].getAttribute('name')] = nodeVal(get1(datas[i], 'value'));\n                    }\n                    for (i = 0; i < simpleDatas.length; i++) {\n                        properties[simpleDatas[i].getAttribute('name')] = nodeVal(simpleDatas[i]);\n                    }\n                }\n                if (visibility) {\n                    properties.visibility = nodeVal(visibility);\n                }\n                if (geomsAndTimes.coordTimes.length) {\n                    properties.coordTimes = (geomsAndTimes.coordTimes.length === 1) ?\n                        geomsAndTimes.coordTimes[0] : geomsAndTimes.coordTimes;\n                }\n                var feature = {\n                    type: 'Feature',\n                    geometry: (geomsAndTimes.geoms.length === 1) ? geomsAndTimes.geoms[0] : {\n                        type: 'GeometryCollection',\n                        geometries: geomsAndTimes.geoms\n                    },\n                    properties: properties\n                };\n                if (attr(root, 'id')) feature.id = attr(root, 'id');\n                return [feature];\n            }\n            return gj;\n        },\n        gpx: function(doc) {\n            var i,\n                tracks = get(doc, 'trk'),\n                routes = get(doc, 'rte'),\n                waypoints = get(doc, 'wpt'),\n                // a feature collection\n                gj = fc(),\n                feature;\n            for (i = 0; i < tracks.length; i++) {\n                feature = getTrack(tracks[i]);\n                if (feature) gj.features.push(feature);\n            }\n            for (i = 0; i < routes.length; i++) {\n                feature = getRoute(routes[i]);\n                if (feature) gj.features.push(feature);\n            }\n            for (i = 0; i < waypoints.length; i++) {\n                gj.features.push(getPoint(waypoints[i]));\n            }\n            function getPoints(node, pointname) {\n                var pts = get(node, pointname),\n                    line = [],\n                    times = [],\n                    heartRates = [],\n                    l = pts.length;\n                if (l < 2) return {};  // Invalid line in GeoJSON\n                for (var i = 0; i < l; i++) {\n                    var c = coordPair(pts[i]);\n                    line.push(c.coordinates);\n                    if (c.time) times.push(c.time);\n                    if (c.heartRate) heartRates.push(c.heartRate);\n                }\n                return {\n                    line: line,\n                    times: times,\n                    heartRates: heartRates\n                };\n            }\n            function getTrack(node) {\n                var segments = get(node, 'trkseg'),\n                    track = [],\n                    times = [],\n                    heartRates = [],\n                    line;\n                for (var i = 0; i < segments.length; i++) {\n                    line = getPoints(segments[i], 'trkpt');\n                    if (line) {\n                        if (line.line) track.push(line.line);\n                        if (line.times && line.times.length) times.push(line.times);\n                        if (line.heartRates && line.heartRates.length) heartRates.push(line.heartRates);\n                    }\n                }\n                if (track.length === 0) return;\n                var properties = getProperties(node);\n                if (times.length) properties.coordTimes = track.length === 1 ? times[0] : times;\n                if (heartRates.length) properties.heartRates = track.length === 1 ? heartRates[0] : heartRates;\n                return {\n                    type: 'Feature',\n                    properties: properties,\n                    geometry: {\n                        type: track.length === 1 ? 'LineString' : 'MultiLineString',\n                        coordinates: track.length === 1 ? track[0] : track\n                    }\n                };\n            }\n            function getRoute(node) {\n                var line = getPoints(node, 'rtept');\n                if (!line.line) return;\n                var routeObj = {\n                    type: 'Feature',\n                    properties: getProperties(node),\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: line.line\n                    }\n                };\n                return routeObj;\n            }\n            function getPoint(node) {\n                var prop = getProperties(node);\n                extend(prop, getMulti(node, ['sym', 'type']));\n                return {\n                    type: 'Feature',\n                    properties: prop,\n                    geometry: {\n                        type: 'Point',\n                        coordinates: coordPair(node).coordinates\n                    }\n                };\n            }\n            function getProperties(node) {\n                var prop, links;\n                prop = getMulti(node, ['name', 'cmt', 'desc', 'time', 'keywords']);\n                links = get(node, 'link');\n                if (links.length) prop.links = [];\n                for (var i = 0, link; i < links.length; i++) {\n                    link = { href: attr(links[i], 'href') };\n                    extend(link, getMulti(links[i], ['text', 'type']));\n                    prop.links.push(link);\n                }\n                return prop;\n            }\n            return gj;\n        }\n    };\n    return t;\n})();\n\nif (typeof module !== 'undefined') module.exports = toGeoJSON;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar distance_1 = __importDefault(require(\"@turf/distance\"));\nvar meta_1 = require(\"@turf/meta\");\n/**\n * Takes a {@link GeoJSON} and measures its length in the specified units, {@link (Multi)Point}'s distance are ignored.\n *\n * @name length\n * @param {Feature<LineString|MultiLineString>} geojson GeoJSON to measure\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units=kilometers] can be degrees, radians, miles, or kilometers\n * @returns {number} length of GeoJSON\n * @example\n * var line = turf.lineString([[115, -32], [131, -22], [143, -25], [150, -34]]);\n * var length = turf.length(line, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line];\n * line.properties.distance = length;\n */\nfunction length(geojson, options) {\n    if (options === void 0) { options = {}; }\n    // Calculate distance from 2-vertex line segments\n    return meta_1.segmentReduce(geojson, function (previousValue, segment) {\n        var coords = segment.geometry.coordinates;\n        return previousValue + distance_1.default(coords[0], coords[1], options);\n    }, 0);\n}\nexports.default = length;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bearing_1 = require(\"@turf/bearing\");\nvar distance_1 = require(\"@turf/distance\");\nvar destination_1 = require(\"@turf/destination\");\nvar line_intersect_1 = require(\"@turf/line-intersect\");\nvar meta_1 = require(\"@turf/meta\");\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the (Multi)LineString.\n *\n * @name nearestPointOnLine\n * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to\n * @param {Geometry|Feature<Point>|number[]} pt point to snap from\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain three values: `index`: closest point was found on nth line part, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.\n * @example\n * var line = turf.lineString([\n *     [-77.031669, 38.878605],\n *     [-77.029609, 38.881946],\n *     [-77.020339, 38.884084],\n *     [-77.025661, 38.885821],\n *     [-77.021884, 38.889563],\n *     [-77.019824, 38.892368]\n * ]);\n * var pt = turf.point([-77.037076, 38.884017]);\n *\n * var snapped = turf.nearestPointOnLine(line, pt, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line, pt, snapped];\n * snapped.properties['marker-color'] = '#00f';\n */\nfunction nearestPointOnLine(lines, pt, options) {\n    if (options === void 0) { options = {}; }\n    var closestPt = helpers_1.point([Infinity, Infinity], {\n        dist: Infinity\n    });\n    var length = 0.0;\n    meta_1.flattenEach(lines, function (line) {\n        var coords = invariant_1.getCoords(line);\n        for (var i = 0; i < coords.length - 1; i++) {\n            //start\n            var start = helpers_1.point(coords[i]);\n            start.properties.dist = distance_1.default(pt, start, options);\n            //stop\n            var stop_1 = helpers_1.point(coords[i + 1]);\n            stop_1.properties.dist = distance_1.default(pt, stop_1, options);\n            // sectionLength\n            var sectionLength = distance_1.default(start, stop_1, options);\n            //perpendicular\n            var heightDistance = Math.max(start.properties.dist, stop_1.properties.dist);\n            var direction = bearing_1.default(start, stop_1);\n            var perpendicularPt1 = destination_1.default(pt, heightDistance, direction + 90, options);\n            var perpendicularPt2 = destination_1.default(pt, heightDistance, direction - 90, options);\n            var intersect = line_intersect_1.default(helpers_1.lineString([perpendicularPt1.geometry.coordinates, perpendicularPt2.geometry.coordinates]), helpers_1.lineString([start.geometry.coordinates, stop_1.geometry.coordinates]));\n            var intersectPt = null;\n            if (intersect.features.length > 0) {\n                intersectPt = intersect.features[0];\n                intersectPt.properties.dist = distance_1.default(pt, intersectPt, options);\n                intersectPt.properties.location = length + distance_1.default(start, intersectPt, options);\n            }\n            if (start.properties.dist < closestPt.properties.dist) {\n                closestPt = start;\n                closestPt.properties.index = i;\n                closestPt.properties.location = length;\n            }\n            if (stop_1.properties.dist < closestPt.properties.dist) {\n                closestPt = stop_1;\n                closestPt.properties.index = i + 1;\n                closestPt.properties.location = length + sectionLength;\n            }\n            if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {\n                closestPt = intersectPt;\n                closestPt.properties.index = i;\n            }\n            // update length\n            length += sectionLength;\n        }\n    });\n    return closestPt;\n}\nexports.default = nearestPointOnLine;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Taken from http://geomalgorithms.com/a02-_lines.html\nvar distance_1 = __importDefault(require(\"@turf/distance\"));\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\nvar meta_1 = require(\"@turf/meta\");\nvar rhumb_distance_1 = __importDefault(require(\"@turf/rhumb-distance\"));\n/**\n * Returns the minimum distance between a {@link Point} and a {@link LineString}, being the distance from a line the\n * minimum distance between the point and any segment of the `LineString`.\n *\n * @name pointToLineDistance\n * @param {Feature<Point>|Array<number>} pt Feature or Geometry\n * @param {Feature<LineString>} line GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units=\"kilometers\"] can be anything supported by turf/convertLength\n * (ex: degrees, radians, miles, or kilometers)\n * @param {string} [options.method=\"geodesic\"] wether to calculate the distance based on geodesic (spheroid) or\n * planar (flat) method. Valid options are 'geodesic' or 'planar'.\n * @returns {number} distance between point and line\n * @example\n * var pt = turf.point([0, 0]);\n * var line = turf.lineString([[1, 1],[-1, 1]]);\n *\n * var distance = turf.pointToLineDistance(pt, line, {units: 'miles'});\n * //=69.11854715938406\n */\nfunction pointToLineDistance(pt, line, options) {\n    if (options === void 0) { options = {}; }\n    // Optional parameters\n    if (!options.method) {\n        options.method = \"geodesic\";\n    }\n    if (!options.units) {\n        options.units = \"kilometers\";\n    }\n    // validation\n    if (!pt) {\n        throw new Error(\"pt is required\");\n    }\n    if (Array.isArray(pt)) {\n        pt = helpers_1.point(pt);\n    }\n    else if (pt.type === \"Point\") {\n        pt = helpers_1.feature(pt);\n    }\n    else {\n        invariant_1.featureOf(pt, \"Point\", \"point\");\n    }\n    if (!line) {\n        throw new Error(\"line is required\");\n    }\n    if (Array.isArray(line)) {\n        line = helpers_1.lineString(line);\n    }\n    else if (line.type === \"LineString\") {\n        line = helpers_1.feature(line);\n    }\n    else {\n        invariant_1.featureOf(line, \"LineString\", \"line\");\n    }\n    var distance = Infinity;\n    var p = pt.geometry.coordinates;\n    meta_1.segmentEach(line, function (segment) {\n        var a = segment.geometry.coordinates[0];\n        var b = segment.geometry.coordinates[1];\n        var d = distanceToSegment(p, a, b, options);\n        if (d < distance) {\n            distance = d;\n        }\n    });\n    return helpers_1.convertLength(distance, \"degrees\", options.units);\n}\n/**\n * Returns the distance between a point P on a segment AB.\n *\n * @private\n * @param {Array<number>} p external point\n * @param {Array<number>} a first segment point\n * @param {Array<number>} b second segment point\n * @param {Object} [options={}] Optional parameters\n * @returns {number} distance\n */\nfunction distanceToSegment(p, a, b, options) {\n    var v = [b[0] - a[0], b[1] - a[1]];\n    var w = [p[0] - a[0], p[1] - a[1]];\n    var c1 = dot(w, v);\n    if (c1 <= 0) {\n        return calcDistance(p, a, { method: options.method, units: \"degrees\" });\n    }\n    var c2 = dot(v, v);\n    if (c2 <= c1) {\n        return calcDistance(p, b, { method: options.method, units: \"degrees\" });\n    }\n    var b2 = c1 / c2;\n    var Pb = [a[0] + (b2 * v[0]), a[1] + (b2 * v[1])];\n    return calcDistance(p, Pb, { method: options.method, units: \"degrees\" });\n}\nfunction dot(u, v) {\n    return (u[0] * v[0] + u[1] * v[1]);\n}\nfunction calcDistance(a, b, options) {\n    return options.method === \"planar\" ? rhumb_distance_1.default(a, b, options) : distance_1.default(a, b, options);\n}\nexports.default = pointToLineDistance;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var overArg = require('./_overArg');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nmodule.exports = DataView;\n","var isFunction = require('./isFunction'),\n    isMasked = require('./_isMasked'),\n    isObject = require('./isObject'),\n    toSource = require('./_toSource');\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","var coreJsData = require('./_coreJsData');\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n","var root = require('./_root');\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nmodule.exports = Promise;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nmodule.exports = Set;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nmodule.exports = WeakMap;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n","/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n","var baseGetTag = require('./_baseGetTag'),\n    isLength = require('./isLength'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n","var Stack = require('./_Stack'),\n    equalArrays = require('./_equalArrays'),\n    equalByTag = require('./_equalByTag'),\n    equalObjects = require('./_equalObjects'),\n    getTag = require('./_getTag'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\nmodule.exports = baseIsEqualDeep;\n","/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n","var ListCache = require('./_ListCache');\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\nmodule.exports = stackClear;\n","/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\nmodule.exports = stackDelete;\n","/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nmodule.exports = stackGet;\n","/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nmodule.exports = stackHas;\n","var ListCache = require('./_ListCache'),\n    Map = require('./_Map'),\n    MapCache = require('./_MapCache');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nmodule.exports = stackSet;\n","var Hash = require('./_Hash'),\n    ListCache = require('./_ListCache'),\n    Map = require('./_Map');\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n","var hashClear = require('./_hashClear'),\n    hashDelete = require('./_hashDelete'),\n    hashGet = require('./_hashGet'),\n    hashHas = require('./_hashHas'),\n    hashSet = require('./_hashSet');\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n","var nativeCreate = require('./_nativeCreate');\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n","/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n","var getMapData = require('./_getMapData');\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n","/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n","var getMapData = require('./_getMapData');\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n","var getMapData = require('./_getMapData');\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n","var getMapData = require('./_getMapData');\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n","var MapCache = require('./_MapCache'),\n    setCacheAdd = require('./_setCacheAdd'),\n    setCacheHas = require('./_setCacheHas');\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\nmodule.exports = SetCache;\n","/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\nmodule.exports = setCacheAdd;\n","/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\nmodule.exports = setCacheHas;\n","/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arraySome;\n","/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\nmodule.exports = cacheHas;\n","var Symbol = require('./_Symbol'),\n    Uint8Array = require('./_Uint8Array'),\n    eq = require('./eq'),\n    equalArrays = require('./_equalArrays'),\n    mapToArray = require('./_mapToArray'),\n    setToArray = require('./_setToArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]';\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\nmodule.exports = equalByTag;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Uint8Array = root.Uint8Array;\n\nmodule.exports = Uint8Array;\n","/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\nmodule.exports = mapToArray;\n","/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nmodule.exports = setToArray;\n","var getAllKeys = require('./_getAllKeys');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalObjects;\n","var baseGetAllKeys = require('./_baseGetAllKeys'),\n    getSymbols = require('./_getSymbols'),\n    keys = require('./keys');\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\nmodule.exports = getAllKeys;\n","var arrayPush = require('./_arrayPush'),\n    isArray = require('./isArray');\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\nmodule.exports = baseGetAllKeys;\n","var arrayFilter = require('./_arrayFilter'),\n    stubArray = require('./stubArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\nmodule.exports = getSymbols;\n","/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\nmodule.exports = stubArray;\n","var baseTimes = require('./_baseTimes'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isIndex = require('./_isIndex'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n","/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n","var baseEach = require('./_baseEach');\n\n/**\n * The base implementation of `_.filter` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction baseFilter(collection, predicate) {\n  var result = [];\n  baseEach(collection, function(value, index, collection) {\n    if (predicate(value, index, collection)) {\n      result.push(value);\n    }\n  });\n  return result;\n}\n\nmodule.exports = baseFilter;\n","var baseFor = require('./_baseFor'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n","var createBaseFor = require('./_createBaseFor');\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n","/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n","var isArrayLike = require('./isArrayLike');\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\nmodule.exports = createBaseEach;\n","var baseIsMatch = require('./_baseIsMatch'),\n    getMatchData = require('./_getMatchData'),\n    matchesStrictComparable = require('./_matchesStrictComparable');\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\nmodule.exports = baseMatches;\n","var Stack = require('./_Stack'),\n    baseIsEqual = require('./_baseIsEqual');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nmodule.exports = baseIsMatch;\n","var isStrictComparable = require('./_isStrictComparable'),\n    keys = require('./keys');\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\nmodule.exports = getMatchData;\n","var baseIsEqual = require('./_baseIsEqual'),\n    get = require('./get'),\n    hasIn = require('./hasIn'),\n    isKey = require('./_isKey'),\n    isStrictComparable = require('./_isStrictComparable'),\n    matchesStrictComparable = require('./_matchesStrictComparable'),\n    toKey = require('./_toKey');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\nmodule.exports = baseMatchesProperty;\n","var memoizeCapped = require('./_memoizeCapped');\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nmodule.exports = stringToPath;\n","var memoize = require('./memoize');\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nmodule.exports = memoizeCapped;\n","var MapCache = require('./_MapCache');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n","var baseToString = require('./_baseToString');\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nmodule.exports = toString;\n","var Symbol = require('./_Symbol'),\n    arrayMap = require('./_arrayMap'),\n    isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = baseToString;\n","var baseHasIn = require('./_baseHasIn'),\n    hasPath = require('./_hasPath');\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\nmodule.exports = hasIn;\n","/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\nmodule.exports = baseHasIn;\n","var castPath = require('./_castPath'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isIndex = require('./_isIndex'),\n    isLength = require('./isLength'),\n    toKey = require('./_toKey');\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\nmodule.exports = hasPath;\n","var baseProperty = require('./_baseProperty'),\n    basePropertyDeep = require('./_basePropertyDeep'),\n    isKey = require('./_isKey'),\n    toKey = require('./_toKey');\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nmodule.exports = property;\n","/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = baseProperty;\n","var baseGet = require('./_baseGet');\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\nmodule.exports = basePropertyDeep;\n","var baseIteratee = require('./_baseIteratee'),\n    isArrayLike = require('./isArrayLike'),\n    keys = require('./keys');\n\n/**\n * Creates a `_.find` or `_.findLast` function.\n *\n * @private\n * @param {Function} findIndexFunc The function to find the collection index.\n * @returns {Function} Returns the new find function.\n */\nfunction createFind(findIndexFunc) {\n  return function(collection, predicate, fromIndex) {\n    var iterable = Object(collection);\n    if (!isArrayLike(collection)) {\n      var iteratee = baseIteratee(predicate, 3);\n      collection = keys(collection);\n      predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n    }\n    var index = findIndexFunc(collection, predicate, fromIndex);\n    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n  };\n}\n\nmodule.exports = createFind;\n","var baseFindIndex = require('./_baseFindIndex'),\n    baseIteratee = require('./_baseIteratee'),\n    toInteger = require('./toInteger');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\n * // => 0\n *\n * // The `_.matches` iteratee shorthand.\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findIndex(users, ['active', false]);\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.findIndex(users, 'active');\n * // => 2\n */\nfunction findIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index);\n}\n\nmodule.exports = findIndex;\n","/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = baseFindIndex;\n","var toFinite = require('./toFinite');\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nmodule.exports = toInteger;\n","var toNumber = require('./toNumber');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nmodule.exports = toFinite;\n","var isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n","/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n","var identity = require('./identity');\n\n/**\n * Casts `value` to `identity` if it's not a function.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Function} Returns cast function.\n */\nfunction castFunction(value) {\n  return typeof value == 'function' ? value : identity;\n}\n\nmodule.exports = castFunction;\n","var isSymbol = require('./isSymbol');\n\n/**\n * The base implementation of methods like `_.max` and `_.min` which accepts a\n * `comparator` to determine the extremum value.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The iteratee invoked per iteration.\n * @param {Function} comparator The comparator used to compare values.\n * @returns {*} Returns the extremum value.\n */\nfunction baseExtremum(array, iteratee, comparator) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    var value = array[index],\n        current = iteratee(value);\n\n    if (current != null && (computed === undefined\n          ? (current === current && !isSymbol(current))\n          : comparator(current, computed)\n        )) {\n      var computed = current,\n          result = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseExtremum;\n","/**\n * The base implementation of `_.lt` which doesn't coerce arguments.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if `value` is less than `other`,\n *  else `false`.\n */\nfunction baseLt(value, other) {\n  return value < other;\n}\n\nmodule.exports = baseLt;\n","var arrayPush = require('./_arrayPush'),\n    isFlattenable = require('./_isFlattenable');\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseFlatten;\n","var Symbol = require('./_Symbol'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray');\n\n/** Built-in value references. */\nvar spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\nmodule.exports = isFlattenable;\n","var arrayMap = require('./_arrayMap'),\n    baseIteratee = require('./_baseIteratee'),\n    baseMap = require('./_baseMap'),\n    baseSortBy = require('./_baseSortBy'),\n    baseUnary = require('./_baseUnary'),\n    compareMultiple = require('./_compareMultiple'),\n    identity = require('./identity');\n\n/**\n * The base implementation of `_.orderBy` without param guards.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n * @param {string[]} orders The sort orders of `iteratees`.\n * @returns {Array} Returns the new sorted array.\n */\nfunction baseOrderBy(collection, iteratees, orders) {\n  var index = -1;\n  iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));\n\n  var result = baseMap(collection, function(value, key, collection) {\n    var criteria = arrayMap(iteratees, function(iteratee) {\n      return iteratee(value);\n    });\n    return { 'criteria': criteria, 'index': ++index, 'value': value };\n  });\n\n  return baseSortBy(result, function(object, other) {\n    return compareMultiple(object, other, orders);\n  });\n}\n\nmodule.exports = baseOrderBy;\n","/**\n * The base implementation of `_.sortBy` which uses `comparer` to define the\n * sort order of `array` and replaces criteria objects with their corresponding\n * values.\n *\n * @private\n * @param {Array} array The array to sort.\n * @param {Function} comparer The function to define sort order.\n * @returns {Array} Returns `array`.\n */\nfunction baseSortBy(array, comparer) {\n  var length = array.length;\n\n  array.sort(comparer);\n  while (length--) {\n    array[length] = array[length].value;\n  }\n  return array;\n}\n\nmodule.exports = baseSortBy;\n","var compareAscending = require('./_compareAscending');\n\n/**\n * Used by `_.orderBy` to compare multiple properties of a value to another\n * and stable sort them.\n *\n * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n * of corresponding values.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {boolean[]|string[]} orders The order to sort by for each property.\n * @returns {number} Returns the sort order indicator for `object`.\n */\nfunction compareMultiple(object, other, orders) {\n  var index = -1,\n      objCriteria = object.criteria,\n      othCriteria = other.criteria,\n      length = objCriteria.length,\n      ordersLength = orders.length;\n\n  while (++index < length) {\n    var result = compareAscending(objCriteria[index], othCriteria[index]);\n    if (result) {\n      if (index >= ordersLength) {\n        return result;\n      }\n      var order = orders[index];\n      return result * (order == 'desc' ? -1 : 1);\n    }\n  }\n  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n  // that causes it, under certain circumstances, to provide the same value for\n  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n  // for more details.\n  //\n  // This also ensures a stable sort in V8 and other engines.\n  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n  return object.index - other.index;\n}\n\nmodule.exports = compareMultiple;\n","var isSymbol = require('./isSymbol');\n\n/**\n * Compares values to sort them in ascending order.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {number} Returns the sort order indicator for `value`.\n */\nfunction compareAscending(value, other) {\n  if (value !== other) {\n    var valIsDefined = value !== undefined,\n        valIsNull = value === null,\n        valIsReflexive = value === value,\n        valIsSymbol = isSymbol(value);\n\n    var othIsDefined = other !== undefined,\n        othIsNull = other === null,\n        othIsReflexive = other === other,\n        othIsSymbol = isSymbol(other);\n\n    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n        (valIsNull && othIsDefined && othIsReflexive) ||\n        (!valIsDefined && othIsReflexive) ||\n        !valIsReflexive) {\n      return 1;\n    }\n    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n        (othIsNull && valIsDefined && valIsReflexive) ||\n        (!othIsDefined && valIsReflexive) ||\n        !othIsReflexive) {\n      return -1;\n    }\n  }\n  return 0;\n}\n\nmodule.exports = compareAscending;\n","var identity = require('./identity'),\n    overRest = require('./_overRest'),\n    setToString = require('./_setToString');\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\nmodule.exports = baseRest;\n","var apply = require('./_apply');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\nmodule.exports = overRest;\n","/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\nmodule.exports = apply;\n","var baseSetToString = require('./_baseSetToString'),\n    shortOut = require('./_shortOut');\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\nmodule.exports = setToString;\n","var constant = require('./constant'),\n    defineProperty = require('./_defineProperty'),\n    identity = require('./identity');\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\nmodule.exports = baseSetToString;\n","/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\nmodule.exports = constant;\n","var getNative = require('./_getNative');\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nmodule.exports = defineProperty;\n","/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeNow = Date.now;\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\nmodule.exports = shortOut;\n","var eq = require('./eq'),\n    isArrayLike = require('./isArrayLike'),\n    isIndex = require('./_isIndex'),\n    isObject = require('./isObject');\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\nmodule.exports = isIterateeCall;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        var previousFeatureIndex = 0;\n        var previousMultiIndex = 0;\n        var prevGeomIndex = 0;\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n                previousCoords = currentCoord;\n                previousFeatureIndex = featureIndex;\n                previousMultiIndex = multiPartIndexCoord;\n                prevGeomIndex = geometryIndex;\n                segmentIndex = 0;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        if (feature.geometry === null) return;\n        var type = feature.geometry.type;\n        var coords = feature.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\n// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Takes two {@link Point|points} and finds the geographic bearing between them,\n * i.e. the angle measured in degrees from the north line (0 degrees)\n *\n * @name bearing\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.final=false] calculates the final bearing if true\n * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)\n * @example\n * var point1 = turf.point([-75.343, 39.984]);\n * var point2 = turf.point([-75.534, 39.123]);\n *\n * var bearing = turf.bearing(point1, point2);\n *\n * //addToMap\n * var addToMap = [point1, point2]\n * point1.properties['marker-color'] = '#f00'\n * point2.properties['marker-color'] = '#0f0'\n * point1.properties.bearing = bearing\n */\nfunction bearing(start, end, options) {\n    if (options === void 0) { options = {}; }\n    // Reverse calculation\n    if (options.final === true) {\n        return calculateFinalBearing(start, end);\n    }\n    var coordinates1 = invariant_1.getCoord(start);\n    var coordinates2 = invariant_1.getCoord(end);\n    var lon1 = helpers_1.degreesToRadians(coordinates1[0]);\n    var lon2 = helpers_1.degreesToRadians(coordinates2[0]);\n    var lat1 = helpers_1.degreesToRadians(coordinates1[1]);\n    var lat2 = helpers_1.degreesToRadians(coordinates2[1]);\n    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n    var b = Math.cos(lat1) * Math.sin(lat2) -\n        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n    return helpers_1.radiansToDegrees(Math.atan2(a, b));\n}\n/**\n * Calculates Final Bearing\n *\n * @private\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @returns {number} bearing\n */\nfunction calculateFinalBearing(start, end) {\n    // Swap start & end\n    var bear = bearing(end, start);\n    bear = (bear + 180) % 360;\n    return bear;\n}\nexports.default = bearing;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in\n * degrees, radians, miles, or kilometers; and bearing in degrees.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Coord} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {Object} [options.properties={}] Translate properties to Point\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.destination(point, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\nfunction destination(origin, distance, bearing, options) {\n    if (options === void 0) { options = {}; }\n    // Handle input\n    var coordinates1 = invariant_1.getCoord(origin);\n    var longitude1 = helpers_1.degreesToRadians(coordinates1[0]);\n    var latitude1 = helpers_1.degreesToRadians(coordinates1[1]);\n    var bearingRad = helpers_1.degreesToRadians(bearing);\n    var radians = helpers_1.lengthToRadians(distance, options.units);\n    // Main\n    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));\n    var longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n    var lng = helpers_1.radiansToDegrees(longitude2);\n    var lat = helpers_1.radiansToDegrees(latitude2);\n    return helpers_1.point([lng, lat], options.properties);\n}\nexports.default = destination;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\nvar line_segment_1 = __importDefault(require(\"@turf/line-segment\"));\nvar meta_1 = require(\"@turf/meta\");\nvar geojson_rbush_1 = __importDefault(require(\"geojson-rbush\"));\n/**\n * Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).\n *\n * @name lineIntersect\n * @param {GeoJSON} line1 any LineString or Polygon\n * @param {GeoJSON} line2 any LineString or Polygon\n * @returns {FeatureCollection<Point>} point(s) that intersect both\n * @example\n * var line1 = turf.lineString([[126, -11], [129, -21]]);\n * var line2 = turf.lineString([[123, -18], [131, -14]]);\n * var intersects = turf.lineIntersect(line1, line2);\n *\n * //addToMap\n * var addToMap = [line1, line2, intersects]\n */\nfunction lineIntersect(line1, line2) {\n    var unique = {};\n    var results = [];\n    // First, normalize geometries to features\n    // Then, handle simple 2-vertex segments\n    if (line1.type === \"LineString\") {\n        line1 = helpers_1.feature(line1);\n    }\n    if (line2.type === \"LineString\") {\n        line2 = helpers_1.feature(line2);\n    }\n    if (line1.type === \"Feature\" &&\n        line2.type === \"Feature\" &&\n        line1.geometry !== null &&\n        line2.geometry !== null &&\n        line1.geometry.type === \"LineString\" &&\n        line2.geometry.type === \"LineString\" &&\n        line1.geometry.coordinates.length === 2 &&\n        line2.geometry.coordinates.length === 2) {\n        var intersect = intersects(line1, line2);\n        if (intersect) {\n            results.push(intersect);\n        }\n        return helpers_1.featureCollection(results);\n    }\n    // Handles complex GeoJSON Geometries\n    var tree = geojson_rbush_1.default();\n    tree.load(line_segment_1.default(line2));\n    meta_1.featureEach(line_segment_1.default(line1), function (segment) {\n        meta_1.featureEach(tree.search(segment), function (match) {\n            var intersect = intersects(segment, match);\n            if (intersect) {\n                // prevent duplicate points https://github.com/Turfjs/turf/issues/688\n                var key = invariant_1.getCoords(intersect).join(\",\");\n                if (!unique[key]) {\n                    unique[key] = true;\n                    results.push(intersect);\n                }\n            }\n        });\n    });\n    return helpers_1.featureCollection(results);\n}\n/**\n * Find a point that intersects LineStrings with two coordinates each\n *\n * @private\n * @param {Feature<LineString>} line1 GeoJSON LineString (Must only contain 2 coordinates)\n * @param {Feature<LineString>} line2 GeoJSON LineString (Must only contain 2 coordinates)\n * @returns {Feature<Point>} intersecting GeoJSON Point\n */\nfunction intersects(line1, line2) {\n    var coords1 = invariant_1.getCoords(line1);\n    var coords2 = invariant_1.getCoords(line2);\n    if (coords1.length !== 2) {\n        throw new Error(\"<intersects> line1 must only contain 2 coordinates\");\n    }\n    if (coords2.length !== 2) {\n        throw new Error(\"<intersects> line2 must only contain 2 coordinates\");\n    }\n    var x1 = coords1[0][0];\n    var y1 = coords1[0][1];\n    var x2 = coords1[1][0];\n    var y2 = coords1[1][1];\n    var x3 = coords2[0][0];\n    var y3 = coords2[0][1];\n    var x4 = coords2[1][0];\n    var y4 = coords2[1][1];\n    var denom = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));\n    var numeA = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3));\n    var numeB = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3));\n    if (denom === 0) {\n        if (numeA === 0 && numeB === 0) {\n            return null;\n        }\n        return null;\n    }\n    var uA = numeA / denom;\n    var uB = numeB / denom;\n    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n        var x = x1 + (uA * (x2 - x1));\n        var y = y1 + (uA * (y2 - y1));\n        return helpers_1.point([x, y]);\n    }\n    return null;\n}\nexports.default = lineIntersect;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\nvar meta_1 = require(\"@turf/meta\");\n/**\n * Creates a {@link FeatureCollection} of 2-vertex {@link LineString} segments from a\n * {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon}.\n *\n * @name lineSegment\n * @param {GeoJSON} geojson GeoJSON Polygon or LineString\n * @returns {FeatureCollection<LineString>} 2-vertex line segments\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n * var segments = turf.lineSegment(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, segments]\n */\nfunction lineSegment(geojson) {\n    if (!geojson) {\n        throw new Error(\"geojson is required\");\n    }\n    var results = [];\n    meta_1.flattenEach(geojson, function (feature) {\n        lineSegmentFeature(feature, results);\n    });\n    return helpers_1.featureCollection(results);\n}\n/**\n * Line Segment\n *\n * @private\n * @param {Feature<LineString|Polygon>} geojson Line or polygon feature\n * @param {Array} results push to results\n * @returns {void}\n */\nfunction lineSegmentFeature(geojson, results) {\n    var coords = [];\n    var geometry = geojson.geometry;\n    if (geometry !== null) {\n        switch (geometry.type) {\n            case \"Polygon\":\n                coords = invariant_1.getCoords(geometry);\n                break;\n            case \"LineString\":\n                coords = [invariant_1.getCoords(geometry)];\n        }\n        coords.forEach(function (coord) {\n            var segments = createSegments(coord, geojson.properties);\n            segments.forEach(function (segment) {\n                segment.id = results.length;\n                results.push(segment);\n            });\n        });\n    }\n}\n/**\n * Create Segments from LineString coordinates\n *\n * @private\n * @param {Array<Array<number>>} coords LineString coordinates\n * @param {*} properties GeoJSON properties\n * @returns {Array<Feature<LineString>>} line segments\n */\nfunction createSegments(coords, properties) {\n    var segments = [];\n    coords.reduce(function (previousCoords, currentCoords) {\n        var segment = helpers_1.lineString([previousCoords, currentCoords], properties);\n        segment.bbox = bbox(previousCoords, currentCoords);\n        segments.push(segment);\n        return currentCoords;\n    });\n    return segments;\n}\n/**\n * Create BBox between two coordinates (faster than @turf/bbox)\n *\n * @private\n * @param {Array<number>} coords1 Point coordinate\n * @param {Array<number>} coords2 Point coordinate\n * @returns {BBox} [west, south, east, north]\n */\nfunction bbox(coords1, coords2) {\n    var x1 = coords1[0];\n    var y1 = coords1[1];\n    var x2 = coords2[0];\n    var y2 = coords2[1];\n    var west = (x1 < x2) ? x1 : x2;\n    var south = (y1 < y2) ? y1 : y2;\n    var east = (x1 > x2) ? x1 : x2;\n    var north = (y1 > y2) ? y1 : y2;\n    return [west, south, east, north];\n}\nexports.default = lineSegment;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        var previousFeatureIndex = 0;\n        var previousMultiIndex = 0;\n        var prevGeomIndex = 0;\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n                previousCoords = currentCoord;\n                previousFeatureIndex = featureIndex;\n                previousMultiIndex = multiPartIndexCoord;\n                prevGeomIndex = geometryIndex;\n                segmentIndex = 0;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        if (feature.geometry === null) return;\n        var type = feature.geometry.type;\n        var coords = feature.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        var previousFeatureIndex = 0;\n        var previousMultiIndex = 0;\n        var prevGeomIndex = 0;\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n                previousCoords = currentCoord;\n                previousFeatureIndex = featureIndex;\n                previousMultiIndex = multiPartIndexCoord;\n                prevGeomIndex = geometryIndex;\n                segmentIndex = 0;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        if (feature.geometry === null) return;\n        var type = feature.geometry.type;\n        var coords = feature.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n","var rbush = require('rbush');\nvar helpers = require('@turf/helpers');\nvar meta = require('@turf/meta');\nvar turfBBox = require('@turf/bbox').default;\nvar featureEach = meta.featureEach;\nvar coordEach = meta.coordEach;\nvar polygon = helpers.polygon;\nvar featureCollection = helpers.featureCollection;\n\n/**\n * GeoJSON implementation of [RBush](https://github.com/mourner/rbush#rbush) spatial index.\n *\n * @name rbush\n * @param {number} [maxEntries=9] defines the maximum number of entries in a tree node. 9 (used by default) is a\n * reasonable choice for most applications. Higher value means faster insertion and slower search, and vice versa.\n * @returns {RBush} GeoJSON RBush\n * @example\n * var geojsonRbush = require('geojson-rbush').default;\n * var tree = geojsonRbush();\n */\nfunction geojsonRbush(maxEntries) {\n    var tree = rbush(maxEntries);\n    /**\n     * [insert](https://github.com/mourner/rbush#data-format)\n     *\n     * @param {Feature} feature insert single GeoJSON Feature\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     * tree.insert(poly)\n     */\n    tree.insert = function (feature) {\n        if (feature.type !== 'Feature') throw new Error('invalid feature');\n        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        return rbush.prototype.insert.call(this, feature);\n    };\n\n    /**\n     * [load](https://github.com/mourner/rbush#bulk-inserting-data)\n     *\n     * @param {FeatureCollection|Array<Feature>} features load entire GeoJSON FeatureCollection\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polys = turf.polygons([\n     *     [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]],\n     *     [[[-93, 32], [-83, 32], [-83, 39], [-93, 39], [-93, 32]]]\n     * ]);\n     * tree.load(polys);\n     */\n    tree.load = function (features) {\n        var load = [];\n        // Load an Array of Features\n        if (Array.isArray(features)) {\n            features.forEach(function (feature) {\n                if (feature.type !== 'Feature') throw new Error('invalid features');\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        } else {\n            // Load a FeatureCollection\n            featureEach(features, function (feature) {\n                if (feature.type !== 'Feature') throw new Error('invalid features');\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        }\n        return rbush.prototype.load.call(this, load);\n    };\n\n    /**\n     * [remove](https://github.com/mourner/rbush#removing-data)\n     *\n     * @param {Feature} feature remove single GeoJSON Feature\n     * @param {Function} equals Pass a custom equals function to compare by value for removal.\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.remove(poly);\n     */\n    tree.remove = function (feature, equals) {\n        if (feature.type !== 'Feature') throw new Error('invalid feature');\n        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        return rbush.prototype.remove.call(this, feature, equals);\n    };\n\n    /**\n     * [clear](https://github.com/mourner/rbush#removing-data)\n     *\n     * @returns {RBush} GeoJSON Rbush\n     * @example\n     * tree.clear()\n     */\n    tree.clear = function () {\n        return rbush.prototype.clear.call(this);\n    };\n\n    /**\n     * [search](https://github.com/mourner/rbush#search)\n     *\n     * @param {BBox|FeatureCollection|Feature} geojson search with GeoJSON\n     * @returns {FeatureCollection} all features that intersects with the given GeoJSON.\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.search(poly);\n     */\n    tree.search = function (geojson) {\n        var features = rbush.prototype.search.call(this, this.toBBox(geojson));\n        return featureCollection(features);\n    };\n\n    /**\n     * [collides](https://github.com/mourner/rbush#collisions)\n     *\n     * @param {BBox|FeatureCollection|Feature} geojson collides with GeoJSON\n     * @returns {boolean} true if there are any items intersecting the given GeoJSON, otherwise false.\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.collides(poly);\n     */\n    tree.collides = function (geojson) {\n        return rbush.prototype.collides.call(this, this.toBBox(geojson));\n    };\n\n    /**\n     * [all](https://github.com/mourner/rbush#search)\n     *\n     * @returns {FeatureCollection} all the features in RBush\n     * @example\n     * tree.all()\n     */\n    tree.all = function () {\n        var features = rbush.prototype.all.call(this);\n        return featureCollection(features);\n    };\n\n    /**\n     * [toJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @returns {any} export data as JSON object\n     * @example\n     * var exported = tree.toJSON()\n     */\n    tree.toJSON = function () {\n        return rbush.prototype.toJSON.call(this);\n    };\n\n    /**\n     * [fromJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @param {any} json import previously exported data\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var exported = {\n     *   \"children\": [\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"geometry\": {\n     *         \"type\": \"Point\",\n     *         \"coordinates\": [110, 50]\n     *       },\n     *       \"properties\": {},\n     *       \"bbox\": [110, 50, 110, 50]\n     *     }\n     *   ],\n     *   \"height\": 1,\n     *   \"leaf\": true,\n     *   \"minX\": 110,\n     *   \"minY\": 50,\n     *   \"maxX\": 110,\n     *   \"maxY\": 50\n     * }\n     * tree.fromJSON(exported)\n     */\n    tree.fromJSON = function (json) {\n        return rbush.prototype.fromJSON.call(this, json);\n    };\n\n    /**\n     * Converts GeoJSON to {minX, minY, maxX, maxY} schema\n     *\n     * @private\n     * @param {BBox|FeatureCollection|Feature} geojson feature(s) to retrieve BBox from\n     * @returns {Object} converted to {minX, minY, maxX, maxY}\n     */\n    tree.toBBox = function (geojson) {\n        var bbox;\n        if (geojson.bbox) bbox = geojson.bbox;\n        else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;\n        else if (Array.isArray(geojson) && geojson.length === 6) bbox = [geojson[0], geojson[1], geojson[3], geojson[4]];\n        else if (geojson.type === 'Feature') bbox = turfBBox(geojson);\n        else if (geojson.type === 'FeatureCollection') bbox = turfBBox(geojson);\n        else throw new Error('invalid geojson')\n\n        return {\n            minX: bbox[0],\n            minY: bbox[1],\n            maxX: bbox[2],\n            maxY: bbox[3]\n        };\n    };\n    return tree;\n}\n\nmodule.exports = geojsonRbush;\nmodule.exports.default = geojsonRbush;\n","'use strict';\n\nmodule.exports = rbush;\nmodule.exports.default = rbush;\n\nvar quickselect = require('quickselect');\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.quickselect = factory());\n}(this, (function () { 'use strict';\n\nfunction quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nreturn quickselect;\n\n})));\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        var previousFeatureIndex = 0;\n        var previousMultiIndex = 0;\n        var prevGeomIndex = 0;\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n                previousCoords = currentCoord;\n                previousFeatureIndex = featureIndex;\n                previousMultiIndex = multiPartIndexCoord;\n                prevGeomIndex = geometryIndex;\n                segmentIndex = 0;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        if (feature.geometry === null) return;\n        var type = feature.geometry.type;\n        var coords = feature.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar meta_1 = require(\"@turf/meta\");\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n    var result = [Infinity, Infinity, -Infinity, -Infinity];\n    meta_1.coordEach(geojson, function (coord) {\n        if (result[0] > coord[0]) {\n            result[0] = coord[0];\n        }\n        if (result[1] > coord[1]) {\n            result[1] = coord[1];\n        }\n        if (result[2] < coord[0]) {\n            result[2] = coord[0];\n        }\n        if (result[3] < coord[1]) {\n            result[3] = coord[1];\n        }\n    });\n    return result;\n}\nexports.default = bbox;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        var previousFeatureIndex = 0;\n        var previousMultiIndex = 0;\n        var prevGeomIndex = 0;\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n                previousCoords = currentCoord;\n                previousFeatureIndex = featureIndex;\n                previousMultiIndex = multiPartIndexCoord;\n                prevGeomIndex = geometryIndex;\n                segmentIndex = 0;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        if (feature.geometry === null) return;\n        var type = feature.geometry.type;\n        var coords = feature.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        var previousFeatureIndex = 0;\n        var previousMultiIndex = 0;\n        var prevGeomIndex = 0;\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n                previousCoords = currentCoord;\n                previousFeatureIndex = featureIndex;\n                previousMultiIndex = multiPartIndexCoord;\n                prevGeomIndex = geometryIndex;\n                segmentIndex = 0;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        if (feature.geometry === null) return;\n        var type = feature.geometry.type;\n        var coords = feature.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        var previousFeatureIndex = 0;\n        var previousMultiIndex = 0;\n        var prevGeomIndex = 0;\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n                previousCoords = currentCoord;\n                previousFeatureIndex = featureIndex;\n                previousMultiIndex = multiPartIndexCoord;\n                prevGeomIndex = geometryIndex;\n                segmentIndex = 0;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        if (feature.geometry === null) return;\n        var type = feature.geometry.type;\n        var coords = feature.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// https://en.wikipedia.org/wiki/Rhumb_line\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Calculates the distance along a rhumb line between two {@link Point|points} in degrees, radians,\n * miles, or kilometers.\n *\n * @name rhumbDistance\n * @param {Coord} from origin point\n * @param {Coord} to destination point\n * @param {Object} [options] Optional parameters\n * @param {string} [options.units=\"kilometers\"] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.rhumbDistance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction rhumbDistance(from, to, options) {\n    if (options === void 0) { options = {}; }\n    var origin = invariant_1.getCoord(from);\n    var destination = invariant_1.getCoord(to);\n    // compensate the crossing of the 180th meridian (https://macwright.org/2016/09/26/the-180th-meridian.html)\n    // solution from https://github.com/mapbox/mapbox-gl-js/issues/3250#issuecomment-294887678\n    destination[0] += (destination[0] - origin[0] > 180) ? -360 : (origin[0] - destination[0] > 180) ? 360 : 0;\n    var distanceInMeters = calculateRhumbDistance(origin, destination);\n    var distance = helpers_1.convertLength(distanceInMeters, \"meters\", options.units);\n    return distance;\n}\n/**\n * Returns the distance travelling from this point to destination point along a rhumb line.\n * Adapted from Geodesy: https://github.com/chrisveness/geodesy/blob/master/latlon-spherical.js\n *\n * @private\n * @param   {Array<number>} origin point.\n * @param   {Array<number>} destination point.\n * @param   {number} [radius=6371e3] - (Mean) radius of earth (defaults to radius in metres).\n * @returns {number} Distance in km between this point and destination point (same units as radius).\n *\n * @example\n *     var p1 = new LatLon(51.127, 1.338);\n *     var p2 = new LatLon(50.964, 1.853);\n *     var d = p1.distanceTo(p2); // 40.31 km\n */\nfunction calculateRhumbDistance(origin, destination, radius) {\n    //  => phi\n    //  => lambda\n    //  => psi\n    //  => Delta\n    //  => delta\n    //  => theta\n    radius = (radius === undefined) ? helpers_1.earthRadius : Number(radius);\n    // see www.edwilliams.org/avform.htm#Rhumb\n    var R = radius;\n    var phi1 = origin[1] * Math.PI / 180;\n    var phi2 = destination[1] * Math.PI / 180;\n    var DeltaPhi = phi2 - phi1;\n    var DeltaLambda = Math.abs(destination[0] - origin[0]) * Math.PI / 180;\n    // if dLon over 180 take shorter rhumb line across the anti-meridian:\n    if (DeltaLambda > Math.PI) {\n        DeltaLambda -= 2 * Math.PI;\n    }\n    // on Mercator projection, longitude distances shrink by latitude; q is the 'stretch factor'\n    // q becomes ill-conditioned along E-W line (0/0); use empirical tolerance to avoid it\n    var DeltaPsi = Math.log(Math.tan(phi2 / 2 + Math.PI / 4) / Math.tan(phi1 / 2 + Math.PI / 4));\n    var q = Math.abs(DeltaPsi) > 10e-12 ? DeltaPhi / DeltaPsi : Math.cos(phi1);\n    // distance is pythagoras on 'stretched' Mercator projection\n    var delta = Math.sqrt(DeltaPhi * DeltaPhi + q * q * DeltaLambda * DeltaLambda); // angular distance in radians\n    var dist = delta * R;\n    return dist;\n}\nexports.default = rhumbDistance;\n","/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325,\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nvar unitsFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000,\n    millimetres: 1000,\n    centimeters: 100,\n    centimetres: 100,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    miles: 1 / 1609.344,\n    nauticalmiles: 1 / 1852,\n    inches: 39.370,\n    yards: 1 / 1.0936,\n    feet: 3.28084,\n    radians: 1 / earthRadius,\n    degrees: 1 / 111325,\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nvar areaFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    centimeters: 10000,\n    centimetres: 10000,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox) validateBBox(bbox);\n\n    // Main\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (length === null || length === undefined) throw new Error('length is required');\n    if (!(length >= 0)) throw new Error('length must be a positive number');\n\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) throw new Error('bbox is required');\n    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n    });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) throw new Error('id is required');\n    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nfunction degrees2radians() {\n    throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nfunction distanceToDegrees() {\n    throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nfunction distanceToRadians() {\n    throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nfunction radiansToDistance() {\n    throw new Error('method has been renamed to `radiansToLength`');\n}\n\nfunction bearingToAngle() {\n    throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nfunction convertDistance() {\n    throw new Error('method has been renamed to `convertLength`');\n}\n\nexport { earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId, radians2degrees, degrees2radians, distanceToDegrees, distanceToRadians, radiansToDistance, bearingToAngle, convertDistance };\n","import { feature, isObject, lineString, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    if (geomType === 'MultiPolygon') geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature$$1.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature$$1.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        if (coordEach(feature$$1, function (currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined) {\n                previousCoords = currentCoord;\n                return;\n            }\n            var currentSegment = lineString([previousCoords, currentCoord], feature$$1.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        if (feature$$1.geometry === null) return;\n        var type = feature$$1.geometry.type;\n        var coords = feature$$1.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(lineString(coords[geometryIndex], feature$$1.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexport { coordEach, coordReduce, propEach, propReduce, featureEach, featureReduce, coordAll, geomEach, geomReduce, flattenEach, flattenReduce, segmentEach, segmentReduce, lineEach, lineReduce, findSegment, findPoint };\n","/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325,\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nvar unitsFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000,\n    millimetres: 1000,\n    centimeters: 100,\n    centimetres: 100,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    miles: 1 / 1609.344,\n    nauticalmiles: 1 / 1852,\n    inches: 39.370,\n    yards: 1 / 1.0936,\n    feet: 3.28084,\n    radians: 1 / earthRadius,\n    degrees: 1 / 111325,\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nvar areaFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    centimeters: 10000,\n    centimetres: 10000,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox) validateBBox(bbox);\n\n    // Main\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (length === null || length === undefined) throw new Error('length is required');\n    if (!(length >= 0)) throw new Error('length must be a positive number');\n\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) throw new Error('bbox is required');\n    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n    });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) throw new Error('id is required');\n    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nfunction degrees2radians() {\n    throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nfunction distanceToDegrees() {\n    throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nfunction distanceToRadians() {\n    throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nfunction radiansToDistance() {\n    throw new Error('method has been renamed to `radiansToLength`');\n}\n\nfunction bearingToAngle() {\n    throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nfunction convertDistance() {\n    throw new Error('method has been renamed to `convertLength`');\n}\n\nexport { earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId, radians2degrees, degrees2radians, distanceToDegrees, distanceToRadians, radiansToDistance, bearingToAngle, convertDistance };\n","import { flattenEach } from '@turf/meta';\nimport { featureCollection } from '@turf/helpers';\n\n/**\n * Flattens any {@link GeoJSON} to a {@link FeatureCollection} inspired by [geojson-flatten](https://github.com/tmcw/geojson-flatten).\n *\n * @name flatten\n * @param {GeoJSON} geojson any valid GeoJSON Object\n * @returns {FeatureCollection<any>} all Multi-Geometries are flattened into single Features\n * @example\n * var multiGeometry = turf.multiPolygon([\n *   [[[102.0, 2.0], [103.0, 2.0], [103.0, 3.0], [102.0, 3.0], [102.0, 2.0]]],\n *   [[[100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0]],\n *   [[100.2, 0.2], [100.8, 0.2], [100.8, 0.8], [100.2, 0.8], [100.2, 0.2]]]\n * ]);\n *\n * var flatten = turf.flatten(multiGeometry);\n *\n * //addToMap\n * var addToMap = [flatten]\n */\nfunction flatten(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n\n    var results = [];\n    flattenEach(geojson, function (feature) {\n        results.push(feature);\n    });\n    return featureCollection(results);\n}\n\nexport default flatten;\n","import logger from 'loglevel';\nimport toGeoJSON from 'togeojson';\nimport flatten from '@turf/flatten';\nimport * as _ from './lodash';\n\n\nexport default class Helpers {\n    static getGeoJSON(kml) {\n        const extendedData = kml.getElementsByTagName('ExtendedData');\n        for (let index = extendedData.length - 1; index >= 0; index--) {\n            extendedData[index].parentNode.removeChild(extendedData[index]);\n        }\n        logger.log('KML (no ExtendedData):', kml);\n\n        let geoJson = toGeoJSON.kml(kml);\n        geoJson = flatten(geoJson);\n        logger.log('GeoJSON (flatten): ', geoJson);\n\n        return geoJson;\n    }\n\n    static getNumberOfFeatures(featureName, geoJson) {\n        const features = _.filter(geoJson.features,\n            feature => _.isEqual(feature.geometry.type, featureName));\n        return features.length;\n    }\n\n    static getLineString(geoJson) {\n        const lineString = _.find(geoJson.features,\n            feature => _.isEqual(feature.geometry.type, 'LineString'));\n        return lineString;\n    }\n\n    static getDistanceToNearestPointOnLine(point) {\n        return _.get(point, 'properties.nearestOnLine.properties.dist', Number.MAX_VALUE);\n    }\n\n    static getLocationOfNearestPointOnLine(point) {\n        return _.get(point, 'properties.nearestOnLine.properties.location', 0);\n    }\n\n    static reverseLineString(lineString) {\n        const newLineString = { ...lineString };\n        newLineString.geometry.coordinates = lineString.geometry.coordinates.reverse();\n        return newLineString;\n    }\n\n    static getPoints(geoJson) {\n        const points = _.filter(geoJson.features,\n            feature => _.isEqual(feature.geometry.type, 'Point'));\n        return points;\n    }\n\n    static getRoute(routeUrl) {\n        logger.debug('Fetching route from:', routeUrl);\n        return $.ajax(routeUrl);\n    }\n\n    static getGoogleMapsLatLng(coordinates) {\n        return new google.maps.LatLng(coordinates[1], coordinates[0]);\n    }\n\n    static getGoogleMapsPath(lineString) {\n        const path = _.map(lineString.geometry.coordinates,\n            element => Helpers.getGoogleMapsLatLng(element));\n        return path;\n    }\n\n    static getPathElevations(lineString, useLocalElevations) {\n        if (useLocalElevations && lineString.geometry.coordinates[0].length === 3) {\n            // Elevation present in line string\n\n            logger.debug('Getting path elevations from line string...');\n            const elevations = _.map(lineString.geometry.coordinates,\n                element => ({ elevation: element[2] }));\n            logger.debug('Elevations:', elevations);\n            return new Promise((resolve, reject) => {\n                resolve(elevations);\n            });\n        }\n        // No elevation in line string\n        let path = this.getGoogleMapsPath(lineString);\n\n        // Optimize path array length\n        // This is done to send no more than\n        // MAXIMUM_NUMBER_OF_LATLNG_OBJECTS coordinates in KML path\n        const MAXIMUM_NUMBER_OF_SAMPLES = 512;\n        // Request to google.maps.ElevationService cannot be too long (2048 is too long)\n        const MAXIMUM_NUMBER_OF_LATLNG_OBJECTS = 1024;\n        logger.debug('Number of LatLng objects:', path.length);\n        if (path.length > MAXIMUM_NUMBER_OF_LATLNG_OBJECTS) {\n            const optimizedPath = [];\n            const delta = parseFloat(path.length / MAXIMUM_NUMBER_OF_LATLNG_OBJECTS);\n            for (let i = 0; i < path.length; i += delta) {\n                optimizedPath.push(path[Math.floor(i)]);\n            }\n            path = optimizedPath;\n            logger.debug('Number of LatLng objects after optimization:', path.length);\n        }\n\n        return new Promise((resolve, reject) => {\n            const elevator = new google.maps.ElevationService();\n            elevator.getElevationAlongPath({\n                path,\n                samples: MAXIMUM_NUMBER_OF_SAMPLES,\n            }, (elevations, status) => {\n                if (status === google.maps.ElevationStatus.OK) {\n                    resolve(elevations);\n                } else {\n                    reject(status);\n                }\n            });\n        });\n    }\n\n    static getRouteParameters(routeParamsUrl) {\n        return new Promise((resolve, reject) => {\n            $.ajax(routeParamsUrl)\n                .done(data => {\n                    logger.debug('Route parameters:', data);\n                    if (data.success === 1) {\n                        resolve(data);\n                    } else {\n                        reject(`Server side error: ${data.error}`);\n                    }\n                })\n                .fail((xhr, status) => {\n                    reject(status);\n                });\n        });\n    }\n\n    static approveRoute(routeApproveUrl) {\n        return new Promise((resolve, reject) => {\n            $.ajax(routeApproveUrl)\n                .done(data => {\n                    resolve({ success: true });\n                })\n                .fail((xhr, status) => {\n                    reject(status);\n                });\n        });\n    }\n}\n","const getGain = elevations => {\n    let elevationGain = 0.0;\n    for (let i = 1; i < elevations.length; i++) {\n        const elevationDifference = elevations[i].elevation - elevations[i - 1].elevation;\n        elevationGain += (elevationDifference > 0) ? elevationDifference : 0.0;\n    }\n    return Number(elevationGain);\n};\n\nconst getLoss = elevations => {\n    let elevationLoss = 0.0;\n    for (let i = 1; i < elevations.length; i++) {\n        const elevationDifference = elevations[i - 1].elevation - elevations[i].elevation;\n        elevationLoss += (elevationDifference > 0) ? elevationDifference : 0.0;\n    }\n    return Number(elevationLoss);\n};\n\n\nexport default class PathElevation {\n    constructor(elevations, length) {\n        this.gain = getGain(elevations);\n        this.loss = getLoss(elevations);\n        this.totalChange = this.loss + this.gain;\n        this.data = elevations;\n    }\n\n    enrichData(length) {\n        const elevationsWithDistance = [];\n        const resolution = length / this.data.length;\n        for (let i = 0; i < this.data.length; i++) {\n            elevationsWithDistance.push({\n                elevation: this.data[i].elevation, distance: i * resolution,\n            });\n        }\n        this.data = elevationsWithDistance;\n    }\n}\n","/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325,\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nvar unitsFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000,\n    millimetres: 1000,\n    centimeters: 100,\n    centimetres: 100,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    miles: 1 / 1609.344,\n    nauticalmiles: 1 / 1852,\n    inches: 39.370,\n    yards: 1 / 1.0936,\n    feet: 3.28084,\n    radians: 1 / earthRadius,\n    degrees: 1 / 111325,\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nvar areaFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    centimeters: 10000,\n    centimetres: 10000,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox) validateBBox(bbox);\n\n    // Main\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (length === null || length === undefined) throw new Error('length is required');\n    if (!(length >= 0)) throw new Error('length must be a positive number');\n\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) throw new Error('bbox is required');\n    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n    });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) throw new Error('id is required');\n    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nfunction degrees2radians() {\n    throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nfunction distanceToDegrees() {\n    throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nfunction distanceToRadians() {\n    throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nfunction radiansToDistance() {\n    throw new Error('method has been renamed to `radiansToLength`');\n}\n\nfunction bearingToAngle() {\n    throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nfunction convertDistance() {\n    throw new Error('method has been renamed to `convertLength`');\n}\n\nexport { earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId, radians2degrees, degrees2radians, distanceToDegrees, distanceToRadians, radiansToDistance, bearingToAngle, convertDistance };\n","import { isNumber } from '@turf/helpers';\n\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(coord) {\n    if (!coord) throw new Error('coord is required');\n    if (coord.type === 'Feature' && coord.geometry !== null && coord.geometry.type === 'Point') return coord.geometry.coordinates;\n    if (coord.type === 'Point') return coord.coordinates;\n    if (Array.isArray(coord) && coord.length >= 2 && coord[0].length === undefined && coord[1].length === undefined) return coord;\n\n    throw new Error('coord must be GeoJSON Point or an Array of numbers');\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nfunction getCoords(coords) {\n    if (!coords) throw new Error('coords is required');\n\n    // Feature\n    if (coords.type === 'Feature' && coords.geometry !== null) return coords.geometry.coordinates;\n\n    // Geometry\n    if (coords.coordinates) return coords.coordinates;\n\n    // Array of numbers\n    if (Array.isArray(coords)) return coords;\n\n    throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates) {\n    if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nfunction getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\nfunction getGeomType() {\n    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nfunction getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n\nexport { getCoord, getCoords, containsNumber, geojsonType, featureOf, collectionOf, getGeom, getGeomType, getType };\n","import { getCoord } from '@turf/invariant';\nimport { degreesToRadians, isObject, radiansToDegrees } from '@turf/helpers';\n\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n\n/**\n * Takes two {@link Point|points} and finds the geographic bearing between them,\n * i.e. the angle measured in degrees from the north line (0 degrees)\n *\n * @name bearing\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.final=false] calculates the final bearing if true\n * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)\n * @example\n * var point1 = turf.point([-75.343, 39.984]);\n * var point2 = turf.point([-75.534, 39.123]);\n *\n * var bearing = turf.bearing(point1, point2);\n *\n * //addToMap\n * var addToMap = [point1, point2]\n * point1.properties['marker-color'] = '#f00'\n * point2.properties['marker-color'] = '#0f0'\n * point1.properties.bearing = bearing\n */\nfunction bearing(start, end, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var final = options.final;\n\n    // Reverse calculation\n    if (final === true) return calculateFinalBearing(start, end);\n\n    var coordinates1 = getCoord(start);\n    var coordinates2 = getCoord(end);\n\n    var lon1 = degreesToRadians(coordinates1[0]);\n    var lon2 = degreesToRadians(coordinates2[0]);\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n    var b = Math.cos(lat1) * Math.sin(lat2) -\n        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n\n    return radiansToDegrees(Math.atan2(a, b));\n}\n\n/**\n * Calculates Final Bearing\n *\n * @private\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @returns {number} bearing\n */\nfunction calculateFinalBearing(start, end) {\n    // Swap start & end\n    var bear = bearing(end, start);\n    bear = (bear + 180) % 360;\n    return bear;\n}\n\nexport default bearing;\n","import { getCoord } from '@turf/invariant';\nimport { degreesToRadians, isObject, radiansToLength } from '@turf/helpers';\n\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians,\n * miles, or kilometers. This uses the\n * [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula)\n * to account for global curvature.\n *\n * @name distance\n * @param {Coord} from origin point\n * @param {Coord} to destination point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.distance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var units = options.units;\n\n    var coordinates1 = getCoord(from);\n    var coordinates2 = getCoord(to);\n    var dLat = degreesToRadians((coordinates2[1] - coordinates1[1]));\n    var dLon = degreesToRadians((coordinates2[0] - coordinates1[0]));\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n          Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n\n    return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), units);\n}\n\nexport default distance;\n","import { getCoord } from '@turf/invariant';\nimport { degreesToRadians, isObject, lengthToRadians, point, radiansToDegrees } from '@turf/helpers';\n\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in degrees, radians, miles, or kilometers; and bearing in degrees. This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Coord} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {Object} [options.properties={}] Translate properties to Point\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.destination(point, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\nfunction destination(origin, distance, bearing, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var units = options.units;\n    var properties = options.properties;\n\n    // Handle input\n    var coordinates1 = getCoord(origin);\n    var longitude1 = degreesToRadians(coordinates1[0]);\n    var latitude1 = degreesToRadians(coordinates1[1]);\n    var bearing_rad = degreesToRadians(bearing);\n    var radians = lengthToRadians(distance, units);\n\n    // Main\n    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearing_rad));\n    var longitude2 = longitude1 + Math.atan2(Math.sin(bearing_rad) * Math.sin(radians) * Math.cos(latitude1),\n        Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n    var lng = radiansToDegrees(longitude2);\n    var lat = radiansToDegrees(latitude2);\n\n    return point([lng, lat], properties);\n}\n\nexport default destination;\n","import bearing from '@turf/bearing';\nimport distance from '@turf/distance';\nimport destination from '@turf/destination';\nimport { isObject, lineString } from '@turf/helpers';\n\n/**\n * Takes a {@link LineString|line}, a specified distance along the line to a start {@link Point},\n * and a specified  distance along the line to a stop point\n * and returns a subsection of the line in-between those points.\n *\n * This can be useful for extracting only the part of a route between two distances.\n *\n * @name lineSliceAlong\n * @param {Feature<LineString>|LineString} line input line\n * @param {number} startDist distance along the line to starting point\n * @param {number} stopDist distance along the line to ending point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<LineString>} sliced line\n * @example\n * var line = turf.lineString([[7, 45], [9, 45], [14, 40], [14, 41]]);\n * var start = 12.5;\n * var stop = 25;\n * var sliced = turf.lineSliceAlong(line, start, stop, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line, start, stop, sliced]\n */\nfunction lineSliceAlong(line, startDist, stopDist, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n\n    var coords;\n    var slice = [];\n\n    // Validation\n    if (line.type === 'Feature') coords = line.geometry.coordinates;\n    else if (line.type === 'LineString') coords = line.coordinates;\n    else throw new Error('input must be a LineString Feature or Geometry');\n\n    var travelled = 0;\n    var overshot, direction, interpolated;\n    for (var i = 0; i < coords.length; i++) {\n        if (startDist >= travelled && i === coords.length - 1) break;\n        else if (travelled > startDist && slice.length === 0) {\n            overshot = startDist - travelled;\n            if (!overshot) {\n                slice.push(coords[i]);\n                return lineString(slice);\n            }\n            direction = bearing(coords[i], coords[i - 1]) - 180;\n            interpolated = destination(coords[i], overshot, direction, options);\n            slice.push(interpolated.geometry.coordinates);\n        }\n\n        if (travelled >= stopDist) {\n            overshot = stopDist - travelled;\n            if (!overshot) {\n                slice.push(coords[i]);\n                return lineString(slice);\n            }\n            direction = bearing(coords[i], coords[i - 1]) - 180;\n            interpolated = destination(coords[i], overshot, direction, options);\n            slice.push(interpolated.geometry.coordinates);\n            return lineString(slice);\n        }\n\n        if (travelled >= startDist) {\n            slice.push(coords[i]);\n        }\n\n        if (i === coords.length - 1) {\n            return lineString(slice);\n        }\n\n        travelled += distance(coords[i], coords[i + 1], options);\n    }\n    return lineString(coords[coords.length - 1]);\n}\n\nexport default lineSliceAlong;\n","import logger from 'loglevel';\nimport length from '@turf/length';\nimport lineSliceAlong from '@turf/line-slice-along';\nimport nearestPointOnLine from '@turf/nearest-point-on-line';\nimport pointToLineDistance from '@turf/point-to-line-distance';\nimport distance from '@turf/distance';\nimport { point } from '@turf/helpers';\n\nimport * as _ from './lodash';\nimport helpers from './helpers';\n\n\nconst turf = {\n    distance,\n    length,\n    lineSliceAlong,\n    point,\n    pointToLineDistance,\n    nearestPointOnLine,\n\n    options: { units: 'meters' },\n};\n\n\nconst CONSTS = {\n    START_INDEX: 0,\n    FIRST_STATION_INDEX: 1,\n    LAST_STATION_INDEX: 14,\n    END_INDEX: 15,\n};\n\n\nexport default class Stations {\n    constructor(points, lineString) {\n        this.points = points;\n        this.path = lineString;\n        this.pathReversed = false;\n        this.pathCircular = false;\n\n        // Map points to stations and sort\n        this.addIndexes();\n        this.sortByIndex();\n\n        // Path circular check\n        this.pathStart = turf.point(this.path.geometry.coordinates[0]);\n        this.pathEnd = turf.point(this.path.geometry.coordinates[this.path.geometry.coordinates.length - 1]);\n        this.updateCircularity();\n\n        // Path reverse check\n        this.updateDirection();\n\n        // Stations to path mapping\n        this.findNearestPointsOnPath();\n        this.sortByLocationOnPath();\n    }\n\n    findNearestPointsOnPath() {\n        const stepDistance = turf.length(this.path, turf.options) / 10;\n        const sampleDistance = stepDistance / 10;\n\n        let nearestPointOnSlicedPath = null;\n        _.forEach(this.points, point => {\n            // Filter out point if it is too far from path\n            const coordinates = point.geometry.coordinates;\n            const distanceToPath = turf.pointToLineDistance(coordinates, this.path, turf.options);\n            const maximumDistanceFromPath = 200; // meters\n            if (distanceToPath > maximumDistanceFromPath) {\n                logger.debug(`Point ${point.properties.name} too far from the path. \n                              Not looking for nearest point on line for it.`);\n                point.properties.nearestOnLine = turf.nearestPointOnLine(this.path, point, turf.options);\n                return true;\n            }\n\n            // Find nearest point on line for the specific station\n            logger.debug(`Looking for nearest point on line for ${point.properties.name}`);\n\n            // Set start and stop point of the sliced path traversal\n            const startPointDistance = _.get(nearestPointOnSlicedPath, 'properties.location', 0);\n            let stopPointDistance = startPointDistance + stepDistance;\n\n            // Reset nearest point on sliced path\n            nearestPointOnSlicedPath = null;\n\n            for (let oldDistanceToPath = 0, newDistanceToPath = Number.MAX_VALUE;\n                newDistanceToPath !== oldDistanceToPath || newDistanceToPath > maximumDistanceFromPath;\n                stopPointDistance += sampleDistance) {\n                const slicedPath = turf.lineSliceAlong(this.path, startPointDistance, stopPointDistance, turf.options);\n                nearestPointOnSlicedPath = turf.nearestPointOnLine(slicedPath, point, turf.options);\n                oldDistanceToPath = newDistanceToPath;\n                newDistanceToPath = turf.pointToLineDistance(coordinates, slicedPath, turf.options);\n            }\n\n            // Save nearest point on line for the specific station\n            point.properties.nearestOnLine = nearestPointOnSlicedPath;\n\n            // Update location on line (starting from the path beginning)\n            point.properties.nearestOnLine.properties.location += startPointDistance;\n\n            logger.debug(`Distance from path: \n                ${point.properties.nearestOnLine.properties.dist.toFixed(2)} meter(s).`);\n            logger.debug(`Location on path: \n                ${point.properties.nearestOnLine.properties.location.toFixed(2)} meter(s).`);\n\n            this.addDebugInformationToMap(point, nearestPointOnSlicedPath);\n        });\n    }\n\n    addDebugInformationToMap(originalPoint, nearestPoint) {\n        if (logger.getLevel() <= logger.levels.DEBUG && !!window.map) {\n            new google.maps.Marker({\n                position: helpers.getGoogleMapsLatLng(nearestPoint.geometry.coordinates),\n                map: window.map,\n                label: {\n                    fontWeight: 'bold',\n                    text: `${originalPoint.properties.index}`,\n                },\n                title: `${originalPoint.properties.index}`,\n                icon: 'https://maps.google.com/mapfiles/ms/icons/yellow.png',\n            });\n            new google.maps.Marker({\n                position: helpers.getGoogleMapsLatLng(originalPoint.geometry.coordinates),\n                map: window.map,\n                label: {\n                    fontWeight: 'bold',\n                    text: `${originalPoint.properties.index}`,\n                },\n                title: `${originalPoint.properties.index}`,\n                icon: 'https://maps.google.com/mapfiles/ms/icons/blue.png',\n            });\n        }\n    }\n\n    sortByIndex() {\n        const getIndex = point => _.get(point, 'properties.index', Number.MAX_VALUE);\n        this.points = _.sortBy(this.points, point => getIndex(point));\n    }\n\n    sortByLocationOnPath() {\n        const getLocation = point => _.get(point, 'properties.nearestOnLine.properties.location', Number.MAX_VALUE);\n        this.points = _.sortBy(this.points, point => getLocation(point));\n    }\n\n    addIndexes() {\n        const getIndex = str => {\n            /** Regular expressions for extracting station number\n             *  from a given string (which might be represented by different types\n             *  of numbers and different delimiters)\n             */\n            const START_NAMES_REGEX = /^(wstp|wprowadzenie|pocztek|start)$/ig;\n            const END_NAMES_REGEX = /^(zakoczenie|koniec|podsumowanie)$/ig;\n            const ROMAN_NUMBERS_REGEX = /^(I|II|III|IV|V|VI|VII|VIII|IX|X|XI|XII|XIII|XIV)$/g;\n            const EUROPEAN_NUMBERS_REGEX = /^\\d+$/g;\n            const SPLITTER_REGEX = /[ ,\\._\\-:;]+/;\n            const ROMAN_EUROPEAN_MAP = {\n                I: 1,\n                II: 2,\n                III: 3,\n                IV: 4,\n                V: 5,\n                VI: 6,\n                VII: 7,\n                VIII: 8,\n                IX: 9,\n                X: 10,\n                XI: 11,\n                XII: 12,\n                XIII: 13,\n                XIV: 14,\n            };\n\n            let index = null;\n\n            logger.debug(`Checking station index for string: ${str}`);\n\n            // noname station\n            if (!str) {\n                return index;\n            }\n\n            // split\n            const parts = str.trim().split(SPLITTER_REGEX);\n\n            _.forEach(parts, part => {\n                // try roman numbers\n                // it isn't clear why there are for matches declaration\n                let matches = part.match(ROMAN_NUMBERS_REGEX);\n                if (!_.isNull(matches)) {\n                    index = ROMAN_EUROPEAN_MAP[matches[0]];\n                    return false;\n                }\n\n                // try european numbers\n                matches = part.match(EUROPEAN_NUMBERS_REGEX);\n                if (!_.isNull(matches)) {\n                    const stationNumber = parseInt(matches[0]);\n                    if (stationNumber >= CONSTS.FIRST_STATION_INDEX\n                        && stationNumber <= CONSTS.LAST_STATION_INDEX) {\n                        index = stationNumber;\n                        return false;\n                    }\n                    return true;\n                }\n\n                // try start names\n                matches = part.match(START_NAMES_REGEX);\n                if (!_.isNull(matches)) {\n                    index = CONSTS.START_INDEX;\n                    return false;\n                }\n\n                // try end names\n                matches = part.match(END_NAMES_REGEX);\n                if (!_.isNull(matches)) {\n                    index = CONSTS.END_INDEX;\n                    return false;\n                }\n            });\n\n            return index;\n        };\n\n        this.points = _.map(this.points, point => {\n            const name = point.properties.name;\n\n            point.properties.index = getIndex(name);\n            return point;\n        });\n    }\n\n    updateDirection() {\n        const isIndexEqual = (point, index) => point.properties.index === index;\n        const startPoint = _.filter(this.points,\n            point => isIndexEqual(point, CONSTS.START_INDEX) || isIndexEqual(point, CONSTS.FIRST_STATION_INDEX));\n        const endPoint = _.filter(this.points,\n            point => isIndexEqual(point, CONSTS.END_INDEX) || isIndexEqual(point, CONSTS.LAST_STATION_INDEX));\n\n        if (!_.isEmpty(startPoint)) {\n            logger.debug('Start point detected. Checking if it is closer to path start or path end...');\n            const startPointToPathStartDistance = turf.distance(this.pathStart,\n                startPoint[0], turf.options);\n            const startPointToPathEndDistance = turf.distance(this.pathEnd, startPoint[0], turf.options);\n            if (startPointToPathStartDistance > startPointToPathEndDistance) {\n                logger.debug('Reversed path detected. Start point is closer to path end.');\n                this.pathReversed = true;\n            }\n        } else if (!_.isEmpty(endPoint)) {\n            logger.debug('End point detected. Checking if it is closer to path start or path end...');\n            const endPointToPathStartDistance = turf.distance(this.pathStart, endPoint[0], turf.options);\n            const endPointToPathEndDistance = turf.distance(this.pathEnd, endPoint[0], turf.options);\n            if (endPointToPathEndDistance > endPointToPathStartDistance) {\n                logger.debug('Reversed path detected. Start point is closer to path end.');\n                this.pathReversed = true;\n            }\n        }\n\n        if (this.pathReversed) {\n            logger.debug('Reversing points.');\n            this.path = helpers.reverseLineString(this.path);\n        }\n    }\n\n    updateCircularity() {\n        const maxDistanceBetweenPathEnds = 1000; // meters\n        const distance = turf.distance(this.pathStart, this.pathEnd, turf.options);\n\n        logger.debug('Distance between path start and end points:', distance.toFixed(2), 'meters.');\n        if (distance <= maxDistanceBetweenPathEnds) {\n            logger.debug('Circular path detected.');\n            this.pathCircular = true;\n        } else {\n            logger.debug('Circular path not detected.');\n            this.pathCircular = false;\n        }\n    }\n\n    getCount() {\n        let numberOfStations = 0;\n        for (let stationNumber = CONSTS.FIRST_STATION_INDEX;\n            stationNumber <= CONSTS.LAST_STATION_INDEX; stationNumber++) {\n            let firstStationName = '';\n            const stationsOfNumber = _.filter(this.points, station => {\n                if (station.properties.index === stationNumber) {\n                    firstStationName = station.properties.name;\n                    return true;\n                }\n                return false;\n            });\n            if (stationsOfNumber.length !== 1) {\n                logger.warn(`Station ${stationNumber} found ${stationsOfNumber.length} times.`);\n            } else {\n                logger.debug(`Station ${stationNumber} found. Station name: ${firstStationName}`);\n                numberOfStations++;\n            }\n        }\n        return numberOfStations;\n    }\n\n    isOrderCorrect() {\n        let result = true;\n        for (let i = 1; i < this.points.length; i++) {\n            const currentStationNumber = this.points[i].properties.index;\n            const previousStationNumber = this.points[i - 1].properties.index;\n            logger.debug(`Point ${i - 1}`);\n            if (currentStationNumber === null) {\n                logger.debug(`Not checking order for unrecognized point: ${this.points[i].properties.name}`);\n            } else if (previousStationNumber === null) {\n                logger.debug(`Not checking order for unrecognized point: ${this.points[i - 1].properties.name}`);\n            } else if (this.pathCircular\n                && (\n                    (previousStationNumber === CONSTS.FIRST_STATION_INDEX\n                    && currentStationNumber === CONSTS.LAST_STATION_INDEX)\n                    || (currentStationNumber === CONSTS.FIRST_STATION_INDEX\n                    && previousStationNumber === CONSTS.LAST_STATION_INDEX)\n                )\n            ) {\n                logger.debug('Not checking order for station',\n                    CONSTS.FIRST_STATION_INDEX, 'and', CONSTS.LAST_STATION_INDEX,\n                    'when route is circular.');\n            } else if (currentStationNumber <= previousStationNumber) {\n                logger.warn(`Detected invalid order of stations. \n                    Station ${currentStationNumber} is after station ${previousStationNumber}.`);\n                result = false;\n            } else {\n                logger.debug(`Station ${currentStationNumber} is after station ${previousStationNumber}.`);\n            }\n        }\n        return result;\n    }\n\n    areAllOnThePath(maximumDistanceFromPath) {\n        let result = true;\n\n        _.forEach(this.points, (station, index) => {\n            const stationNumber = station.properties.index;\n\n            logger.debug(`Point ${index}`);\n            if (stationNumber === null) {\n                logger.debug(`Not checking distance for: ${station.properties.name}`);\n            } else {\n                const distanceFromStationToPath = helpers.getDistanceToNearestPointOnLine(station);\n                logger.debug(`Station ${stationNumber} distance from path: \n                    ${distanceFromStationToPath.toFixed(2)} meter(s).`);\n                if (distanceFromStationToPath > maximumDistanceFromPath) {\n                    logger.warn(`Station ${stationNumber} is too far from path. \n                        Expected maximum distance from path: ${maximumDistanceFromPath} meter(s).`);\n                    result = false;\n                } else {\n                    logger.debug(`Station ${stationNumber} is on the path.`);\n                }\n            }\n        });\n\n        return result;\n    }\n\n    getUpdatedPath() {\n        const lastStationPoint = _.find(this.points, point => point.properties.index === CONSTS.LAST_STATION_INDEX);\n\n        if (lastStationPoint !== null) {\n            const lastStationLocation = helpers.getLocationOfNearestPointOnLine(lastStationPoint);\n            if (lastStationLocation > 0) {\n                logger.debug('getPathEndingOnLastStation: Returning sliced path. '\n                    + `Last station location: ${lastStationLocation.toFixed(2)}`);\n                return turf.lineSliceAlong(this.path, 0, lastStationLocation, turf.options);\n            }\n        }\n\n        logger.debug('getPathEndingOnLastStation: Returning original path. Last station not found.');\n        return this.path;\n    }\n}\n","import logger from 'loglevel';\nimport * as _ from './lodash';\nimport helpers from './helpers';\nimport PathElevation from './PathElevation';\nimport Stations from './Stations';\n\n// Constants\nconst EXPECTED_NUMBER_OF_PATHS = 1;\nconst EXPECTED_NUMBER_OF_STATIONS = 14;\nconst MAXIMUM_DISTANCE_FROM_STATION_TO_PATH = 50; // meters\n\n\nexport default class Route {\n    constructor(geoJson) {\n        this.geoJson = geoJson;\n        this.lineString = helpers.getLineString(this.geoJson);\n        this.points = helpers.getPoints(this.geoJson);\n        this.isRouteVerifiable = true;\n\n        if (_.isEmpty(this.lineString)) {\n            logger.error('No line string in route.');\n            this.isRouteVerifiable = false;\n        }\n        if (_.isEmpty(this.points)) {\n            logger.error('No points in route.');\n        }\n        if (this.isRouteVerifiable) {\n            this.stations = new Stations(this.points, this.lineString);\n            this.path = this.stations.getUpdatedPath();\n            this.numberOfPaths = helpers.getNumberOfFeatures('LineString', this.geoJson);\n        }\n    }\n\n\n    isVerifiable() {\n        return this.isRouteVerifiable;\n    }\n\n    isSinglePath() {\n        const result = _.isEqual(this.numberOfPaths, EXPECTED_NUMBER_OF_PATHS);\n        if (!result) {\n            logger.warn('No single path defined.');\n        }\n        logger.debug('isSinglePath:', result, ', numberOfPaths:', this.numberOfPaths);\n        return result;\n    }\n\n    areAllStationsPresent() {\n        const numberOfStations = this.stations.getCount();\n        const result = _.isEqual(numberOfStations, EXPECTED_NUMBER_OF_STATIONS);\n        logger.debug('areAllStationsPresent:', result, ', numberOfStations:', numberOfStations);\n        return result;\n    }\n\n    areStationsOnThePath() {\n        const result = this.stations.areAllOnThePath(MAXIMUM_DISTANCE_FROM_STATION_TO_PATH);\n        logger.debug('areStationsOnThePath:', result);\n        return result;\n    }\n\n    isStationOrderCorrect() {\n        const result = this.stations.isOrderCorrect();\n        logger.debug('isStationOrderCorrect:', result);\n        return result;\n    }\n\n    getPathLength() {\n        let result = 0;\n\n        const googleMapsPath = helpers.getGoogleMapsPath(this.path);\n        result = google.maps.geometry.spherical.computeLength(googleMapsPath);\n        result /= 1000;\n\n        logger.debug('getPathLength [km]:', result);\n        return result;\n    }\n\n    fetchPathElevationData() {\n        return helpers.getPathElevations(this.path)\n            .then(elevations => {\n                logger.debug('Path elevations:', elevations);\n                this.pathElevation = new PathElevation(elevations);\n                return this.pathElevation;\n            })\n            .catch(error => {\n                throw new Error(error);\n            });\n    }\n\n    getPathElevation() {\n        logger.debug('getPathElevation:', this.pathElevation);\n        return this.pathElevation;\n    }\n}\n","export default function () {\n    const mapCanvasElement = $('div#map-canvas');\n\n    this.routeUrl = mapCanvasElement.attr('data-what');\n    this.routeParamsUrl = mapCanvasElement.attr('data-route-params');\n    this.routeApproveUrl = mapCanvasElement.attr('data-route-approve');\n}\n","import logger from 'loglevel';\nimport * as _ from './lodash';\n\n// Constants\nconst ROUTE_TYPE_ID = 'div#routeType';\nconst SINGLE_PATH_ID = 'div#singlePath';\nconst PATH_LENGTH_ID = 'div#pathLength';\nconst ELEVATION_GAIN_ID = 'div#elevationGain';\nconst ELEVATION_LOSS_ID = 'div#elevationLoss';\nconst ELEVATION_TOTAL_CHANGE_ID = 'div#elevationTotalChange';\nconst NUMBER_OF_STATIONS_ID = 'div#numberOfStations';\nconst STATIONS_ORDER_ID = 'div#stationsOrder';\nconst STATIONS_ON_PATH_ID = 'div#stationsOnPath';\nconst DATA_CONSISTENCY_ID = 'div#dataConsistency';\nconst ELEVATION_CHART_ID = 'canvas#elevationChart';\nconst VERIFY_BUTTON_ID = 'button#verifyRoute';\nconst LOADER_ID = 'div#loader';\nconst LOADER_ELEMENT = '<div id=\"loader\" class=\"overlay\"><i class=\"fa fa-refresh fa-spin\"></i></div>';\nconst ELEVATION_CHART_ELEMENT = '<canvas id=\"elevationChart\"></canvas>';\n\n\nconst updateControlColor = (element, isValid) => {\n    const VALID_COLOR_CLASS = 'bg-green';\n    const INVALID_COLOR_CLASS = 'bg-yellow';\n    const INFO_BOX_ICON = 'span.info-box-icon';\n\n    if (_.isNull(isValid)) {\n        $(`${element} ${INFO_BOX_ICON}`).removeClass([INVALID_COLOR_CLASS, VALID_COLOR_CLASS].join(' '));\n    } else {\n        (isValid)\n            ? $(`${element} ${INFO_BOX_ICON}`).removeClass(INVALID_COLOR_CLASS).addClass(VALID_COLOR_CLASS)\n            : $(`${element} ${INFO_BOX_ICON}`).removeClass(VALID_COLOR_CLASS).addClass(INVALID_COLOR_CLASS);\n    }\n};\n\nconst updateControlValue = (element, value, unit) => {\n    const INFO_BOX_NUMBER = 'span.info-box-number';\n\n    logger.debug('Updating control element', element, 'with:', value, unit);\n    $(`${element} ${INFO_BOX_NUMBER}`).html(`${value} ${unit ? `<small>${unit}</small>` : ''}`);\n};\n\nconst removeControlChildren = element => {\n    $(ELEVATION_CHART_ID).empty();\n};\n\n\nexport default class Controls {\n    // Constructor\n\n\n    updateRouteType(isNormalRoute) {\n        const normalRouteString = $('input#normalRouteString').attr('value');\n        const inspiredRouteString = $('input#inspiredRouteString').attr('value');\n        updateControlValue(ROUTE_TYPE_ID, isNormalRoute ? normalRouteString : inspiredRouteString);\n        updateControlColor(ROUTE_TYPE_ID, true);\n    }\n\n    updatePathLength(isLengthValid, length) {\n        updateControlValue(PATH_LENGTH_ID, length.toFixed(2), 'km');\n        updateControlColor(PATH_LENGTH_ID, isLengthValid);\n    }\n\n    updateElevationGain(isElevationGainValid, elevationGain) {\n        updateControlValue(ELEVATION_GAIN_ID, elevationGain.toFixed(2), 'm');\n        updateControlColor(ELEVATION_GAIN_ID, isElevationGainValid);\n    }\n\n    updateElevationLoss(isElevationLossValid, elevationLoss) {\n        updateControlValue(ELEVATION_LOSS_ID, elevationLoss.toFixed(2), 'm');\n        updateControlColor(ELEVATION_LOSS_ID, isElevationLossValid);\n    }\n\n    updateElevationTotalChange(isElevationTotalChangeValid, elevationTotalChange) {\n        updateControlValue(ELEVATION_TOTAL_CHANGE_ID, elevationTotalChange.toFixed(2), 'm');\n        updateControlColor(ELEVATION_TOTAL_CHANGE_ID, isElevationTotalChangeValid);\n    }\n\n    updateNumberOfStations(areAllStationsPresent) {\n        updateControlColor(NUMBER_OF_STATIONS_ID, areAllStationsPresent);\n    }\n\n    updateStationsOrder(isStationOrderCorrect) {\n        updateControlColor(STATIONS_ORDER_ID, isStationOrderCorrect);\n    }\n\n    updateStationsOnPath(areAllStationsOnPath) {\n        updateControlColor(STATIONS_ON_PATH_ID, areAllStationsOnPath);\n    }\n\n    updateSinglePath(isSinglePath) {\n        updateControlColor(SINGLE_PATH_ID, isSinglePath);\n    }\n\n    updateDataConsistency(isDataConsistent) {\n        updateControlColor(DATA_CONSISTENCY_ID, isDataConsistent);\n    }\n\n    drawElevationChart(pathElevation) {\n        const X_AXIS_NUMBER_OF_LABELS = 10;\n        const X_AXIS_LABEL_STRING = '[km]';\n        const Y_AXIS_LABEL_STRING = '[m]';\n        const CHART_BACKGROUND_COLOR = 'rgb(32, 77, 116)';\n\n        const labelWidth = parseInt(pathElevation.data.length / X_AXIS_NUMBER_OF_LABELS);\n        const labels = _.map(pathElevation.data, elevation => elevation.distance.toFixed());\n        const data = _.map(pathElevation.data, elevation => elevation.elevation);\n\n        logger.debug('Drawing elevation chart. Input:', pathElevation);\n\n        const elevationChart = new Chart($(ELEVATION_CHART_ID), {\n            type: 'line',\n            data: {\n                labels,\n                datasets: [{\n                    label: '',\n                    data,\n                    fill: 'start',\n                    radius: 0,\n                    backgroundColor: CHART_BACKGROUND_COLOR,\n                }],\n            },\n            options: {\n                scales: {\n                    xAxes: [{\n                        scaleLabel: {\n                            display: true,\n                            labelString: X_AXIS_LABEL_STRING,\n                        },\n                        ticks: {\n                            callback: (dataLabel, index) => (index % labelWidth === 0\n                                || (index === pathElevation.data.length - 1)\n                                ? dataLabel\n                                : null)\n                            ,\n                        },\n                    }],\n                    yAxes: [{\n                        scaleLabel: {\n                            display: true,\n                            labelString: Y_AXIS_LABEL_STRING,\n                        },\n                    }],\n                },\n                legend: {\n                    display: false,\n                },\n                tooltips: {\n                    enabled: false,\n                },\n            },\n        });\n    }\n\n    resetElevationChart() {\n        const elevationChartParentElement = $(ELEVATION_CHART_ID).parent();\n        $(ELEVATION_CHART_ID).remove();\n        elevationChartParentElement.append(ELEVATION_CHART_ELEMENT);\n    }\n\n    addLoaderToButton() {\n        $(VERIFY_BUTTON_ID).append(LOADER_ELEMENT);\n    }\n\n    removeLoaderFromButton() {\n        $(`${VERIFY_BUTTON_ID} ${LOADER_ID}`).remove();\n    }\n\n    resetAll(value) {\n        const text = '';\n        const isValid = value === undefined ? null : value;\n\n        updateControlValue(ROUTE_TYPE_ID, text);\n        updateControlColor(ROUTE_TYPE_ID, isValid);\n        updateControlValue(PATH_LENGTH_ID, text);\n        updateControlColor(PATH_LENGTH_ID, isValid);\n        updateControlValue(ELEVATION_GAIN_ID, text);\n        updateControlColor(ELEVATION_GAIN_ID, isValid);\n        updateControlValue(ELEVATION_LOSS_ID, text);\n        updateControlColor(ELEVATION_LOSS_ID, isValid);\n        updateControlValue(ELEVATION_TOTAL_CHANGE_ID, text);\n        updateControlColor(ELEVATION_TOTAL_CHANGE_ID, isValid);\n        updateControlColor(NUMBER_OF_STATIONS_ID, isValid);\n        updateControlColor(STATIONS_ORDER_ID, isValid);\n        updateControlColor(STATIONS_ON_PATH_ID, isValid);\n        updateControlColor(SINGLE_PATH_ID, isValid);\n        updateControlColor(DATA_CONSISTENCY_ID, isValid);\n        this.resetElevationChart();\n    }\n}\n","import logger from 'loglevel';\nimport helpers from './helpers';\nimport Route from './Route';\nimport Context from './Context';\nimport Controls from './Controls';\n\n\n// Constants\nconst NORMAL_ROUTE_MIN_LENGTH = 40; // kilometers\nconst SHORT_NORMAL_ROUTE_MIN_LENGTH = 30; // kilometers\nconst SHORT_NORMAL_ROUTE_MIN_ELEVATION_GAIN = 500; // meters\n\n// Google Maps API loading and key validation\nwindow.GOOGLE_MAPS_API_LOADED = true;\nwindow.gm_authFailure = () => { window.GOOGLE_MAPS_API_LOADED = false; };\n\nfunction verifyRoute() {\n    if (!window.GOOGLE_MAPS_API_LOADED || !window.google || !window.google.maps) {\n        window.GOOGLE_MAPS_API_LOADED = false;\n        logger.error('Google Maps API is not loaded. Verification cannot be done.');\n    }\n    const context = new Context();\n    const controls = new Controls();\n\n    controls.resetAll();\n    controls.addLoaderToButton();\n\n    helpers.getRoute(context.routeUrl)\n        .done(data => {\n            const geoJson = helpers.getGeoJSON(data);\n            const route = new Route(geoJson);\n\n            if (!route.isVerifiable()) {\n                logger.error('Route is unverifiable.');\n                controls.resetAll(false);\n                return;\n            }\n\n            // Path basic checks\n            const isSinglePath = route.isSinglePath();\n            controls.updateSinglePath(isSinglePath);\n\n            const routeLength = route.getPathLength();\n\n            const isPathLengthValid = true;\n            controls.updatePathLength(isPathLengthValid, routeLength);\n\n            // Station checks\n            const areAllStationsPresent = route.areAllStationsPresent();\n            controls.updateNumberOfStations(areAllStationsPresent);\n            const isStationOrderCorrect = route.isStationOrderCorrect();\n            controls.updateStationsOrder(isStationOrderCorrect);\n            const areStationsOnThePath = route.areStationsOnThePath();\n            controls.updateStationsOnPath(areStationsOnThePath);\n\n            // Elevation checks\n            route.fetchPathElevationData()\n                .then(() => {\n                    const pathElevation = route.getPathElevation();\n                    pathElevation.enrichData(routeLength);\n\n                    const isPathElevationGainValid = true;\n                    controls.updateElevationGain(isPathElevationGainValid, pathElevation.gain);\n\n                    const isNormalRoute = routeLength >= NORMAL_ROUTE_MIN_LENGTH\n                        || pathElevation.gain > SHORT_NORMAL_ROUTE_MIN_ELEVATION_GAIN\n                        && routeLength >= SHORT_NORMAL_ROUTE_MIN_LENGTH;\n                    controls.updateRouteType(isNormalRoute);\n\n                    const isPathElevationLossValid = true;\n                    controls.updateElevationLoss(isPathElevationLossValid, pathElevation.loss);\n\n                    const isPathElevationTotalChangeValid = true;\n                    controls.updateElevationTotalChange(isPathElevationTotalChangeValid,\n                        pathElevation.totalChange);\n\n                    controls.drawElevationChart(pathElevation);\n\n                    helpers.getRouteParameters(context.routeParamsUrl)\n                        .then(parameters => {\n                            const ACCEPTED_ROUTE_LENGTH_DIFF = 1; // km\n                            const ACCEPTED_ELEVATION_GAIN_DIFF = 50; // m\n                            const NORMAL_ROUTE_TYPE = 0;\n                            const INSPIRED_ROUTE_TYPE = 1;\n                            /* eslint-disable max-len */\n                            const isLengthConsistent = (routeLength - ACCEPTED_ROUTE_LENGTH_DIFF <= parameters.length\n                                && parameters.length <= routeLength + ACCEPTED_ROUTE_LENGTH_DIFF);\n                            const isElevationGainConsistent = (pathElevation.gain - ACCEPTED_ELEVATION_GAIN_DIFF <= parameters.ascent\n                                && parameters.ascent <= pathElevation.gain + ACCEPTED_ELEVATION_GAIN_DIFF);\n                            const isRouteTypeConsistent = parameters.type === (isNormalRoute ? NORMAL_ROUTE_TYPE : INSPIRED_ROUTE_TYPE);\n                            const isDataConsistent = isLengthConsistent && isElevationGainConsistent && isRouteTypeConsistent;\n\n                            logger.debug('isLengthConsistent:', isLengthConsistent,\n                                ', isElevationGainConsistent:', isElevationGainConsistent,\n                                ', isRouteTypeConsistent:', isRouteTypeConsistent);\n                            controls.updateDataConsistency(isDataConsistent);\n\n                            const canRouteBeAutomaticallyApproved = isSinglePath && isPathLengthValid\n                                && areAllStationsPresent && isStationOrderCorrect\n                                && areStationsOnThePath && isPathElevationGainValid\n                                && isPathElevationLossValid && isPathElevationTotalChangeValid\n                                && isDataConsistent;\n\n                            if (canRouteBeAutomaticallyApproved) {\n                                logger.info('Route verification success. Approving...');\n                                helpers.approveRoute(context.routeApproveUrl)\n                                    .then(() => {\n                                        logger.info('Route approved.');\n                                        const pageReloadModalElement = $('div#pageReloadModal');\n                                        const reloadTimeout = setTimeout(() => {\n                                            window.location.reload(1);\n                                        }, 5000);\n                                        pageReloadModalElement.on('hide.bs.modal', e => clearTimeout(reloadTimeout));\n                                        pageReloadModalElement.modal();\n                                    })\n                                    .catch(error => {\n                                        logger.error('Route approval error.', error);\n                                    });\n                            } else {\n                                logger.info('Route verification failed. Cannot be approved.');\n                            }\n                        })\n                        .catch(error => {\n                            logger.error('Route parameters data fetching error.', error);\n                        });\n                })\n                .catch(error => {\n                    logger.error('Path elevation data fetching error.', error);\n                    controls.updateElevationGain(false, 0);\n                    controls.updateElevationLoss(false, 0);\n                    controls.updateElevationTotalChange(false, 0);\n                    controls.updateDataConsistency(false);\n                });\n        }).fail((xhr, status) => {\n            logger.error('Route fetching error. Status:', status);\n        }).always(() => {\n            controls.removeLoaderFromButton();\n        });\n}\n\nif (process.env.NODE_ENV === 'production') {\n    logger.setLevel('warn');\n} else {\n    logger.setLevel('debug');\n}\nwindow.setLogLevel = (logLevel = 'debug') => logger.setLevel(logLevel);\n\n$('button#verifyRoute').bind('click', verifyRoute);\n"],"sourceRoot":""}