{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/loglevel/lib/loglevel.js","webpack:///./node_modules/lodash/isArray.js","webpack:///./node_modules/lodash/_root.js","webpack:///./node_modules/lodash/_getNative.js","webpack:///./node_modules/lodash/isArrayLike.js","webpack:///./node_modules/lodash/isSymbol.js","webpack:///./node_modules/lodash/identity.js","webpack:///./node_modules/lodash/_baseGetTag.js","webpack:///./node_modules/lodash/_Symbol.js","webpack:///./node_modules/lodash/isObject.js","webpack:///./node_modules/lodash/isObjectLike.js","webpack:///./node_modules/lodash/_baseIteratee.js","webpack:///./node_modules/lodash/isArguments.js","webpack:///./node_modules/lodash/_ListCache.js","webpack:///./node_modules/lodash/_assocIndexOf.js","webpack:///./node_modules/lodash/_nativeCreate.js","webpack:///./node_modules/lodash/_getMapData.js","webpack:///./node_modules/lodash/keys.js","webpack:///./node_modules/lodash/_toKey.js","webpack:///./node_modules/@turf/helpers/index.js","webpack:///./node_modules/lodash/_Map.js","webpack:///./node_modules/lodash/isLength.js","webpack:///./node_modules/lodash/isBuffer.js","webpack:///./node_modules/lodash/isTypedArray.js","webpack:///./node_modules/lodash/_baseIsEqual.js","webpack:///./node_modules/lodash/eq.js","webpack:///./node_modules/lodash/_MapCache.js","webpack:///./node_modules/lodash/_isIndex.js","webpack:///./node_modules/lodash/_baseEach.js","webpack:///./node_modules/lodash/_isKey.js","webpack:///./node_modules/lodash/_arrayMap.js","webpack:///./node_modules/lodash/isEmpty.js","webpack:///./node_modules/lodash/_baseKeys.js","webpack:///./node_modules/lodash/_isPrototype.js","webpack:///./node_modules/lodash/_getTag.js","webpack:///./node_modules/lodash/isFunction.js","webpack:///./node_modules/lodash/_freeGlobal.js","webpack:///./node_modules/lodash/_toSource.js","webpack:///(webpack)/buildin/module.js","webpack:///./node_modules/lodash/_baseUnary.js","webpack:///./node_modules/lodash/isEqual.js","webpack:///./node_modules/lodash/_Stack.js","webpack:///./node_modules/lodash/_equalArrays.js","webpack:///./node_modules/lodash/_arrayPush.js","webpack:///./node_modules/lodash/_arrayFilter.js","webpack:///./node_modules/lodash/isNull.js","webpack:///./node_modules/lodash/filter.js","webpack:///./node_modules/lodash/_isStrictComparable.js","webpack:///./node_modules/lodash/_matchesStrictComparable.js","webpack:///./node_modules/lodash/_baseGet.js","webpack:///./node_modules/lodash/_castPath.js","webpack:///./node_modules/lodash/find.js","webpack:///./node_modules/lodash/forEach.js","webpack:///./node_modules/lodash/map.js","webpack:///./node_modules/lodash/_baseMap.js","webpack:///./node_modules/lodash/min.js","webpack:///./node_modules/lodash/sortBy.js","webpack:///./node_modules/togeojson/togeojson.js","webpack:///./node_modules/@turf/distance/index.js","webpack:///./node_modules/process/browser.js","webpack:///./node_modules/lodash/_nativeKeys.js","webpack:///./node_modules/lodash/_overArg.js","webpack:///./node_modules/lodash/_DataView.js","webpack:///./node_modules/lodash/_baseIsNative.js","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/lodash/_getRawTag.js","webpack:///./node_modules/lodash/_objectToString.js","webpack:///./node_modules/lodash/_isMasked.js","webpack:///./node_modules/lodash/_coreJsData.js","webpack:///./node_modules/lodash/_getValue.js","webpack:///./node_modules/lodash/_Promise.js","webpack:///./node_modules/lodash/_Set.js","webpack:///./node_modules/lodash/_WeakMap.js","webpack:///./node_modules/lodash/_baseIsArguments.js","webpack:///./node_modules/lodash/stubFalse.js","webpack:///./node_modules/lodash/_baseIsTypedArray.js","webpack:///./node_modules/lodash/_nodeUtil.js","webpack:///./node_modules/lodash/_baseIsEqualDeep.js","webpack:///./node_modules/lodash/_listCacheClear.js","webpack:///./node_modules/lodash/_listCacheDelete.js","webpack:///./node_modules/lodash/_listCacheGet.js","webpack:///./node_modules/lodash/_listCacheHas.js","webpack:///./node_modules/lodash/_listCacheSet.js","webpack:///./node_modules/lodash/_stackClear.js","webpack:///./node_modules/lodash/_stackDelete.js","webpack:///./node_modules/lodash/_stackGet.js","webpack:///./node_modules/lodash/_stackHas.js","webpack:///./node_modules/lodash/_stackSet.js","webpack:///./node_modules/lodash/_mapCacheClear.js","webpack:///./node_modules/lodash/_Hash.js","webpack:///./node_modules/lodash/_hashClear.js","webpack:///./node_modules/lodash/_hashDelete.js","webpack:///./node_modules/lodash/_hashGet.js","webpack:///./node_modules/lodash/_hashHas.js","webpack:///./node_modules/lodash/_hashSet.js","webpack:///./node_modules/lodash/_mapCacheDelete.js","webpack:///./node_modules/lodash/_isKeyable.js","webpack:///./node_modules/lodash/_mapCacheGet.js","webpack:///./node_modules/lodash/_mapCacheHas.js","webpack:///./node_modules/lodash/_mapCacheSet.js","webpack:///./node_modules/lodash/_SetCache.js","webpack:///./node_modules/lodash/_setCacheAdd.js","webpack:///./node_modules/lodash/_setCacheHas.js","webpack:///./node_modules/lodash/_arraySome.js","webpack:///./node_modules/lodash/_cacheHas.js","webpack:///./node_modules/lodash/_equalByTag.js","webpack:///./node_modules/lodash/_Uint8Array.js","webpack:///./node_modules/lodash/_mapToArray.js","webpack:///./node_modules/lodash/_setToArray.js","webpack:///./node_modules/lodash/_equalObjects.js","webpack:///./node_modules/lodash/_getAllKeys.js","webpack:///./node_modules/lodash/_baseGetAllKeys.js","webpack:///./node_modules/lodash/_getSymbols.js","webpack:///./node_modules/lodash/stubArray.js","webpack:///./node_modules/lodash/_arrayLikeKeys.js","webpack:///./node_modules/lodash/_baseTimes.js","webpack:///./node_modules/lodash/_baseFilter.js","webpack:///./node_modules/lodash/_baseForOwn.js","webpack:///./node_modules/lodash/_baseFor.js","webpack:///./node_modules/lodash/_createBaseFor.js","webpack:///./node_modules/lodash/_createBaseEach.js","webpack:///./node_modules/lodash/_baseMatches.js","webpack:///./node_modules/lodash/_baseIsMatch.js","webpack:///./node_modules/lodash/_getMatchData.js","webpack:///./node_modules/lodash/_baseMatchesProperty.js","webpack:///./node_modules/lodash/get.js","webpack:///./node_modules/lodash/_stringToPath.js","webpack:///./node_modules/lodash/_memoizeCapped.js","webpack:///./node_modules/lodash/memoize.js","webpack:///./node_modules/lodash/toString.js","webpack:///./node_modules/lodash/_baseToString.js","webpack:///./node_modules/lodash/hasIn.js","webpack:///./node_modules/lodash/_baseHasIn.js","webpack:///./node_modules/lodash/_hasPath.js","webpack:///./node_modules/lodash/property.js","webpack:///./node_modules/lodash/_baseProperty.js","webpack:///./node_modules/lodash/_basePropertyDeep.js","webpack:///./node_modules/lodash/_createFind.js","webpack:///./node_modules/lodash/findIndex.js","webpack:///./node_modules/lodash/_baseFindIndex.js","webpack:///./node_modules/lodash/toInteger.js","webpack:///./node_modules/lodash/toFinite.js","webpack:///./node_modules/lodash/toNumber.js","webpack:///./node_modules/lodash/_arrayEach.js","webpack:///./node_modules/lodash/_castFunction.js","webpack:///./node_modules/lodash/_baseExtremum.js","webpack:///./node_modules/lodash/_baseLt.js","webpack:///./node_modules/lodash/_baseFlatten.js","webpack:///./node_modules/lodash/_isFlattenable.js","webpack:///./node_modules/lodash/_baseOrderBy.js","webpack:///./node_modules/lodash/_baseSortBy.js","webpack:///./node_modules/lodash/_compareMultiple.js","webpack:///./node_modules/lodash/_compareAscending.js","webpack:///./node_modules/lodash/_baseRest.js","webpack:///./node_modules/lodash/_overRest.js","webpack:///./node_modules/lodash/_apply.js","webpack:///./node_modules/lodash/_setToString.js","webpack:///./node_modules/lodash/_baseSetToString.js","webpack:///./node_modules/lodash/constant.js","webpack:///./node_modules/lodash/_defineProperty.js","webpack:///./node_modules/lodash/_shortOut.js","webpack:///./node_modules/lodash/_isIterateeCall.js","webpack:///./node_modules/@turf/invariant/index.js","webpack:///./node_modules/@turf/meta/node_modules/@turf/helpers/main.es.js","webpack:///./node_modules/@turf/meta/main.es.js","webpack:///./node_modules/@turf/flatten/node_modules/@turf/helpers/main.es.js","webpack:///./node_modules/@turf/flatten/main.es.js","webpack:///./src/helpers.js","webpack:///./src/PathElevation.js","webpack:///./node_modules/@turf/bearing/node_modules/@turf/invariant/index.js","webpack:///./node_modules/@turf/bearing/index.js","webpack:///./node_modules/@turf/point-on-line/node_modules/@turf/invariant/index.js","webpack:///./node_modules/@turf/point-on-line/node_modules/@turf/helpers/index.js","webpack:///./node_modules/@turf/point-on-line/node_modules/@turf/distance/index.js","webpack:///./node_modules/@turf/destination/node_modules/@turf/invariant/index.js","webpack:///./node_modules/@turf/destination/node_modules/@turf/helpers/index.js","webpack:///./node_modules/@turf/destination/index.js","webpack:///./node_modules/@turf/point-on-line/node_modules/geojson-rbush/quickselect.js","webpack:///./node_modules/@turf/point-on-line/node_modules/geojson-rbush/rbush.js","webpack:///./node_modules/@turf/point-on-line/node_modules/@turf/meta/index.js","webpack:///./node_modules/@turf/point-on-line/node_modules/geojson-rbush/index.js","webpack:///./node_modules/@turf/point-on-line/node_modules/@turf/line-segment/node_modules/@turf/helpers/main.es.js","webpack:///./node_modules/@turf/point-on-line/node_modules/@turf/line-segment/node_modules/@turf/invariant/main.es.js","webpack:///./node_modules/@turf/point-on-line/node_modules/@turf/line-segment/node_modules/@turf/meta/main.es.js","webpack:///./node_modules/@turf/point-on-line/node_modules/@turf/line-segment/main.es.js","webpack:///./node_modules/@turf/point-on-line/node_modules/@turf/line-intersect/node_modules/@turf/helpers/main.es.js","webpack:///./node_modules/@turf/point-on-line/node_modules/@turf/line-intersect/node_modules/@turf/invariant/main.es.js","webpack:///./node_modules/@turf/point-on-line/node_modules/@turf/line-intersect/node_modules/@turf/meta/main.es.js","webpack:///./node_modules/@turf/point-on-line/node_modules/@turf/line-intersect/main.es.js","webpack:///./node_modules/@turf/point-on-line/index.js","webpack:///./src/Stations.js","webpack:///./src/Route.js","webpack:///./src/Context.js","webpack:///./src/Controls.js","webpack:///./src/routeVerifier.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","root","definition","undefined","noop","undefinedType","logMethods","bindMethod","obj","methodName","method","Function","e","apply","arguments","replaceLoggingMethods","level","loggerName","length","this","methodFactory","log","debug","defaultMethodFactory","console","realMethod","Logger","defaultLevel","factory","currentLevel","self","storageKey","getPersistedLevel","storedLevel","window","localStorage","ignore","cookie","document","location","indexOf","encodeURIComponent","exec","slice","levels","TRACE","DEBUG","INFO","WARN","ERROR","SILENT","getLevel","setLevel","persist","toUpperCase","levelNum","levelName","persistLevelIfPossible","setDefaultLevel","enableAll","disableAll","initialLevel","defaultLogger","_loggersByName","getLogger","TypeError","logger","_log","noConflict","getLoggers","isArray","Array","freeGlobal","freeSelf","baseIsNative","getValue","isFunction","isLength","baseGetTag","isObjectLike","symbolTag","getRawTag","objectToString","nullTag","undefinedTag","symToStringTag","type","baseMatches","baseMatchesProperty","identity","baseIsArguments","objectProto","propertyIsEnumerable","isArguments","listCacheClear","listCacheDelete","listCacheGet","listCacheHas","listCacheSet","ListCache","entries","index","clear","entry","set","has","eq","array","nativeCreate","getNative","isKeyable","map","data","__data__","arrayLikeKeys","baseKeys","isArrayLike","isSymbol","INFINITY","result","feature","geom","properties","options","feat","id","bbox","geometry","point","coordinates","polygon","_i","coordinates_1","ring","Error","j","lineString","featureCollection","features","fc","multiLineString","multiPoint","multiPolygon","radiansToLength","radians","units","factor","factors","lengthToRadians","distance","radiansToDegrees","Math","PI","isNumber","num","isNaN","test","earthRadius","centimeters","centimetres","degrees","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","yards","unitsFactors","areaFactors","acres","points","coords","polygons","lineStrings","geometryCollection","geometries","round","precision","multiplier","pow","lengthToDegrees","bearingToAzimuth","bearing","angle","degreesToRadians","convertLength","originalUnit","finalUnit","convertArea","area","startFactor","finalFactor","isObject","input","constructor","validateBBox","forEach","validateId","radians2degrees","degrees2radians","distanceToDegrees","distanceToRadians","radiansToDistance","bearingToAngle","convertDistance","Map","MAX_SAFE_INTEGER","stubFalse","freeExports","nodeType","freeModule","Buffer","isBuffer","baseIsTypedArray","baseUnary","nodeUtil","nodeIsTypedArray","isTypedArray","baseIsEqualDeep","baseIsEqual","other","bitmask","customizer","stack","mapCacheClear","mapCacheDelete","mapCacheGet","mapCacheHas","mapCacheSet","MapCache","reIsUint","baseForOwn","baseEach","createBaseEach","reIsDeepProp","reIsPlainProp","iteratee","getTag","isPrototype","mapTag","setTag","splice","tag","size","nativeKeys","push","Ctor","DataView","Promise","Set","WeakMap","toSource","dataViewCtorString","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","ArrayBuffer","resolve","ctorString","asyncTag","funcTag","genTag","proxyTag","global","funcToString","toString","func","webpackPolyfill","deprecate","paths","children","stackClear","stackDelete","stackGet","stackHas","stackSet","Stack","SetCache","arraySome","cacheHas","COMPARE_PARTIAL_FLAG","COMPARE_UNORDERED_FLAG","equalFunc","isPartial","arrLength","othLength","stacked","seen","arrValue","othValue","compared","othIndex","values","offset","predicate","resIndex","arrayFilter","baseFilter","baseIteratee","collection","srcValue","castPath","toKey","path","isKey","stringToPath","find","createFind","arrayEach","castFunction","arrayMap","baseMap","baseExtremum","baseLt","baseFlatten","baseOrderBy","baseRest","isIterateeCall","sortBy","iteratees","process","toGeoJSON","serializer","removeSpace","trimSpace","splitSpace","okhash","x","h","charCodeAt","y","getElementsByTagName","attr","getAttribute","attrf","parseFloat","get1","numarray","nodeVal","el","normalize","textContent","getMulti","ys","k","extend","coord1","v","replace","split","coord","coordPair","ll","ele","heartRate","time","xml2str","str","xml","serializeToString","XMLSerializer","browser","kml","doc","gj","styleIndex","styleByHash","styleMapIndex","geotypes","placemarks","styles","styleMaps","hash","pairs","pairsMap","concat","getPlacemark","kmlColor","color","opacity","substr","parseInt","gxCoords","elems","times","timeElems","geomsAndTimes","getGeometry","geomNode","geomNodes","geoms","coordTimes","rings","track","styleUrl","description","timeSpan","timeStamp","extendedData","lineStyle","polyStyle","visibility","styleHash","styleMapHash","normal","style","begin","end","timespan","timestamp","linestyles","width","stroke","polystyles","pcolor","popacity","fill","outline","datas","simpleDatas","gpx","tracks","routes","waypoints","getTrack","getRoute","getPoint","getPoints","node","pointname","pts","line","heartRates","segments","getProperties","prop","links","link","href","invariant_1","helpers_1","default","from","to","coordinates1","getCoord","coordinates2","dLat","dLon","lat1","lat2","a","sin","cos","atan2","sqrt","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","len","run","marker","runClearTimeout","Item","nextTick","args","title","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","overArg","keys","transform","arg","isMasked","reIsHostCtor","funcProto","reIsNative","RegExp","g","nativeObjectToString","isOwn","unmasked","uid","coreJsData","maskSrcKey","IE_PROTO","argsTag","typedArrayTags","freeProcess","types","require","equalArrays","equalByTag","equalObjects","arrayTag","objectTag","objIsArr","othIsArr","objTag","othTag","objIsObj","othIsObj","isSameTag","objIsWrapped","othIsWrapped","objUnwrapped","othUnwrapped","assocIndexOf","pop","LARGE_ARRAY_SIZE","Hash","string","hashClear","hashDelete","hashGet","hashHas","hashSet","HASH_UNDEFINED","getMapData","setCacheAdd","setCacheHas","add","cache","Uint8Array","mapToArray","setToArray","boolTag","dateTag","errorTag","numberTag","regexpTag","stringTag","arrayBufferTag","dataViewTag","symbolProto","symbolValueOf","valueOf","byteLength","byteOffset","buffer","message","convert","getAllKeys","objProps","objLength","skipCtor","objValue","objCtor","othCtor","baseGetAllKeys","getSymbols","arrayPush","keysFunc","symbolsFunc","stubArray","nativeGetSymbols","getOwnPropertySymbols","symbol","baseTimes","isIndex","inherited","isArr","isArg","isBuff","isType","skipIndexes","String","baseFor","createBaseFor","fromRight","iterable","props","eachFunc","baseIsMatch","getMatchData","matchesStrictComparable","source","matchData","noCustomizer","isStrictComparable","hasIn","baseGet","defaultValue","memoizeCapped","rePropName","reEscapeChar","match","number","quote","subString","memoize","MAX_MEMOIZE_SIZE","FUNC_ERROR_TEXT","resolver","memoized","Cache","baseToString","symbolToString","baseHasIn","hasPath","hasFunc","baseProperty","basePropertyDeep","findIndexFunc","fromIndex","baseFindIndex","toInteger","nativeMax","max","toFinite","remainder","toNumber","MAX_INTEGER","NAN","reTrim","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","isBinary","comparator","current","computed","isFlattenable","depth","isStrict","spreadableSymbol","isConcatSpreadable","baseSortBy","compareMultiple","orders","criteria","comparer","sort","compareAscending","objCriteria","othCriteria","ordersLength","valIsDefined","valIsNull","valIsReflexive","valIsSymbol","othIsDefined","othIsNull","othIsReflexive","othIsSymbol","overRest","setToString","start","otherArgs","thisArg","baseSetToString","shortOut","constant","configurable","writable","HOT_COUNT","HOT_SPAN","nativeNow","Date","now","count","lastCalled","stamp","remaining","getCoords","containsNumber","geojsonType","featureOf","collectionOf","_a","getGeom","geojson","getType","main_es_feature","geomEach","callback","stopG","geometryMaybeCollection","isGeometryCollection","featureProperties","featureBBox","featureId","featureIndex","isFeatureCollection","isFeature","stop","flattenEach","geomType","multiFeatureIndex","coordinate","main_es_featureCollection","main_es_isObject","main_es_validateBBox","main_es_validateId","main_es_isNumber","main_es","results","Helpers","parentNode","removeChild","geoJson","flatten","featureName","_","newLineString","reverse","routeUrl","$","ajax","element","google","maps","LatLng","useLocalElevations","elevations","elevation","reject","getGoogleMapsPath","optimizedPath","delta","floor","ElevationService","getElevationAlongPath","samples","status","ElevationStatus","OK","routeParamsUrl","done","success","error","fail","xhr","routeApproveUrl","getGain","elevationGain","elevationDifference","Number","getLoss","elevationLoss","PathElevation","PathElevation_classCallCheck","gain","loss","totalChange","elevationsWithDistance","resolution","bearing_bearing","final","bear","calculateFinalBearing","lon1","lon2","b","_turf_bearing","invariant_getCoord","invariant_getCoords","invariant_containsNumber","helpers_feature","helpers_point","helpers_isNumber","helpers_lineString","helpers_factors","helpers_radiansToDistance","_turf_distance","_turf_invariant_getCoord","_turf_invariant_containsNumber","_turf_invariant_getCoords","_turf_helpers_feature","_turf_helpers_point","_turf_helpers_isNumber","_turf_helpers_factors","_turf_helpers_distanceToRadians","_turf_destination","origin","longitude1","latitude1","bearing_rad","latitude2","asin","swap","arr","tmp","defaultCompare","geojson_rbush_quickselect","left","right","compare","quickselectStep","z","exp","sd","newLeft","newRight","min","rbush","maxEntries","format","_maxEntries","_minEntries","ceil","_initFormat","findItem","item","items","equalsFn","calcBBox","toBBox","distBBox","destNode","createNode","minX","Infinity","minY","maxX","maxY","child","leaf","compareNodeMinX","compareNodeMinY","bboxArea","bboxMargin","contains","intersects","height","multiSelect","mid","all","_all","search","childBBox","nodesToSearch","collides","load","insert","_build","_splitRoot","tmpNode","_insert","remove","parent","goingUp","indexes","_condense","compareMinX","compareMinY","toJSON","fromJSON","N","M","right2","right3","N2","N1","_chooseSubtree","targetNode","enlargement","minArea","minEnlargement","isNode","insertPath","_split","_adjustParentBBoxes","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","bbox1","bbox2","overlap","minOverlap","_allDistMargin","leftBBox","rightBBox","margin","siblings","compareArr","join","geojson_rbush_rbush","meta_coordEach","excludeWrapCoord","geometryIndex","wrapShrink","coordIndex","featureSubIndex","meta_featureEach","meta_geomEach","geometryProperties","meta_flattenEach","meta_feature","bboxPolygon","lowLeft","topLeft","topRight","turfBBox","geojson_rbush","tree","json","_turf_helpers_main_es_feature","helpers_main_es_isObject","helpers_main_es_validateBBox","helpers_main_es_validateId","_turf_helpers_main_es_lineString","helpers_main_es_isNumber","helpers_main_es_featureCollection","main_es_getCoords","main_es_geomEach","main_es_flattenEach","line_segment_main_es","reduce","previousCoords","currentCoords","coords1","coords2","x1","y1","x2","y2","segment","createSegments","lineSegmentFeature","node_modules_turf_helpers_main_es_feature","_turf_helpers_main_es_isObject","_turf_helpers_main_es_validateBBox","_turf_helpers_main_es_validateId","_turf_helpers_main_es_point","_turf_helpers_main_es_isNumber","_turf_helpers_main_es_featureCollection","invariant_main_es_getCoords","meta_main_es_featureEach","main_es_intersects","line1","line2","x3","y3","x4","y4","denom","numeA","numeB","uA","uB","line_intersect_main_es","unique","intersect","point_on_line","lines","pt","closestPt","dist","sectionLength","heightDistance","direction","perpendicularPt1","perpendicularPt2","intersectPt","turf","pointOnLine","CONSTS","Stations","Stations_classCallCheck","pathReversed","pathCircular","pathStart","pathEnd","_sortPoints","_addIndexes","_updateCircularity","_updateDirection","enhancedPoints","nearestOnLine","sortedPoints","START_NAMES_REGEX","END_NAMES_REGEX","ROMAN_NUMBERS_REGEX","EUROPEAN_NUMBERS_REGEX","ROMAN_EUROPEAN_MAP","I","II","III","IV","V","VI","VII","VIII","IX","X","XI","XII","XIII","XIV","parts","trim","part","matches","stationNumber","getIndex","startPoint","endPoint","endPointToPathStartDistance","toFixed","_this","numberOfStations","_loop","firstStationName","stationsOfNumber","station","warn","currentStationNumber","previousStationNumber","maximumDistanceFromPath","distanceFromStationToPath","Route","Route_classCallCheck","helpers","getLineString","isRouteVerifiable","stations","isPathReversed","reverseLineString","numberOfPaths","getNumberOfFeatures","getCount","areAllOnThePath","isOrderCorrect","googleMapsPath","spherical","computeLength","getPathElevations","then","pathElevation","catch","Context","mapCanvasElement","updateControlColor","isValid","VALID_COLOR_CLASS","INVALID_COLOR_CLASS","removeClass","addClass","updateControlValue","unit","html","Controls","isNormalRoute","normalRouteString","inspiredRouteString","isLengthValid","isElevationGainValid","isElevationLossValid","isElevationTotalChangeValid","elevationTotalChange","areAllStationsPresent","isStationOrderCorrect","areAllStationsOnPath","isSinglePath","isDataConsistent","labelWidth","labels","Chart","datasets","label","radius","backgroundColor","scales","xAxes","scaleLabel","display","labelString","ticks","dataLabel","yAxes","legend","tooltips","enabled","elevationChartParentElement","append","VERIFY_BUTTON_ID","resetElevationChart","NORMAL_ROUTE_MIN_LENGTH","SHORT_NORMAL_ROUTE_MIN_LENGTH","SHORT_NORMAL_ROUTE_MIN_ELEVATION_GAIN","setLogLevel","logLevel","context","controls","resetAll","addLoaderToButton","getGeoJSON","route","isVerifiable","updateSinglePath","routeLength","getPathLength","updatePathLength","updateNumberOfStations","updateStationsOrder","areStationsOnThePath","updateStationsOnPath","fetchPathElevationData","getPathElevation","enrichData","updateElevationGain","updateRouteType","updateElevationLoss","updateElevationTotalChange","drawElevationChart","getRouteParameters","parameters","isLengthConsistent","isElevationGainConsistent","ascent","isRouteTypeConsistent","updateDataConsistency","info","approveRoute","pageReloadModalElement","reloadTimeout","reload","modal","always","removeLoaderFromButton"],"mappings":"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","file":"edk-route-verifier.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 164);\n","/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      var storageKey = \"loglevel\";\n      if (name) {\n        storageKey += \":\" + name;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== \"string\" || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    return defaultLogger;\n}));\n","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","var baseIsNative = require('./_baseIsNative'),\n    getValue = require('./_getValue');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n","var isFunction = require('./isFunction'),\n    isLength = require('./isLength');\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var baseMatches = require('./_baseMatches'),\n    baseMatchesProperty = require('./_baseMatchesProperty'),\n    identity = require('./identity'),\n    isArray = require('./isArray'),\n    property = require('./property');\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\nmodule.exports = baseIteratee;\n","var baseIsArguments = require('./_baseIsArguments'),\n    isObjectLike = require('./isObjectLike');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n","var listCacheClear = require('./_listCacheClear'),\n    listCacheDelete = require('./_listCacheDelete'),\n    listCacheGet = require('./_listCacheGet'),\n    listCacheHas = require('./_listCacheHas'),\n    listCacheSet = require('./_listCacheSet');\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n","var eq = require('./eq');\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n","var getNative = require('./_getNative');\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n","var isKeyable = require('./_isKeyable');\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n","var arrayLikeKeys = require('./_arrayLikeKeys'),\n    baseKeys = require('./_baseKeys'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n","var isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = toKey;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.370,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.370,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, options) {\n    if (options === void 0) { options = {}; }\n    switch (type) {\n        case \"Point\": return point(coordinates).geometry;\n        case \"LineString\": return lineString(coordinates).geometry;\n        case \"Polygon\": return polygon(coordinates).geometry;\n        case \"MultiPoint\": return multiPoint(coordinates).geometry;\n        case \"MultiLineString\": return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\": return multiPolygon(coordinates).geometry;\n        default: throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\\s*$/.test(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error(\"method has been renamed to `radiansToDegrees`\");\n}\nexports.radians2degrees = radians2degrees;\nfunction degrees2radians() {\n    throw new Error(\"method has been renamed to `degreesToRadians`\");\n}\nexports.degrees2radians = degrees2radians;\nfunction distanceToDegrees() {\n    throw new Error(\"method has been renamed to `lengthToDegrees`\");\n}\nexports.distanceToDegrees = distanceToDegrees;\nfunction distanceToRadians() {\n    throw new Error(\"method has been renamed to `lengthToRadians`\");\n}\nexports.distanceToRadians = distanceToRadians;\nfunction radiansToDistance() {\n    throw new Error(\"method has been renamed to `radiansToLength`\");\n}\nexports.radiansToDistance = radiansToDistance;\nfunction bearingToAngle() {\n    throw new Error(\"method has been renamed to `bearingToAzimuth`\");\n}\nexports.bearingToAngle = bearingToAngle;\nfunction convertDistance() {\n    throw new Error(\"method has been renamed to `convertLength`\");\n}\nexports.convertDistance = convertDistance;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n","var root = require('./_root'),\n    stubFalse = require('./stubFalse');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n","var baseIsTypedArray = require('./_baseIsTypedArray'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n","var baseIsEqualDeep = require('./_baseIsEqualDeep'),\n    isObjectLike = require('./isObjectLike');\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\nmodule.exports = baseIsEqual;\n","/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n","var mapCacheClear = require('./_mapCacheClear'),\n    mapCacheDelete = require('./_mapCacheDelete'),\n    mapCacheGet = require('./_mapCacheGet'),\n    mapCacheHas = require('./_mapCacheHas'),\n    mapCacheSet = require('./_mapCacheSet');\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n","/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n","var baseForOwn = require('./_baseForOwn'),\n    createBaseEach = require('./_createBaseEach');\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\nmodule.exports = baseEach;\n","var isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nmodule.exports = isKey;\n","/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n","var baseKeys = require('./_baseKeys'),\n    getTag = require('./_getTag'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isArrayLike = require('./isArrayLike'),\n    isBuffer = require('./isBuffer'),\n    isPrototype = require('./_isPrototype'),\n    isTypedArray = require('./isTypedArray');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    setTag = '[object Set]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if `value` is an empty object, collection, map, or set.\n *\n * Objects are considered empty if they have no own enumerable string keyed\n * properties.\n *\n * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n * jQuery-like collections are considered empty if they have a `length` of `0`.\n * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n * @example\n *\n * _.isEmpty(null);\n * // => true\n *\n * _.isEmpty(true);\n * // => true\n *\n * _.isEmpty(1);\n * // => true\n *\n * _.isEmpty([1, 2, 3]);\n * // => false\n *\n * _.isEmpty({ 'a': 1 });\n * // => false\n */\nfunction isEmpty(value) {\n  if (value == null) {\n    return true;\n  }\n  if (isArrayLike(value) &&\n      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n        isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n    return !value.length;\n  }\n  var tag = getTag(value);\n  if (tag == mapTag || tag == setTag) {\n    return !value.size;\n  }\n  if (isPrototype(value)) {\n    return !baseKeys(value).length;\n  }\n  for (var key in value) {\n    if (hasOwnProperty.call(value, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = isEmpty;\n","var isPrototype = require('./_isPrototype'),\n    nativeKeys = require('./_nativeKeys');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n","var DataView = require('./_DataView'),\n    Map = require('./_Map'),\n    Promise = require('./_Promise'),\n    Set = require('./_Set'),\n    WeakMap = require('./_WeakMap'),\n    baseGetTag = require('./_baseGetTag'),\n    toSource = require('./_toSource');\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nmodule.exports = getTag;\n","var baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n","var baseIsEqual = require('./_baseIsEqual');\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\nmodule.exports = isEqual;\n","var ListCache = require('./_ListCache'),\n    stackClear = require('./_stackClear'),\n    stackDelete = require('./_stackDelete'),\n    stackGet = require('./_stackGet'),\n    stackHas = require('./_stackHas'),\n    stackSet = require('./_stackSet');\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nmodule.exports = Stack;\n","var SetCache = require('./_SetCache'),\n    arraySome = require('./_arraySome'),\n    cacheHas = require('./_cacheHas');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalArrays;\n","/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n","/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayFilter;\n","/**\n * Checks if `value` is `null`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n * @example\n *\n * _.isNull(null);\n * // => true\n *\n * _.isNull(void 0);\n * // => false\n */\nfunction isNull(value) {\n  return value === null;\n}\n\nmodule.exports = isNull;\n","var arrayFilter = require('./_arrayFilter'),\n    baseFilter = require('./_baseFilter'),\n    baseIteratee = require('./_baseIteratee'),\n    isArray = require('./isArray');\n\n/**\n * Iterates over elements of `collection`, returning an array of all elements\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * **Note:** Unlike `_.remove`, this method returns a new array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n * @see _.reject\n * @example\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': true },\n *   { 'user': 'fred',   'age': 40, 'active': false }\n * ];\n *\n * _.filter(users, function(o) { return !o.active; });\n * // => objects for ['fred']\n *\n * // The `_.matches` iteratee shorthand.\n * _.filter(users, { 'age': 36, 'active': true });\n * // => objects for ['barney']\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.filter(users, ['active', false]);\n * // => objects for ['fred']\n *\n * // The `_.property` iteratee shorthand.\n * _.filter(users, 'active');\n * // => objects for ['barney']\n */\nfunction filter(collection, predicate) {\n  var func = isArray(collection) ? arrayFilter : baseFilter;\n  return func(collection, baseIteratee(predicate, 3));\n}\n\nmodule.exports = filter;\n","var isObject = require('./isObject');\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\nmodule.exports = isStrictComparable;\n","/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\nmodule.exports = matchesStrictComparable;\n","var castPath = require('./_castPath'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n","var isArray = require('./isArray'),\n    isKey = require('./_isKey'),\n    stringToPath = require('./_stringToPath'),\n    toString = require('./toString');\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nmodule.exports = castPath;\n","var createFind = require('./_createFind'),\n    findIndex = require('./findIndex');\n\n/**\n * Iterates over elements of `collection`, returning the first element\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {*} Returns the matched element, else `undefined`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'age': 36, 'active': true },\n *   { 'user': 'fred',    'age': 40, 'active': false },\n *   { 'user': 'pebbles', 'age': 1,  'active': true }\n * ];\n *\n * _.find(users, function(o) { return o.age < 40; });\n * // => object for 'barney'\n *\n * // The `_.matches` iteratee shorthand.\n * _.find(users, { 'age': 1, 'active': true });\n * // => object for 'pebbles'\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.find(users, ['active', false]);\n * // => object for 'fred'\n *\n * // The `_.property` iteratee shorthand.\n * _.find(users, 'active');\n * // => object for 'barney'\n */\nvar find = createFind(findIndex);\n\nmodule.exports = find;\n","var arrayEach = require('./_arrayEach'),\n    baseEach = require('./_baseEach'),\n    castFunction = require('./_castFunction'),\n    isArray = require('./isArray');\n\n/**\n * Iterates over elements of `collection` and invokes `iteratee` for each element.\n * The iteratee is invoked with three arguments: (value, index|key, collection).\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n * property are iterated like arrays. To avoid this behavior use `_.forIn`\n * or `_.forOwn` for object iteration.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @alias each\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n * @see _.forEachRight\n * @example\n *\n * _.forEach([1, 2], function(value) {\n *   console.log(value);\n * });\n * // => Logs `1` then `2`.\n *\n * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n *   console.log(key);\n * });\n * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n */\nfunction forEach(collection, iteratee) {\n  var func = isArray(collection) ? arrayEach : baseEach;\n  return func(collection, castFunction(iteratee));\n}\n\nmodule.exports = forEach;\n","var arrayMap = require('./_arrayMap'),\n    baseIteratee = require('./_baseIteratee'),\n    baseMap = require('./_baseMap'),\n    isArray = require('./isArray');\n\n/**\n * Creates an array of values by running each element in `collection` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n *\n * The guarded methods are:\n * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n * @example\n *\n * function square(n) {\n *   return n * n;\n * }\n *\n * _.map([4, 8], square);\n * // => [16, 64]\n *\n * _.map({ 'a': 4, 'b': 8 }, square);\n * // => [16, 64] (iteration order is not guaranteed)\n *\n * var users = [\n *   { 'user': 'barney' },\n *   { 'user': 'fred' }\n * ];\n *\n * // The `_.property` iteratee shorthand.\n * _.map(users, 'user');\n * // => ['barney', 'fred']\n */\nfunction map(collection, iteratee) {\n  var func = isArray(collection) ? arrayMap : baseMap;\n  return func(collection, baseIteratee(iteratee, 3));\n}\n\nmodule.exports = map;\n","var baseEach = require('./_baseEach'),\n    isArrayLike = require('./isArrayLike');\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\nmodule.exports = baseMap;\n","var baseExtremum = require('./_baseExtremum'),\n    baseLt = require('./_baseLt'),\n    identity = require('./identity');\n\n/**\n * Computes the minimum value of `array`. If `array` is empty or falsey,\n * `undefined` is returned.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {*} Returns the minimum value.\n * @example\n *\n * _.min([4, 2, 8, 6]);\n * // => 2\n *\n * _.min([]);\n * // => undefined\n */\nfunction min(array) {\n  return (array && array.length)\n    ? baseExtremum(array, identity, baseLt)\n    : undefined;\n}\n\nmodule.exports = min;\n","var baseFlatten = require('./_baseFlatten'),\n    baseOrderBy = require('./_baseOrderBy'),\n    baseRest = require('./_baseRest'),\n    isIterateeCall = require('./_isIterateeCall');\n\n/**\n * Creates an array of elements, sorted in ascending order by the results of\n * running each element in a collection thru each iteratee. This method\n * performs a stable sort, that is, it preserves the original sort order of\n * equal elements. The iteratees are invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {...(Function|Function[])} [iteratees=[_.identity]]\n *  The iteratees to sort by.\n * @returns {Array} Returns the new sorted array.\n * @example\n *\n * var users = [\n *   { 'user': 'fred',   'age': 48 },\n *   { 'user': 'barney', 'age': 36 },\n *   { 'user': 'fred',   'age': 40 },\n *   { 'user': 'barney', 'age': 34 }\n * ];\n *\n * _.sortBy(users, [function(o) { return o.user; }]);\n * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n *\n * _.sortBy(users, ['user', 'age']);\n * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]\n */\nvar sortBy = baseRest(function(collection, iteratees) {\n  if (collection == null) {\n    return [];\n  }\n  var length = iteratees.length;\n  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n    iteratees = [];\n  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n    iteratees = [iteratees[0]];\n  }\n  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n});\n\nmodule.exports = sortBy;\n","var toGeoJSON = (function() {\n    'use strict';\n\n    var removeSpace = /\\s*/g,\n        trimSpace = /^\\s*|\\s*$/g,\n        splitSpace = /\\s+/;\n    // generate a short, numeric hash of a string\n    function okhash(x) {\n        if (!x || !x.length) return 0;\n        for (var i = 0, h = 0; i < x.length; i++) {\n            h = ((h << 5) - h) + x.charCodeAt(i) | 0;\n        } return h;\n    }\n    // all Y children of X\n    function get(x, y) { return x.getElementsByTagName(y); }\n    function attr(x, y) { return x.getAttribute(y); }\n    function attrf(x, y) { return parseFloat(attr(x, y)); }\n    // one Y child of X, if any, otherwise null\n    function get1(x, y) { var n = get(x, y); return n.length ? n[0] : null; }\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node.normalize\n    function norm(el) { if (el.normalize) { el.normalize(); } return el; }\n    // cast array x into numbers\n    function numarray(x) {\n        for (var j = 0, o = []; j < x.length; j++) { o[j] = parseFloat(x[j]); }\n        return o;\n    }\n    // get the content of a text node, if any\n    function nodeVal(x) {\n        if (x) { norm(x); }\n        return (x && x.textContent) || '';\n    }\n    // get the contents of multiple text nodes, if present\n    function getMulti(x, ys) {\n        var o = {}, n, k;\n        for (k = 0; k < ys.length; k++) {\n            n = get1(x, ys[k]);\n            if (n) o[ys[k]] = nodeVal(n);\n        }\n        return o;\n    }\n    // add properties of Y to X, overwriting if present in both\n    function extend(x, y) { for (var k in y) x[k] = y[k]; }\n    // get one coordinate from a coordinate array, if any\n    function coord1(v) { return numarray(v.replace(removeSpace, '').split(',')); }\n    // get all coordinates from a coordinate array as [[],[]]\n    function coord(v) {\n        var coords = v.replace(trimSpace, '').split(splitSpace),\n            o = [];\n        for (var i = 0; i < coords.length; i++) {\n            o.push(coord1(coords[i]));\n        }\n        return o;\n    }\n    function coordPair(x) {\n        var ll = [attrf(x, 'lon'), attrf(x, 'lat')],\n            ele = get1(x, 'ele'),\n            // handle namespaced attribute in browser\n            heartRate = get1(x, 'gpxtpx:hr') || get1(x, 'hr'),\n            time = get1(x, 'time'),\n            e;\n        if (ele) {\n            e = parseFloat(nodeVal(ele));\n            if (!isNaN(e)) {\n                ll.push(e);\n            }\n        }\n        return {\n            coordinates: ll,\n            time: time ? nodeVal(time) : null,\n            heartRate: heartRate ? parseFloat(nodeVal(heartRate)) : null\n        };\n    }\n\n    // create a new feature collection parent object\n    function fc() {\n        return {\n            type: 'FeatureCollection',\n            features: []\n        };\n    }\n\n    var serializer;\n    if (typeof XMLSerializer !== 'undefined') {\n        /* istanbul ignore next */\n        serializer = new XMLSerializer();\n    // only require xmldom in a node environment\n    } else if (typeof exports === 'object' && typeof process === 'object' && !process.browser) {\n        serializer = new (require('xmldom').XMLSerializer)();\n    }\n    function xml2str(str) {\n        // IE9 will create a new XMLSerializer but it'll crash immediately.\n        // This line is ignored because we don't run coverage tests in IE9\n        /* istanbul ignore next */\n        if (str.xml !== undefined) return str.xml;\n        return serializer.serializeToString(str);\n    }\n\n    var t = {\n        kml: function(doc) {\n\n            var gj = fc(),\n                // styleindex keeps track of hashed styles in order to match features\n                styleIndex = {}, styleByHash = {},\n                // stylemapindex keeps track of style maps to expose in properties\n                styleMapIndex = {},\n                // atomic geospatial types supported by KML - MultiGeometry is\n                // handled separately\n                geotypes = ['Polygon', 'LineString', 'Point', 'Track', 'gx:Track'],\n                // all root placemarks in the file\n                placemarks = get(doc, 'Placemark'),\n                styles = get(doc, 'Style'),\n                styleMaps = get(doc, 'StyleMap');\n\n            for (var k = 0; k < styles.length; k++) {\n                var hash = okhash(xml2str(styles[k])).toString(16);\n                styleIndex['#' + attr(styles[k], 'id')] = hash;\n                styleByHash[hash] = styles[k];\n            }\n            for (var l = 0; l < styleMaps.length; l++) {\n                styleIndex['#' + attr(styleMaps[l], 'id')] = okhash(xml2str(styleMaps[l])).toString(16);\n                var pairs = get(styleMaps[l], 'Pair');\n                var pairsMap = {};\n                for (var m = 0; m < pairs.length; m++) {\n                    pairsMap[nodeVal(get1(pairs[m], 'key'))] = nodeVal(get1(pairs[m], 'styleUrl'));\n                }\n                styleMapIndex['#' + attr(styleMaps[l], 'id')] = pairsMap;\n\n            }\n            for (var j = 0; j < placemarks.length; j++) {\n                gj.features = gj.features.concat(getPlacemark(placemarks[j]));\n            }\n            function kmlColor(v) {\n                var color, opacity;\n                v = v || '';\n                if (v.substr(0, 1) === '#') { v = v.substr(1); }\n                if (v.length === 6 || v.length === 3) { color = v; }\n                if (v.length === 8) {\n                    opacity = parseInt(v.substr(0, 2), 16) / 255;\n                    color = '#' + v.substr(6, 2) +\n                        v.substr(4, 2) +\n                        v.substr(2, 2);\n                }\n                return [color, isNaN(opacity) ? undefined : opacity];\n            }\n            function gxCoord(v) { return numarray(v.split(' ')); }\n            function gxCoords(root) {\n                var elems = get(root, 'coord', 'gx'), coords = [], times = [];\n                if (elems.length === 0) elems = get(root, 'gx:coord');\n                for (var i = 0; i < elems.length; i++) coords.push(gxCoord(nodeVal(elems[i])));\n                var timeElems = get(root, 'when');\n                for (var j = 0; j < timeElems.length; j++) times.push(nodeVal(timeElems[j]));\n                return {\n                    coords: coords,\n                    times: times\n                };\n            }\n            function getGeometry(root) {\n                var geomNode, geomNodes, i, j, k, geoms = [], coordTimes = [];\n                if (get1(root, 'MultiGeometry')) { return getGeometry(get1(root, 'MultiGeometry')); }\n                if (get1(root, 'MultiTrack')) { return getGeometry(get1(root, 'MultiTrack')); }\n                if (get1(root, 'gx:MultiTrack')) { return getGeometry(get1(root, 'gx:MultiTrack')); }\n                for (i = 0; i < geotypes.length; i++) {\n                    geomNodes = get(root, geotypes[i]);\n                    if (geomNodes) {\n                        for (j = 0; j < geomNodes.length; j++) {\n                            geomNode = geomNodes[j];\n                            if (geotypes[i] === 'Point') {\n                                geoms.push({\n                                    type: 'Point',\n                                    coordinates: coord1(nodeVal(get1(geomNode, 'coordinates')))\n                                });\n                            } else if (geotypes[i] === 'LineString') {\n                                geoms.push({\n                                    type: 'LineString',\n                                    coordinates: coord(nodeVal(get1(geomNode, 'coordinates')))\n                                });\n                            } else if (geotypes[i] === 'Polygon') {\n                                var rings = get(geomNode, 'LinearRing'),\n                                    coords = [];\n                                for (k = 0; k < rings.length; k++) {\n                                    coords.push(coord(nodeVal(get1(rings[k], 'coordinates'))));\n                                }\n                                geoms.push({\n                                    type: 'Polygon',\n                                    coordinates: coords\n                                });\n                            } else if (geotypes[i] === 'Track' ||\n                                geotypes[i] === 'gx:Track') {\n                                var track = gxCoords(geomNode);\n                                geoms.push({\n                                    type: 'LineString',\n                                    coordinates: track.coords\n                                });\n                                if (track.times.length) coordTimes.push(track.times);\n                            }\n                        }\n                    }\n                }\n                return {\n                    geoms: geoms,\n                    coordTimes: coordTimes\n                };\n            }\n            function getPlacemark(root) {\n                var geomsAndTimes = getGeometry(root), i, properties = {},\n                    name = nodeVal(get1(root, 'name')),\n                    styleUrl = nodeVal(get1(root, 'styleUrl')),\n                    description = nodeVal(get1(root, 'description')),\n                    timeSpan = get1(root, 'TimeSpan'),\n                    timeStamp = get1(root, 'TimeStamp'),\n                    extendedData = get1(root, 'ExtendedData'),\n                    lineStyle = get1(root, 'LineStyle'),\n                    polyStyle = get1(root, 'PolyStyle'),\n                    visibility = get1(root, 'visibility');\n\n                if (!geomsAndTimes.geoms.length) return [];\n                if (name) properties.name = name;\n                if (styleUrl) {\n                    if (styleUrl[0] !== '#') {\n                        styleUrl = '#' + styleUrl;\n                    }\n\n                    properties.styleUrl = styleUrl;\n                    if (styleIndex[styleUrl]) {\n                        properties.styleHash = styleIndex[styleUrl];\n                    }\n                    if (styleMapIndex[styleUrl]) {\n                        properties.styleMapHash = styleMapIndex[styleUrl];\n                        properties.styleHash = styleIndex[styleMapIndex[styleUrl].normal];\n                    }\n                    // Try to populate the lineStyle or polyStyle since we got the style hash\n                    var style = styleByHash[properties.styleHash];\n                    if (style) {\n                        if (!lineStyle) lineStyle = get1(style, 'LineStyle');\n                        if (!polyStyle) polyStyle = get1(style, 'PolyStyle');\n                    }\n                }\n                if (description) properties.description = description;\n                if (timeSpan) {\n                    var begin = nodeVal(get1(timeSpan, 'begin'));\n                    var end = nodeVal(get1(timeSpan, 'end'));\n                    properties.timespan = { begin: begin, end: end };\n                }\n                if (timeStamp) {\n                    properties.timestamp = nodeVal(get1(timeStamp, 'when'));\n                }\n                if (lineStyle) {\n                    var linestyles = kmlColor(nodeVal(get1(lineStyle, 'color'))),\n                        color = linestyles[0],\n                        opacity = linestyles[1],\n                        width = parseFloat(nodeVal(get1(lineStyle, 'width')));\n                    if (color) properties.stroke = color;\n                    if (!isNaN(opacity)) properties['stroke-opacity'] = opacity;\n                    if (!isNaN(width)) properties['stroke-width'] = width;\n                }\n                if (polyStyle) {\n                    var polystyles = kmlColor(nodeVal(get1(polyStyle, 'color'))),\n                        pcolor = polystyles[0],\n                        popacity = polystyles[1],\n                        fill = nodeVal(get1(polyStyle, 'fill')),\n                        outline = nodeVal(get1(polyStyle, 'outline'));\n                    if (pcolor) properties.fill = pcolor;\n                    if (!isNaN(popacity)) properties['fill-opacity'] = popacity;\n                    if (fill) properties['fill-opacity'] = fill === '1' ? properties['fill-opacity'] || 1 : 0;\n                    if (outline) properties['stroke-opacity'] = outline === '1' ? properties['stroke-opacity'] || 1 : 0;\n                }\n                if (extendedData) {\n                    var datas = get(extendedData, 'Data'),\n                        simpleDatas = get(extendedData, 'SimpleData');\n\n                    for (i = 0; i < datas.length; i++) {\n                        properties[datas[i].getAttribute('name')] = nodeVal(get1(datas[i], 'value'));\n                    }\n                    for (i = 0; i < simpleDatas.length; i++) {\n                        properties[simpleDatas[i].getAttribute('name')] = nodeVal(simpleDatas[i]);\n                    }\n                }\n                if (visibility) {\n                    properties.visibility = nodeVal(visibility);\n                }\n                if (geomsAndTimes.coordTimes.length) {\n                    properties.coordTimes = (geomsAndTimes.coordTimes.length === 1) ?\n                        geomsAndTimes.coordTimes[0] : geomsAndTimes.coordTimes;\n                }\n                var feature = {\n                    type: 'Feature',\n                    geometry: (geomsAndTimes.geoms.length === 1) ? geomsAndTimes.geoms[0] : {\n                        type: 'GeometryCollection',\n                        geometries: geomsAndTimes.geoms\n                    },\n                    properties: properties\n                };\n                if (attr(root, 'id')) feature.id = attr(root, 'id');\n                return [feature];\n            }\n            return gj;\n        },\n        gpx: function(doc) {\n            var i,\n                tracks = get(doc, 'trk'),\n                routes = get(doc, 'rte'),\n                waypoints = get(doc, 'wpt'),\n                // a feature collection\n                gj = fc(),\n                feature;\n            for (i = 0; i < tracks.length; i++) {\n                feature = getTrack(tracks[i]);\n                if (feature) gj.features.push(feature);\n            }\n            for (i = 0; i < routes.length; i++) {\n                feature = getRoute(routes[i]);\n                if (feature) gj.features.push(feature);\n            }\n            for (i = 0; i < waypoints.length; i++) {\n                gj.features.push(getPoint(waypoints[i]));\n            }\n            function getPoints(node, pointname) {\n                var pts = get(node, pointname),\n                    line = [],\n                    times = [],\n                    heartRates = [],\n                    l = pts.length;\n                if (l < 2) return {};  // Invalid line in GeoJSON\n                for (var i = 0; i < l; i++) {\n                    var c = coordPair(pts[i]);\n                    line.push(c.coordinates);\n                    if (c.time) times.push(c.time);\n                    if (c.heartRate) heartRates.push(c.heartRate);\n                }\n                return {\n                    line: line,\n                    times: times,\n                    heartRates: heartRates\n                };\n            }\n            function getTrack(node) {\n                var segments = get(node, 'trkseg'),\n                    track = [],\n                    times = [],\n                    heartRates = [],\n                    line;\n                for (var i = 0; i < segments.length; i++) {\n                    line = getPoints(segments[i], 'trkpt');\n                    if (line) {\n                        if (line.line) track.push(line.line);\n                        if (line.times && line.times.length) times.push(line.times);\n                        if (line.heartRates && line.heartRates.length) heartRates.push(line.heartRates);\n                    }\n                }\n                if (track.length === 0) return;\n                var properties = getProperties(node);\n                if (times.length) properties.coordTimes = track.length === 1 ? times[0] : times;\n                if (heartRates.length) properties.heartRates = track.length === 1 ? heartRates[0] : heartRates;\n                return {\n                    type: 'Feature',\n                    properties: properties,\n                    geometry: {\n                        type: track.length === 1 ? 'LineString' : 'MultiLineString',\n                        coordinates: track.length === 1 ? track[0] : track\n                    }\n                };\n            }\n            function getRoute(node) {\n                var line = getPoints(node, 'rtept');\n                if (!line.line) return;\n                var routeObj = {\n                    type: 'Feature',\n                    properties: getProperties(node),\n                    geometry: {\n                        type: 'LineString',\n                        coordinates: line.line\n                    }\n                };\n                return routeObj;\n            }\n            function getPoint(node) {\n                var prop = getProperties(node);\n                extend(prop, getMulti(node, ['sym', 'type']));\n                return {\n                    type: 'Feature',\n                    properties: prop,\n                    geometry: {\n                        type: 'Point',\n                        coordinates: coordPair(node).coordinates\n                    }\n                };\n            }\n            function getProperties(node) {\n                var prop, links;\n                prop = getMulti(node, ['name', 'cmt', 'desc', 'time', 'keywords']);\n                links = get(node, 'link');\n                if (links.length) prop.links = [];\n                for (var i = 0, link; i < links.length; i++) {\n                    link = { href: attr(links[i], 'href') };\n                    extend(link, getMulti(links[i], ['text', 'type']));\n                    prop.links.push(link);\n                }\n                return prop;\n            }\n            return gj;\n        }\n    };\n    return t;\n})();\n\nif (typeof module !== 'undefined') module.exports = toGeoJSON;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar invariant_1 = require(\"@turf/invariant\");\nvar helpers_1 = require(\"@turf/helpers\");\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians, miles, or kilometers.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name distance\n * @param {Coord} from origin point\n * @param {Coord} to destination point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.distance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n    if (options === void 0) { options = {}; }\n    var coordinates1 = invariant_1.getCoord(from);\n    var coordinates2 = invariant_1.getCoord(to);\n    var dLat = helpers_1.degreesToRadians((coordinates2[1] - coordinates1[1]));\n    var dLon = helpers_1.degreesToRadians((coordinates2[0] - coordinates1[0]));\n    var lat1 = helpers_1.degreesToRadians(coordinates1[1]);\n    var lat2 = helpers_1.degreesToRadians(coordinates2[1]);\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n        Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n    return helpers_1.radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);\n}\nexports.default = distance;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var overArg = require('./_overArg');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nmodule.exports = DataView;\n","var isFunction = require('./isFunction'),\n    isMasked = require('./_isMasked'),\n    isObject = require('./isObject'),\n    toSource = require('./_toSource');\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","var coreJsData = require('./_coreJsData');\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n","var root = require('./_root');\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nmodule.exports = Promise;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nmodule.exports = Set;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nmodule.exports = WeakMap;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n","/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n","var baseGetTag = require('./_baseGetTag'),\n    isLength = require('./isLength'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n","var Stack = require('./_Stack'),\n    equalArrays = require('./_equalArrays'),\n    equalByTag = require('./_equalByTag'),\n    equalObjects = require('./_equalObjects'),\n    getTag = require('./_getTag'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\nmodule.exports = baseIsEqualDeep;\n","/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n","var ListCache = require('./_ListCache');\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\nmodule.exports = stackClear;\n","/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\nmodule.exports = stackDelete;\n","/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nmodule.exports = stackGet;\n","/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nmodule.exports = stackHas;\n","var ListCache = require('./_ListCache'),\n    Map = require('./_Map'),\n    MapCache = require('./_MapCache');\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nmodule.exports = stackSet;\n","var Hash = require('./_Hash'),\n    ListCache = require('./_ListCache'),\n    Map = require('./_Map');\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n","var hashClear = require('./_hashClear'),\n    hashDelete = require('./_hashDelete'),\n    hashGet = require('./_hashGet'),\n    hashHas = require('./_hashHas'),\n    hashSet = require('./_hashSet');\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n","var nativeCreate = require('./_nativeCreate');\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n","/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n","var getMapData = require('./_getMapData');\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n","/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n","var getMapData = require('./_getMapData');\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n","var getMapData = require('./_getMapData');\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n","var getMapData = require('./_getMapData');\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n","var MapCache = require('./_MapCache'),\n    setCacheAdd = require('./_setCacheAdd'),\n    setCacheHas = require('./_setCacheHas');\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\nmodule.exports = SetCache;\n","/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\nmodule.exports = setCacheAdd;\n","/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\nmodule.exports = setCacheHas;\n","/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arraySome;\n","/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\nmodule.exports = cacheHas;\n","var Symbol = require('./_Symbol'),\n    Uint8Array = require('./_Uint8Array'),\n    eq = require('./eq'),\n    equalArrays = require('./_equalArrays'),\n    mapToArray = require('./_mapToArray'),\n    setToArray = require('./_setToArray');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]';\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\nmodule.exports = equalByTag;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Uint8Array = root.Uint8Array;\n\nmodule.exports = Uint8Array;\n","/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\nmodule.exports = mapToArray;\n","/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nmodule.exports = setToArray;\n","var getAllKeys = require('./_getAllKeys');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalObjects;\n","var baseGetAllKeys = require('./_baseGetAllKeys'),\n    getSymbols = require('./_getSymbols'),\n    keys = require('./keys');\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\nmodule.exports = getAllKeys;\n","var arrayPush = require('./_arrayPush'),\n    isArray = require('./isArray');\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\nmodule.exports = baseGetAllKeys;\n","var arrayFilter = require('./_arrayFilter'),\n    stubArray = require('./stubArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\nmodule.exports = getSymbols;\n","/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\nmodule.exports = stubArray;\n","var baseTimes = require('./_baseTimes'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isBuffer = require('./isBuffer'),\n    isIndex = require('./_isIndex'),\n    isTypedArray = require('./isTypedArray');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n","/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n","var baseEach = require('./_baseEach');\n\n/**\n * The base implementation of `_.filter` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction baseFilter(collection, predicate) {\n  var result = [];\n  baseEach(collection, function(value, index, collection) {\n    if (predicate(value, index, collection)) {\n      result.push(value);\n    }\n  });\n  return result;\n}\n\nmodule.exports = baseFilter;\n","var baseFor = require('./_baseFor'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n","var createBaseFor = require('./_createBaseFor');\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n","/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n","var isArrayLike = require('./isArrayLike');\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\nmodule.exports = createBaseEach;\n","var baseIsMatch = require('./_baseIsMatch'),\n    getMatchData = require('./_getMatchData'),\n    matchesStrictComparable = require('./_matchesStrictComparable');\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\nmodule.exports = baseMatches;\n","var Stack = require('./_Stack'),\n    baseIsEqual = require('./_baseIsEqual');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nmodule.exports = baseIsMatch;\n","var isStrictComparable = require('./_isStrictComparable'),\n    keys = require('./keys');\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\nmodule.exports = getMatchData;\n","var baseIsEqual = require('./_baseIsEqual'),\n    get = require('./get'),\n    hasIn = require('./hasIn'),\n    isKey = require('./_isKey'),\n    isStrictComparable = require('./_isStrictComparable'),\n    matchesStrictComparable = require('./_matchesStrictComparable'),\n    toKey = require('./_toKey');\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\nmodule.exports = baseMatchesProperty;\n","var baseGet = require('./_baseGet');\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n","var memoizeCapped = require('./_memoizeCapped');\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nmodule.exports = stringToPath;\n","var memoize = require('./memoize');\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nmodule.exports = memoizeCapped;\n","var MapCache = require('./_MapCache');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n","var baseToString = require('./_baseToString');\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nmodule.exports = toString;\n","var Symbol = require('./_Symbol'),\n    arrayMap = require('./_arrayMap'),\n    isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = baseToString;\n","var baseHasIn = require('./_baseHasIn'),\n    hasPath = require('./_hasPath');\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\nmodule.exports = hasIn;\n","/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\nmodule.exports = baseHasIn;\n","var castPath = require('./_castPath'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isIndex = require('./_isIndex'),\n    isLength = require('./isLength'),\n    toKey = require('./_toKey');\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\nmodule.exports = hasPath;\n","var baseProperty = require('./_baseProperty'),\n    basePropertyDeep = require('./_basePropertyDeep'),\n    isKey = require('./_isKey'),\n    toKey = require('./_toKey');\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nmodule.exports = property;\n","/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = baseProperty;\n","var baseGet = require('./_baseGet');\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\nmodule.exports = basePropertyDeep;\n","var baseIteratee = require('./_baseIteratee'),\n    isArrayLike = require('./isArrayLike'),\n    keys = require('./keys');\n\n/**\n * Creates a `_.find` or `_.findLast` function.\n *\n * @private\n * @param {Function} findIndexFunc The function to find the collection index.\n * @returns {Function} Returns the new find function.\n */\nfunction createFind(findIndexFunc) {\n  return function(collection, predicate, fromIndex) {\n    var iterable = Object(collection);\n    if (!isArrayLike(collection)) {\n      var iteratee = baseIteratee(predicate, 3);\n      collection = keys(collection);\n      predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n    }\n    var index = findIndexFunc(collection, predicate, fromIndex);\n    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n  };\n}\n\nmodule.exports = createFind;\n","var baseFindIndex = require('./_baseFindIndex'),\n    baseIteratee = require('./_baseIteratee'),\n    toInteger = require('./toInteger');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\n * // => 0\n *\n * // The `_.matches` iteratee shorthand.\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findIndex(users, ['active', false]);\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.findIndex(users, 'active');\n * // => 2\n */\nfunction findIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index);\n}\n\nmodule.exports = findIndex;\n","/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = baseFindIndex;\n","var toFinite = require('./toFinite');\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nmodule.exports = toInteger;\n","var toNumber = require('./toNumber');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nmodule.exports = toFinite;\n","var isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n","/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n","var identity = require('./identity');\n\n/**\n * Casts `value` to `identity` if it's not a function.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Function} Returns cast function.\n */\nfunction castFunction(value) {\n  return typeof value == 'function' ? value : identity;\n}\n\nmodule.exports = castFunction;\n","var isSymbol = require('./isSymbol');\n\n/**\n * The base implementation of methods like `_.max` and `_.min` which accepts a\n * `comparator` to determine the extremum value.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The iteratee invoked per iteration.\n * @param {Function} comparator The comparator used to compare values.\n * @returns {*} Returns the extremum value.\n */\nfunction baseExtremum(array, iteratee, comparator) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    var value = array[index],\n        current = iteratee(value);\n\n    if (current != null && (computed === undefined\n          ? (current === current && !isSymbol(current))\n          : comparator(current, computed)\n        )) {\n      var computed = current,\n          result = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseExtremum;\n","/**\n * The base implementation of `_.lt` which doesn't coerce arguments.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if `value` is less than `other`,\n *  else `false`.\n */\nfunction baseLt(value, other) {\n  return value < other;\n}\n\nmodule.exports = baseLt;\n","var arrayPush = require('./_arrayPush'),\n    isFlattenable = require('./_isFlattenable');\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseFlatten;\n","var Symbol = require('./_Symbol'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray');\n\n/** Built-in value references. */\nvar spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\nmodule.exports = isFlattenable;\n","var arrayMap = require('./_arrayMap'),\n    baseIteratee = require('./_baseIteratee'),\n    baseMap = require('./_baseMap'),\n    baseSortBy = require('./_baseSortBy'),\n    baseUnary = require('./_baseUnary'),\n    compareMultiple = require('./_compareMultiple'),\n    identity = require('./identity');\n\n/**\n * The base implementation of `_.orderBy` without param guards.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n * @param {string[]} orders The sort orders of `iteratees`.\n * @returns {Array} Returns the new sorted array.\n */\nfunction baseOrderBy(collection, iteratees, orders) {\n  var index = -1;\n  iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));\n\n  var result = baseMap(collection, function(value, key, collection) {\n    var criteria = arrayMap(iteratees, function(iteratee) {\n      return iteratee(value);\n    });\n    return { 'criteria': criteria, 'index': ++index, 'value': value };\n  });\n\n  return baseSortBy(result, function(object, other) {\n    return compareMultiple(object, other, orders);\n  });\n}\n\nmodule.exports = baseOrderBy;\n","/**\n * The base implementation of `_.sortBy` which uses `comparer` to define the\n * sort order of `array` and replaces criteria objects with their corresponding\n * values.\n *\n * @private\n * @param {Array} array The array to sort.\n * @param {Function} comparer The function to define sort order.\n * @returns {Array} Returns `array`.\n */\nfunction baseSortBy(array, comparer) {\n  var length = array.length;\n\n  array.sort(comparer);\n  while (length--) {\n    array[length] = array[length].value;\n  }\n  return array;\n}\n\nmodule.exports = baseSortBy;\n","var compareAscending = require('./_compareAscending');\n\n/**\n * Used by `_.orderBy` to compare multiple properties of a value to another\n * and stable sort them.\n *\n * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n * of corresponding values.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {boolean[]|string[]} orders The order to sort by for each property.\n * @returns {number} Returns the sort order indicator for `object`.\n */\nfunction compareMultiple(object, other, orders) {\n  var index = -1,\n      objCriteria = object.criteria,\n      othCriteria = other.criteria,\n      length = objCriteria.length,\n      ordersLength = orders.length;\n\n  while (++index < length) {\n    var result = compareAscending(objCriteria[index], othCriteria[index]);\n    if (result) {\n      if (index >= ordersLength) {\n        return result;\n      }\n      var order = orders[index];\n      return result * (order == 'desc' ? -1 : 1);\n    }\n  }\n  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n  // that causes it, under certain circumstances, to provide the same value for\n  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n  // for more details.\n  //\n  // This also ensures a stable sort in V8 and other engines.\n  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n  return object.index - other.index;\n}\n\nmodule.exports = compareMultiple;\n","var isSymbol = require('./isSymbol');\n\n/**\n * Compares values to sort them in ascending order.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {number} Returns the sort order indicator for `value`.\n */\nfunction compareAscending(value, other) {\n  if (value !== other) {\n    var valIsDefined = value !== undefined,\n        valIsNull = value === null,\n        valIsReflexive = value === value,\n        valIsSymbol = isSymbol(value);\n\n    var othIsDefined = other !== undefined,\n        othIsNull = other === null,\n        othIsReflexive = other === other,\n        othIsSymbol = isSymbol(other);\n\n    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n        (valIsNull && othIsDefined && othIsReflexive) ||\n        (!valIsDefined && othIsReflexive) ||\n        !valIsReflexive) {\n      return 1;\n    }\n    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n        (othIsNull && valIsDefined && valIsReflexive) ||\n        (!othIsDefined && valIsReflexive) ||\n        !othIsReflexive) {\n      return -1;\n    }\n  }\n  return 0;\n}\n\nmodule.exports = compareAscending;\n","var identity = require('./identity'),\n    overRest = require('./_overRest'),\n    setToString = require('./_setToString');\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\nmodule.exports = baseRest;\n","var apply = require('./_apply');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\nmodule.exports = overRest;\n","/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\nmodule.exports = apply;\n","var baseSetToString = require('./_baseSetToString'),\n    shortOut = require('./_shortOut');\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\nmodule.exports = setToString;\n","var constant = require('./constant'),\n    defineProperty = require('./_defineProperty'),\n    identity = require('./identity');\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\nmodule.exports = baseSetToString;\n","/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\nmodule.exports = constant;\n","var getNative = require('./_getNative');\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nmodule.exports = defineProperty;\n","/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeNow = Date.now;\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\nmodule.exports = shortOut;\n","var eq = require('./eq'),\n    isArrayLike = require('./isArrayLike'),\n    isIndex = require('./_isIndex'),\n    isObject = require('./isObject');\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\nmodule.exports = isIterateeCall;\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"@turf/helpers\");\r\n/**\r\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\r\n *\r\n * @name getCoord\r\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\r\n * @returns {Array<number>} coordinates\r\n * @example\r\n * var pt = turf.point([10, 10]);\r\n *\r\n * var coord = turf.getCoord(pt);\r\n * //= [10, 10]\r\n */\r\nfunction getCoord(coord) {\r\n    if (!coord) {\r\n        throw new Error(\"coord is required\");\r\n    }\r\n    if (!Array.isArray(coord)) {\r\n        if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\r\n            return coord.geometry.coordinates;\r\n        }\r\n        if (coord.type === \"Point\") {\r\n            return coord.coordinates;\r\n        }\r\n    }\r\n    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\r\n        return coord;\r\n    }\r\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\r\n}\r\nexports.getCoord = getCoord;\r\n/**\r\n * Unwrap coordinates from a Feature, Geometry Object or an Array\r\n *\r\n * @name getCoords\r\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\r\n * @returns {Array<any>} coordinates\r\n * @example\r\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\r\n *\r\n * var coords = turf.getCoords(poly);\r\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\r\n */\r\nfunction getCoords(coords) {\r\n    if (Array.isArray(coords)) {\r\n        return coords;\r\n    }\r\n    // Feature\r\n    if (coords.type === \"Feature\") {\r\n        if (coords.geometry !== null) {\r\n            return coords.geometry.coordinates;\r\n        }\r\n    }\r\n    else {\r\n        // Geometry\r\n        if (coords.coordinates) {\r\n            return coords.coordinates;\r\n        }\r\n    }\r\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\r\n}\r\nexports.getCoords = getCoords;\r\n/**\r\n * Checks if coordinates contains a number\r\n *\r\n * @name containsNumber\r\n * @param {Array<any>} coordinates GeoJSON Coordinates\r\n * @returns {boolean} true if Array contains a number\r\n */\r\nfunction containsNumber(coordinates) {\r\n    if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\r\n        return containsNumber(coordinates[0]);\r\n    }\r\n    throw new Error(\"coordinates must only contain numbers\");\r\n}\r\nexports.containsNumber = containsNumber;\r\n/**\r\n * Enforce expectations about types of GeoJSON objects for Turf.\r\n *\r\n * @name geojsonType\r\n * @param {GeoJSON} value any GeoJSON object\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction geojsonType(value, type, name) {\r\n    if (!type || !name) {\r\n        throw new Error(\"type and name required\");\r\n    }\r\n    if (!value || value.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type);\r\n    }\r\n}\r\nexports.geojsonType = geojsonType;\r\n/**\r\n * Enforce expectations about types of {@link Feature} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name featureOf\r\n * @param {Feature} feature a feature with an expected geometry type\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} error if value is not the expected type.\r\n */\r\nfunction featureOf(feature, type, name) {\r\n    if (!feature) {\r\n        throw new Error(\"No feature passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".featureOf() requires a name\");\r\n    }\r\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n    }\r\n    if (!feature.geometry || feature.geometry.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n    }\r\n}\r\nexports.featureOf = featureOf;\r\n/**\r\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name collectionOf\r\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction collectionOf(featureCollection, type, name) {\r\n    if (!featureCollection) {\r\n        throw new Error(\"No featureCollection passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".collectionOf() requires a name\");\r\n    }\r\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\r\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\r\n    }\r\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\r\n        var feature = _a[_i];\r\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n        }\r\n        if (!feature.geometry || feature.geometry.type !== type) {\r\n            throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n        }\r\n    }\r\n}\r\nexports.collectionOf = collectionOf;\r\n/**\r\n * Get Geometry from Feature or Geometry Object\r\n *\r\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\r\n * @returns {Geometry|null} GeoJSON Geometry Object\r\n * @throws {Error} if geojson is not a Feature or Geometry Object\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getGeom(point)\r\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\r\n */\r\nfunction getGeom(geojson) {\r\n    if (geojson.type === \"Feature\") {\r\n        return geojson.geometry;\r\n    }\r\n    return geojson;\r\n}\r\nexports.getGeom = getGeom;\r\n/**\r\n * Get GeoJSON object's type, Geometry type is prioritize.\r\n *\r\n * @param {GeoJSON} geojson GeoJSON object\r\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\r\n * @returns {string} GeoJSON type\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getType(point)\r\n * //=\"Point\"\r\n */\r\nfunction getType(geojson, name) {\r\n    if (geojson.type === \"FeatureCollection\") {\r\n        return \"FeatureCollection\";\r\n    }\r\n    if (geojson.type === \"GeometryCollection\") {\r\n        return \"GeometryCollection\";\r\n    }\r\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\r\n        return geojson.geometry.type;\r\n    }\r\n    return geojson.type;\r\n}\r\nexports.getType = getType;\r\n","/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325,\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nvar unitsFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000,\n    millimetres: 1000,\n    centimeters: 100,\n    centimetres: 100,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    miles: 1 / 1609.344,\n    nauticalmiles: 1 / 1852,\n    inches: 39.370,\n    yards: 1 / 1.0936,\n    feet: 3.28084,\n    radians: 1 / earthRadius,\n    degrees: 1 / 111325,\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nvar areaFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    centimeters: 10000,\n    centimetres: 10000,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox) validateBBox(bbox);\n\n    // Main\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (length === null || length === undefined) throw new Error('length is required');\n    if (!(length >= 0)) throw new Error('length must be a positive number');\n\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) throw new Error('bbox is required');\n    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n    });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) throw new Error('id is required');\n    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nfunction degrees2radians() {\n    throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nfunction distanceToDegrees() {\n    throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nfunction distanceToRadians() {\n    throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nfunction radiansToDistance() {\n    throw new Error('method has been renamed to `radiansToLength`');\n}\n\nfunction bearingToAngle() {\n    throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nfunction convertDistance() {\n    throw new Error('method has been renamed to `convertLength`');\n}\n\nexport { earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId, radians2degrees, degrees2radians, distanceToDegrees, distanceToRadians, radiansToDistance, bearingToAngle, convertDistance };\n","import { feature, isObject, lineString, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    if (geomType === 'MultiPolygon') geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature$$1.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature$$1.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        if (coordEach(feature$$1, function (currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined) {\n                previousCoords = currentCoord;\n                return;\n            }\n            var currentSegment = lineString([previousCoords, currentCoord], feature$$1.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        if (feature$$1.geometry === null) return;\n        var type = feature$$1.geometry.type;\n        var coords = feature$$1.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(lineString(coords[geometryIndex], feature$$1.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexport { coordEach, coordReduce, propEach, propReduce, featureEach, featureReduce, coordAll, geomEach, geomReduce, flattenEach, flattenReduce, segmentEach, segmentReduce, lineEach, lineReduce, findSegment, findPoint };\n","/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325,\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nvar unitsFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000,\n    millimetres: 1000,\n    centimeters: 100,\n    centimetres: 100,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    miles: 1 / 1609.344,\n    nauticalmiles: 1 / 1852,\n    inches: 39.370,\n    yards: 1 / 1.0936,\n    feet: 3.28084,\n    radians: 1 / earthRadius,\n    degrees: 1 / 111325,\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nvar areaFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    centimeters: 10000,\n    centimetres: 10000,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox) validateBBox(bbox);\n\n    // Main\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (length === null || length === undefined) throw new Error('length is required');\n    if (!(length >= 0)) throw new Error('length must be a positive number');\n\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) throw new Error('bbox is required');\n    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n    });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) throw new Error('id is required');\n    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nfunction degrees2radians() {\n    throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nfunction distanceToDegrees() {\n    throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nfunction distanceToRadians() {\n    throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nfunction radiansToDistance() {\n    throw new Error('method has been renamed to `radiansToLength`');\n}\n\nfunction bearingToAngle() {\n    throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nfunction convertDistance() {\n    throw new Error('method has been renamed to `convertLength`');\n}\n\nexport { earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId, radians2degrees, degrees2radians, distanceToDegrees, distanceToRadians, radiansToDistance, bearingToAngle, convertDistance };\n","import { flattenEach } from '@turf/meta';\nimport { featureCollection } from '@turf/helpers';\n\n/**\n * Flattens any {@link GeoJSON} to a {@link FeatureCollection} inspired by [geojson-flatten](https://github.com/tmcw/geojson-flatten).\n *\n * @name flatten\n * @param {GeoJSON} geojson any valid GeoJSON Object\n * @returns {FeatureCollection<any>} all Multi-Geometries are flattened into single Features\n * @example\n * var multiGeometry = turf.multiPolygon([\n *   [[[102.0, 2.0], [103.0, 2.0], [103.0, 3.0], [102.0, 3.0], [102.0, 2.0]]],\n *   [[[100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0]],\n *   [[100.2, 0.2], [100.8, 0.2], [100.8, 0.8], [100.2, 0.8], [100.2, 0.2]]]\n * ]);\n *\n * var flatten = turf.flatten(multiGeometry);\n *\n * //addToMap\n * var addToMap = [flatten]\n */\nfunction flatten(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n\n    var results = [];\n    flattenEach(geojson, function (feature) {\n        results.push(feature);\n    });\n    return featureCollection(results);\n}\n\nexport default flatten;\n","import logger from 'loglevel';\nimport toGeoJSON from 'togeojson';\nimport flatten from '@turf/flatten';\nimport * as _ from './lodash';\n\n\nexport default class Helpers {\n    static getGeoJSON(kml) {\n        const extendedData = kml.getElementsByTagName('ExtendedData');\n        for (let index = extendedData.length - 1; index >= 0; index--) {\n            extendedData[index].parentNode.removeChild(extendedData[index]);\n        }\n        logger.log('KML (no ExtendedData):', kml);\n\n        let geoJson = toGeoJSON.kml(kml);\n        geoJson = flatten(geoJson);\n        logger.log('GeoJSON (flatten): ', geoJson);\n\n        return geoJson;\n    }\n\n    static getNumberOfFeatures(featureName, geoJson) {\n        const features = _.filter(geoJson.features,\n            feature => _.isEqual(feature.geometry.type, featureName));\n        return features.length;\n    }\n\n    static getLineString(geoJson) {\n        const lineString = _.find(geoJson.features,\n            feature => _.isEqual(feature.geometry.type, 'LineString'));\n        return lineString;\n    }\n\n    static reverseLineString(lineString) {\n        const newLineString = { ...lineString };\n        newLineString.geometry.coordinates = lineString.geometry.coordinates.reverse();\n        return newLineString;\n    }\n\n    static getPoints(geoJson) {\n        const points = _.filter(geoJson.features,\n            feature => _.isEqual(feature.geometry.type, 'Point'));\n        return points;\n    }\n\n    static getRoute(routeUrl) {\n        logger.debug('Fetching route from:', routeUrl);\n        return $.ajax(routeUrl);\n    }\n\n    static getGoogleMapsPath(lineString) {\n        const path = _.map(lineString.geometry.coordinates,\n            element => new google.maps.LatLng(element[1], element[0]));\n        return path;\n    }\n\n    static getPathElevations(lineString, useLocalElevations) {\n        if (useLocalElevations && lineString.geometry.coordinates[0].length === 3) {\n            // Elevation present in line string\n\n            logger.debug('Getting path elevations from line string...');\n            const elevations = _.map(lineString.geometry.coordinates,\n                element => ({ elevation: element[2] }));\n            logger.debug('Elevations:', elevations);\n            return new Promise((resolve, reject) => {\n                resolve(elevations);\n            });\n        }\n        // No elevation in line string\n        let path = this.getGoogleMapsPath(lineString);\n\n        // Optimize path array length\n        // This is done to send no more than\n        // MAXIMUM_NUMBER_OF_LATLNG_OBJECTS coordinates in KML path\n        const MAXIMUM_NUMBER_OF_SAMPLES = 512;\n        // Request to google.maps.ElevationService cannot be too long (2048 is too long)\n        const MAXIMUM_NUMBER_OF_LATLNG_OBJECTS = 1024;\n        logger.debug('Number of LatLng objects:', path.length);\n        if (path.length > MAXIMUM_NUMBER_OF_LATLNG_OBJECTS) {\n            const optimizedPath = [];\n            const delta = parseFloat(path.length / MAXIMUM_NUMBER_OF_LATLNG_OBJECTS);\n            for (let i = 0; i < path.length; i += delta) {\n                optimizedPath.push(path[Math.floor(i)]);\n            }\n            path = optimizedPath;\n            logger.debug('Number of LatLng objects after optimization:', path.length);\n        }\n\n        return new Promise((resolve, reject) => {\n            const elevator = new google.maps.ElevationService();\n            elevator.getElevationAlongPath({\n                path,\n                samples: MAXIMUM_NUMBER_OF_SAMPLES,\n            }, (elevations, status) => {\n                if (status === google.maps.ElevationStatus.OK) {\n                    resolve(elevations);\n                } else {\n                    reject(status);\n                }\n            });\n        });\n    }\n\n    static getRouteParameters(routeParamsUrl) {\n        return new Promise((resolve, reject) => {\n            $.ajax(routeParamsUrl)\n                .done(data => {\n                    logger.debug('Route parameters:', data);\n                    if (data.success === 1) {\n                        resolve(data);\n                    } else {\n                        reject(`Server side error: ${data.error}`);\n                    }\n                })\n                .fail((xhr, status) => {\n                    reject(status);\n                });\n        });\n    }\n\n    static approveRoute(routeApproveUrl) {\n        return new Promise((resolve, reject) => {\n            $.ajax(routeApproveUrl)\n                .done(data => {\n                    resolve({ success: true });\n                })\n                .fail((xhr, status) => {\n                    reject(status);\n                });\n        });\n    }\n}\n","const getGain = elevations => {\n    let elevationGain = 0.0;\n    for (let i = 1; i < elevations.length; i++) {\n        const elevationDifference = elevations[i].elevation - elevations[i - 1].elevation;\n        elevationGain += (elevationDifference > 0) ? elevationDifference : 0.0;\n    }\n    return Number(elevationGain);\n};\n\nconst getLoss = elevations => {\n    let elevationLoss = 0.0;\n    for (let i = 1; i < elevations.length; i++) {\n        const elevationDifference = elevations[i - 1].elevation - elevations[i].elevation;\n        elevationLoss += (elevationDifference > 0) ? elevationDifference : 0.0;\n    }\n    return Number(elevationLoss);\n};\n\n\nexport default class PathElevation {\n    constructor(elevations, length) {\n        this.gain = getGain(elevations);\n        this.loss = getLoss(elevations);\n        this.totalChange = this.loss + this.gain;\n        this.data = elevations;\n    }\n\n    enrichData(length) {\n        const elevationsWithDistance = [];\n        const resolution = length / this.data.length;\n        for (let i = 0; i < this.data.length; i++) {\n            elevationsWithDistance.push({\n                elevation: this.data[i].elevation, distance: i * resolution,\n            });\n        }\n        this.data = elevationsWithDistance;\n    }\n}\n","/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(obj) {\n    if (!obj) throw new Error('obj is required');\n\n    var coordinates = getCoords(obj);\n\n    // getCoord() must contain at least two numbers (Point)\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return coordinates;\n    } else {\n        throw new Error('Coordinate is not a valid Point');\n    }\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers\n *\n * @name getCoords\n * @param {Array<number>|Geometry|Feature} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coord = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(obj) {\n    if (!obj) throw new Error('obj is required');\n    var coordinates;\n\n    // Array of numbers\n    if (obj.length) {\n        coordinates = obj;\n\n    // Geometry Object\n    } else if (obj.coordinates) {\n        coordinates = obj.coordinates;\n\n    // Feature\n    } else if (obj.geometry && obj.geometry.coordinates) {\n        coordinates = obj.geometry.coordinates;\n    }\n    // Checks if coordinates contains a number\n    if (coordinates) {\n        containsNumber(coordinates);\n        return coordinates;\n    }\n    throw new Error('No valid coordinates');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\nexport function getGeomType() {\n    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n","import { getCoord } from '@turf/invariant';\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n\n/**\n * Takes two {@link Point|points} and finds the geographic bearing between them,\n * i.e. the angle measured in degrees from the north line (0 degrees)\n *\n * @name bearing\n * @param {Geometry|Feature<Point>|Array<number>} start starting Point\n * @param {Geometry|Feature<Point>|Array<number>} end ending Point\n * @param {Object} [options] Optional parameters\n * @param {boolean} [options.final=false] calculates the final bearing if true\n * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)\n * @example\n * var point1 = turf.point([-75.343, 39.984]);\n * var point2 = turf.point([-75.534, 39.123]);\n *\n * var bearing = turf.bearing(point1, point2);\n *\n * //addToMap\n * var addToMap = [point1, point2]\n * point1.properties['marker-color'] = '#f00'\n * point2.properties['marker-color'] = '#0f0'\n * point1.properties.bearing = bearing\n */\nfunction bearing(start, end, options) {\n    // Backwards compatible with v4.0\n    var final = (typeof options === 'object') ? options.final : options;\n    if (final === true) return calculateFinalBearing(start, end);\n\n    var degrees2radians = Math.PI / 180;\n    var radians2degrees = 180 / Math.PI;\n    var coordinates1 = getCoord(start);\n    var coordinates2 = getCoord(end);\n\n    var lon1 = degrees2radians * coordinates1[0];\n    var lon2 = degrees2radians * coordinates2[0];\n    var lat1 = degrees2radians * coordinates1[1];\n    var lat2 = degrees2radians * coordinates2[1];\n    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n    var b = Math.cos(lat1) * Math.sin(lat2) -\n        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n\n    var bear = radians2degrees * Math.atan2(a, b);\n\n    return bear;\n}\n\n/**\n * Calculates Final Bearing\n * @private\n * @param {Feature<Point>} start starting Point\n * @param {Feature<Point>} end ending Point\n * @returns {number} bearing\n */\nfunction calculateFinalBearing(start, end) {\n    // Swap start & end\n    var bear = bearing(end, start);\n    bear = (bear + 180) % 360;\n    return bear;\n}\n\nexport default bearing;\n","/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(obj) {\n    if (!obj) throw new Error('obj is required');\n\n    var coordinates = getCoords(obj);\n\n    // getCoord() must contain at least two numbers (Point)\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return coordinates;\n    } else {\n        throw new Error('Coordinate is not a valid Point');\n    }\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers\n *\n * @name getCoords\n * @param {Array<number>|Geometry|Feature} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coord = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(obj) {\n    if (!obj) throw new Error('obj is required');\n    var coordinates;\n\n    // Array of numbers\n    if (obj.length) {\n        coordinates = obj;\n\n    // Geometry Object\n    } else if (obj.coordinates) {\n        coordinates = obj.coordinates;\n\n    // Feature\n    } else if (obj.geometry && obj.geometry.coordinates) {\n        coordinates = obj.geometry.coordinates;\n    }\n    // Checks if coordinates contains a number\n    if (coordinates) {\n        containsNumber(coordinates);\n        return coordinates;\n    }\n    throw new Error('No valid coordinates');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\nexport function getGeomType() {\n    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n","/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geometry, properties, bbox, id) {\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nexport function geometry(type, coordinates, bbox) {\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Takes coordinates and properties (optional) and returns a new {@link Point} feature.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n    if (coordinates.length === undefined) throw new Error('Coordinates must be an array');\n    if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('Coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a {@link Polygon} feature.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<Polygon>} a Polygon feature\n * @throws {Error} throw an error if a LinearRing of the polygon has too few positions\n * or if a LinearRing of the Polygon does not have matching Positions at the beginning & end.\n * @example\n * var polygon = turf.polygon([[\n *   [-2.275543, 53.464547],\n *   [-2.275543, 53.489271],\n *   [-2.215118, 53.489271],\n *   [-2.215118, 53.464547],\n *   [-2.275543, 53.464547]\n * ]], { name: 'poly1', population: 400});\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('Coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link LineString} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<LineString>} a LineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var linestring1 = turf.lineString([\n *   [-21.964416, 64.148203],\n *   [-21.956176, 64.141316],\n *   [-21.93901, 64.135924],\n *   [-21.927337, 64.136673]\n * ]);\n * var linestring2 = turf.lineString([\n *   [-21.929054, 64.127985],\n *   [-21.912918, 64.134726],\n *   [-21.916007, 64.141016],\n *   [-21.930084, 64.14446]\n * ], {name: 'line 1', distance: 145});\n *\n * //=linestring1\n *\n * //=linestring2\n */\nexport function lineString(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('Coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {FeatureCollection} a FeatureCollection of input features\n * @example\n * var features = [\n *  turf.point([-75.343, 39.984], {name: 'Location A'}),\n *  turf.point([-75.833, 39.284], {name: 'Location B'}),\n *  turf.point([-75.534, 39.123], {name: 'Location C'})\n * ];\n *\n * var collection = turf.featureCollection(features);\n *\n * //=collection\n */\nexport function featureCollection(features, bbox, id) {\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nexport function geometryCollection(geometries, properties, bbox, id) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, bbox, id);\n}\n\n// https://en.wikipedia.org/wiki/Great-circle_distance#Radius_for_spherical_Earth\nvar factors = {\n    miles: 3960,\n    nauticalmiles: 3441.145,\n    degrees: 57.2957795,\n    radians: 1,\n    inches: 250905600,\n    yards: 6969600,\n    meters: 6373000,\n    metres: 6373000,\n    centimeters: 6.373e+8,\n    centimetres: 6.373e+8,\n    kilometers: 6373,\n    kilometres: 6373,\n    feet: 20908792.65\n};\n\nvar areaFactors = {\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    centimetres: 10000,\n    millimeter: 1000000,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToDistance\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToDistance(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name distanceToRadians\n * @param {number} distance in real units\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function distanceToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name distanceToDegrees\n * @param {number} distance in real units\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function distanceToDegrees(distance, units) {\n    return radians2degrees(distanceToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAngle\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAngle(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radians2degrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radians2degrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degrees2radians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degrees2radians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a distance to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} distance to be converted\n * @param {string} originalUnit of the distance\n * @param {string} [finalUnit=kilometers] returned unit\n * @returns {number} the converted distance\n */\nexport function convertDistance(distance, originalUnit, finalUnit) {\n    if (distance === null || distance === undefined) throw new Error('distance is required');\n    if (!(distance >= 0)) throw new Error('distance must be a positive number');\n\n    var convertedDistance = radiansToDistance(distanceToRadians(distance, originalUnit), finalUnit || 'kilometers');\n    return convertedDistance;\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeter, acre, mile, yard, foot, inch\n * @param {number} area to be converted\n * @param {string} [originalUnit=meters] of the distance\n * @param {string} [finalUnit=kilometers] returned unit\n * @returns {number} the converted distance\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nexport var earthRadius = 6371008.8;\n","import { getCoord } from '@turf/invariant';\nimport { radiansToDistance } from '@turf/helpers';\n\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians,\n * miles, or kilometers. This uses the\n * [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula)\n * to account for global curvature.\n *\n * @name distance\n * @param {Geometry|Feature<Point>|Array<number>} from origin point\n * @param {Geometry|Feature<Point>|Array<number>} to destination point\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n *\n * var distance = turf.distance(from, to, \"miles\");\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n    // Backwards compatible with v4.0\n    var units = (typeof options === 'object') ? options.units : options;\n\n    var degrees2radians = Math.PI / 180;\n    var coordinates1 = getCoord(from);\n    var coordinates2 = getCoord(to);\n    var dLat = degrees2radians * (coordinates2[1] - coordinates1[1]);\n    var dLon = degrees2radians * (coordinates2[0] - coordinates1[0]);\n    var lat1 = degrees2radians * coordinates1[1];\n    var lat2 = degrees2radians * coordinates2[1];\n\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n          Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n\n    return radiansToDistance(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), units);\n}\n\nexport default distance;\n","/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(obj) {\n    if (!obj) throw new Error('obj is required');\n\n    var coordinates = getCoords(obj);\n\n    // getCoord() must contain at least two numbers (Point)\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return coordinates;\n    } else {\n        throw new Error('Coordinate is not a valid Point');\n    }\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array of numbers\n *\n * @name getCoords\n * @param {Array<number>|Geometry|Feature} obj Object\n * @returns {Array<number>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coord = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(obj) {\n    if (!obj) throw new Error('obj is required');\n    var coordinates;\n\n    // Array of numbers\n    if (obj.length) {\n        coordinates = obj;\n\n    // Geometry Object\n    } else if (obj.coordinates) {\n        coordinates = obj.coordinates;\n\n    // Feature\n    } else if (obj.geometry && obj.geometry.coordinates) {\n        coordinates = obj.geometry.coordinates;\n    }\n    // Checks if coordinates contains a number\n    if (coordinates) {\n        containsNumber(coordinates);\n        return coordinates;\n    }\n    throw new Error('No valid coordinates');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        typeof coordinates[0] === 'number' &&\n        typeof coordinates[1] === 'number') {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\nexport function getGeomType() {\n    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n","/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geometry, properties, bbox, id) {\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nexport function geometry(type, coordinates, bbox) {\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Takes coordinates and properties (optional) and returns a new {@link Point} feature.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n    if (coordinates.length === undefined) throw new Error('Coordinates must be an array');\n    if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('Coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a {@link Polygon} feature.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<Polygon>} a Polygon feature\n * @throws {Error} throw an error if a LinearRing of the polygon has too few positions\n * or if a LinearRing of the Polygon does not have matching Positions at the beginning & end.\n * @example\n * var polygon = turf.polygon([[\n *   [-2.275543, 53.464547],\n *   [-2.275543, 53.489271],\n *   [-2.215118, 53.489271],\n *   [-2.215118, 53.464547],\n *   [-2.275543, 53.464547]\n * ]], { name: 'poly1', population: 400});\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('Coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link LineString} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<LineString>} a LineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var linestring1 = turf.lineString([\n *   [-21.964416, 64.148203],\n *   [-21.956176, 64.141316],\n *   [-21.93901, 64.135924],\n *   [-21.927337, 64.136673]\n * ]);\n * var linestring2 = turf.lineString([\n *   [-21.929054, 64.127985],\n *   [-21.912918, 64.134726],\n *   [-21.916007, 64.141016],\n *   [-21.930084, 64.14446]\n * ], {name: 'line 1', distance: 145});\n *\n * //=linestring1\n *\n * //=linestring2\n */\nexport function lineString(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('Coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {FeatureCollection} a FeatureCollection of input features\n * @example\n * var features = [\n *  turf.point([-75.343, 39.984], {name: 'Location A'}),\n *  turf.point([-75.833, 39.284], {name: 'Location B'}),\n *  turf.point([-75.534, 39.123], {name: 'Location C'})\n * ];\n *\n * var collection = turf.featureCollection(features);\n *\n * //=collection\n */\nexport function featureCollection(features, bbox, id) {\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox && bbox.length !== 4) throw new Error('bbox must be an Array of 4 numbers');\n    if (id && ['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, bbox, id) {\n    if (!coordinates) throw new Error('No coordinates passed');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, bbox, id);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Array<number>} [bbox] BBox [west, south, east, north]\n * @param {string|number} [id] Identifier\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nexport function geometryCollection(geometries, properties, bbox, id) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, bbox, id);\n}\n\n// https://en.wikipedia.org/wiki/Great-circle_distance#Radius_for_spherical_Earth\nvar factors = {\n    miles: 3960,\n    nauticalmiles: 3441.145,\n    degrees: 57.2957795,\n    radians: 1,\n    inches: 250905600,\n    yards: 6969600,\n    meters: 6373000,\n    metres: 6373000,\n    centimeters: 6.373e+8,\n    centimetres: 6.373e+8,\n    kilometers: 6373,\n    kilometres: 6373,\n    feet: 20908792.65\n};\n\nvar areaFactors = {\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    centimetres: 10000,\n    millimeter: 1000000,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToDistance\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToDistance(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name distanceToRadians\n * @param {number} distance in real units\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function distanceToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name distanceToDegrees\n * @param {number} distance in real units\n * @param {string} [units=kilometers] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function distanceToDegrees(distance, units) {\n    return radians2degrees(distanceToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAngle\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAngle(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radians2degrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radians2degrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degrees2radians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degrees2radians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a distance to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} distance to be converted\n * @param {string} originalUnit of the distance\n * @param {string} [finalUnit=kilometers] returned unit\n * @returns {number} the converted distance\n */\nexport function convertDistance(distance, originalUnit, finalUnit) {\n    if (distance === null || distance === undefined) throw new Error('distance is required');\n    if (!(distance >= 0)) throw new Error('distance must be a positive number');\n\n    var convertedDistance = radiansToDistance(distanceToRadians(distance, originalUnit), finalUnit || 'kilometers');\n    return convertedDistance;\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeter, acre, mile, yard, foot, inch\n * @param {number} area to be converted\n * @param {string} [originalUnit=meters] of the distance\n * @param {string} [finalUnit=kilometers] returned unit\n * @returns {number} the converted distance\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nexport var earthRadius = 6371008.8;\n","//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\nimport { getCoord } from '@turf/invariant';\nimport { point, distanceToRadians } from '@turf/helpers';\n\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in degrees, radians, miles, or kilometers; and bearing in degrees. This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Geometry|Feature<Point>|Array<number>} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} options Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var units = 'miles';\n *\n * var destination = turf.destination(point, distance, bearing, units);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\nfunction destination(origin, distance, bearing, options) {\n    // Backwards compatible with v4.0\n    var units = (typeof options === 'object') ? options.units : options;\n\n    var degrees2radians = Math.PI / 180;\n    var radians2degrees = 180 / Math.PI;\n    var coordinates1 = getCoord(origin);\n    var longitude1 = degrees2radians * coordinates1[0];\n    var latitude1 = degrees2radians * coordinates1[1];\n    var bearing_rad = degrees2radians * bearing;\n\n    var radians = distanceToRadians(distance, units);\n\n    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearing_rad));\n    var longitude2 = longitude1 + Math.atan2(Math.sin(bearing_rad) * Math.sin(radians) * Math.cos(latitude1),\n        Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n\n    return point([radians2degrees * longitude2, radians2degrees * latitude2]);\n}\n\nexport default destination;\n","function quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nexport default quickselect;\n","import quickselect from './quickselect';\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n\nexport default rbush;\n","/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0.\n * @param {number} featureIndex The current index of the feature being processed.\n * @param {number} featureSubIndex The current subIndex of the feature being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, featureSubIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=featureSubIndex\n * });\n */\nexport function coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var featureIndex, geometryIndex, j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (geometryIndex = 0; geometryIndex < stopG; geometryIndex++) {\n            var featureSubIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geometryIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                callback(coords, coordIndex, featureIndex, featureSubIndex);\n                coordIndex++;\n                featureSubIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    callback(coords[j], coordIndex, featureIndex, featureSubIndex);\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') featureSubIndex++;\n                }\n                if (geomType === 'LineString') featureSubIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        callback(coords[j][k], coordIndex, featureIndex, featureSubIndex);\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') featureSubIndex++;\n                }\n                if (geomType === 'Polygon') featureSubIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length; k++)\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            callback(coords[j][k][l], coordIndex, featureIndex, featureSubIndex);\n                            coordIndex++;\n                        }\n                    featureSubIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    coordEach(geometry.geometries[j], callback, excludeWrapCoord);\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the feature being processed.\n * @param {number} featureSubIndex The current subIndex of the feature being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=featureSubIndex\n *   return currentCoord;\n * });\n */\nexport function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, featureSubIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, featureSubIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current properties being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {(FeatureCollection|Feature)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nexport function propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            callback(geojson.features[i].properties, i);\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current properties being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {(FeatureCollection|Feature)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nexport function propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nexport function featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            callback(geojson.features[i], i);\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nexport function featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nexport function coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current geometry being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} currentProperties The current feature properties being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, currentProperties)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, currentProperties) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=currentProperties\n * });\n */\nexport function geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        geometryProperties,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        geometryProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                callback(null, featureIndex, geometryProperties);\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                callback(geometry, featureIndex, geometryProperties);\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    callback(geometry.geometries[j], featureIndex, geometryProperties);\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Feature being processed.\n * @param {number} currentIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {Object} currentProperties The current feature properties being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, currentProperties)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, currentProperties) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=currentProperties\n *   return currentGeometry\n * });\n */\nexport function geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, currentIndex, currentProperties) {\n        if (currentIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, currentIndex, currentProperties);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureSubIndex The subindex of the current element being processed in the\n * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, featureSubIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, featureSubIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=featureSubIndex\n * });\n */\nexport function flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            callback(feature(geometry, properties), featureIndex, 0);\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        geometry.coordinates.forEach(function (coordinate, featureSubIndex) {\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            callback(feature(geom, properties), featureIndex, featureSubIndex);\n        });\n\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The index of the current element being processed in the\n * array.Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureSubIndex The subindex of the current element being processed in the\n * array. Starts at index 0 and increases if the flattened feature was a multi-geometry.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, featureSubIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, featureSubIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=featureSubIndex\n *   return currentFeature\n * });\n */\nexport function flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, featureSubIndex) {\n        if (featureIndex === 0 && featureSubIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, featureSubIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current segment being processed.\n * @param {number} featureIndex The featureIndex currently being processed, starts at index 0.\n * @param {number} featureSubIndex The featureSubIndex currently being processed, starts at index 0.\n * @param {number} segmentIndex The segmentIndex currently being processed, starts at index 0.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, featureSubIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, featureSubIndex, segmentIndex) {\n *   //= currentSegment\n *   //= featureIndex\n *   //= featureSubIndex\n *   //= segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nexport function segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, featureSubIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        coordReduce(feature, function (previousCoords, currentCoord) {\n            var currentSegment = lineString([previousCoords, currentCoord], feature.properties);\n            callback(currentSegment, featureIndex, featureSubIndex, segmentIndex);\n            segmentIndex++;\n            return currentCoord;\n        });\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} [previousValue] The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} [currentSegment] The current segment being processed.\n * @param {number} featureIndex The featureIndex currently being processed, starts at index 0.\n * @param {number} featureSubIndex The featureSubIndex currently being processed, starts at index 0.\n * @param {number} segmentIndex The segmentIndex currently being processed, starts at index 0.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {(FeatureCollection|Feature|Geometry)} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, featureSubIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= featureSubIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nexport function segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, featureSubIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, featureSubIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Create Feature\n *\n * @private\n * @param {Geometry} geometry GeoJSON Geometry\n * @param {Object} properties Properties\n * @returns {Feature} GeoJSON Feature\n */\nfunction feature(geometry, properties) {\n    if (geometry === undefined) throw new Error('No geometry passed');\n\n    return {\n        type: 'Feature',\n        properties: properties || {},\n        geometry: geometry\n    };\n}\n\n/**\n * Create LineString\n *\n * @private\n * @param {Array<Array<number>>} coordinates Line Coordinates\n * @param {Object} properties Properties\n * @returns {Feature<LineString>} GeoJSON LineString Feature\n */\nfunction lineString(coordinates, properties) {\n    if (!coordinates) throw new Error('No coordinates passed');\n    if (coordinates.length < 2) throw new Error('Coordinates must be an array of two or more positions');\n\n    return {\n        type: 'Feature',\n        properties: properties || {},\n        geometry: {\n            type: 'LineString',\n            coordinates: coordinates\n        }\n    };\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} lineIndex The index of the current element being processed in the array, starts at index 0.\n * @param {number} lineSubIndex The sub-index of the current line being processed at index 0\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, lineIndex, lineSubIndex)\n * @example\n * var mtLn = turf.multiLineString([\n *   turf.lineString([[26, 37], [35, 45]]),\n *   turf.lineString([[36, 53], [38, 50], [41, 55]])\n * ]);\n *\n * turf.lineEach(mtLn, function (currentLine, lineIndex) {\n *   //=currentLine\n *   //=lineIndex\n * });\n */\nexport function lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n    var type = geojson.geometry ? geojson.geometry.type : geojson.type;\n    if (!type) throw new Error('invalid geojson');\n    if (type === 'FeatureCollection') throw new Error('FeatureCollection is not supported');\n    if (type === 'GeometryCollection') throw new Error('GeometryCollection is not supported');\n    var coordinates = geojson.geometry ? geojson.geometry.coordinates : geojson.coordinates;\n    if (!coordinates) throw new Error('geojson must contain coordinates');\n\n    switch (type) {\n    case 'LineString':\n        callback(coordinates, 0, 0);\n        return;\n    case 'Polygon':\n    case 'MultiLineString':\n        var subIndex = 0;\n        for (var line = 0; line < coordinates.length; line++) {\n            if (type === 'MultiLineString') subIndex = line;\n            callback(coordinates[line], line, subIndex);\n        }\n        return;\n    case 'MultiPolygon':\n        for (var multi = 0; multi < coordinates.length; multi++) {\n            for (var ring = 0; ring < coordinates[multi].length; ring++) {\n                callback(coordinates[multi][ring], ring, multi);\n            }\n        }\n        return;\n    default:\n        throw new Error(type + ' geometry not supported');\n    }\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} lineIndex The index of the current element being processed in the\n * array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} lineSubIndex The sub-index of the current line being processed at index 0\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var mtp = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(mtp, function (previousValue, currentLine, lineIndex, lineSubIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=lineIndex\n *   //=lineSubIndex\n *   return currentLine\n * }, 2);\n */\nexport function lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, lineIndex, lineSubIndex) {\n        if (lineIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, lineIndex, lineSubIndex);\n    });\n    return previousValue;\n}\n","import rbush from './rbush';\nimport {featureEach, coordEach} from '@turf/meta';\n\n/**\n * GeoJSON implementation of [RBush](https://github.com/mourner/rbush#rbush) spatial index.\n *\n * @name rbush\n * @param {number} [maxEntries=9] defines the maximum number of entries in a tree node. 9 (used by default) is a\n * reasonable choice for most applications. Higher value means faster insertion and slower search, and vice versa.\n * @returns {RBush} GeoJSON RBush\n * @example\n * import geojsonRbush from 'geojson-rbush';\n * var tree = geojsonRbush();\n */\nfunction geojsonRbush(maxEntries) {\n    var tree = rbush(maxEntries);\n    /**\n     * [insert](https://github.com/mourner/rbush#data-format)\n     *\n     * @param {Feature<any>} feature insert single GeoJSON Feature\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.insert(polygon)\n     */\n    tree.insert = function (feature) {\n        if (Array.isArray(feature)) {\n            var bbox = feature;\n            feature = bboxPolygon(bbox);\n            feature.bbox = bbox;\n        } else {\n            feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        }\n        return rbush.prototype.insert.call(this, feature);\n    };\n\n    /**\n     * [load](https://github.com/mourner/rbush#bulk-inserting-data)\n     *\n     * @param {BBox[]|FeatureCollection<any>} features load entire GeoJSON FeatureCollection\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polygons = {\n     *   \"type\": \"FeatureCollection\",\n     *   \"features\": [\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"properties\": {},\n     *       \"geometry\": {\n     *         \"type\": \"Polygon\",\n     *         \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *       }\n     *     },\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"properties\": {},\n     *       \"geometry\": {\n     *         \"type\": \"Polygon\",\n     *         \"coordinates\": [[[-93, 32], [-83, 32], [-83, 39], [-93, 39], [-93, 32]]]\n     *       }\n     *     }\n     *   ]\n     * }\n     * tree.load(polygons)\n     */\n    tree.load = function (features) {\n        var load = [];\n        // Load an Array of BBox\n        if (Array.isArray(features)) {\n            features.forEach(function (bbox) {\n                var feature = bboxPolygon(bbox);\n                feature.bbox = bbox;\n                load.push(feature);\n            });\n        } else {\n            // Load FeatureCollection\n            featureEach(features, function (feature) {\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        }\n        return rbush.prototype.load.call(this, load);\n    };\n\n    /**\n     * [remove](https://github.com/mourner/rbush#removing-data)\n     *\n     * @param {BBox|Feature<any>} feature remove single GeoJSON Feature\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.remove(polygon)\n     */\n    tree.remove = function (feature) {\n        if (Array.isArray(feature)) {\n            var bbox = feature;\n            feature = bboxPolygon(bbox);\n            feature.bbox = bbox;\n        }\n        return rbush.prototype.remove.call(this, feature);\n    };\n\n    /**\n     * [clear](https://github.com/mourner/rbush#removing-data)\n     *\n     * @returns {RBush} GeoJSON Rbush\n     * @example\n     * tree.clear()\n     */\n    tree.clear = function () {\n        return rbush.prototype.clear.call(this);\n    };\n\n    /**\n     * [search](https://github.com/mourner/rbush#search)\n     *\n     * @param {BBox|FeatureCollection|Feature<any>} geojson search with GeoJSON\n     * @returns {FeatureCollection<any>} all features that intersects with the given GeoJSON.\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.search(polygon)\n     */\n    tree.search = function (geojson) {\n        var features = rbush.prototype.search.call(this, this.toBBox(geojson));\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    };\n\n    /**\n     * [collides](https://github.com/mourner/rbush#collisions)\n     *\n     * @param {BBox|FeatureCollection|Feature<any>} geojson collides with GeoJSON\n     * @returns {boolean} true if there are any items intersecting the given GeoJSON, otherwise false.\n     * @example\n     * var polygon = {\n     *   \"type\": \"Feature\",\n     *   \"properties\": {},\n     *   \"geometry\": {\n     *     \"type\": \"Polygon\",\n     *     \"coordinates\": [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]\n     *   }\n     * }\n     * tree.collides(polygon)\n     */\n    tree.collides = function (geojson) {\n        return rbush.prototype.collides.call(this, this.toBBox(geojson));\n    };\n\n    /**\n     * [all](https://github.com/mourner/rbush#search)\n     *\n     * @returns {FeatureCollection<any>} all the features in RBush\n     * @example\n     * tree.all()\n     * //=FeatureCollection\n     */\n    tree.all = function () {\n        var features = rbush.prototype.all.call(this);\n        return {\n            type: 'FeatureCollection',\n            features: features\n        };\n    };\n\n    /**\n     * [toJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @returns {any} export data as JSON object\n     * @example\n     * var exported = tree.toJSON()\n     * //=JSON object\n     */\n    tree.toJSON = function () {\n        return rbush.prototype.toJSON.call(this);\n    };\n\n    /**\n     * [fromJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @param {any} json import previously exported data\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var exported = {\n     *   \"children\": [\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"geometry\": {\n     *         \"type\": \"Point\",\n     *         \"coordinates\": [110, 50]\n     *       },\n     *       \"properties\": {},\n     *       \"bbox\": [110, 50, 110, 50]\n     *     }\n     *   ],\n     *   \"height\": 1,\n     *   \"leaf\": true,\n     *   \"minX\": 110,\n     *   \"minY\": 50,\n     *   \"maxX\": 110,\n     *   \"maxY\": 50\n     * }\n     * tree.fromJSON(exported)\n     */\n    tree.fromJSON = function (json) {\n        return rbush.prototype.fromJSON.call(this, json);\n    };\n\n    /**\n     * Converts GeoJSON to {minX, minY, maxX, maxY} schema\n     *\n     * @private\n     * @param {BBox|FeatureCollectio|Feature<any>} geojson feature(s) to retrieve BBox from\n     * @returns {Object} converted to {minX, minY, maxX, maxY}\n     */\n    tree.toBBox = function (geojson) {\n        var bbox;\n        if (geojson.bbox) bbox = geojson.bbox;\n        else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;\n        else bbox = turfBBox(geojson);\n\n        return {\n            minX: bbox[0],\n            minY: bbox[1],\n            maxX: bbox[2],\n            maxY: bbox[3]\n        };\n    };\n    return tree;\n}\n\n/**\n * Takes a bbox and returns an equivalent {@link Polygon|polygon}.\n *\n * @private\n * @name bboxPolygon\n * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order\n * @returns {Feature<Polygon>} a Polygon representation of the bounding box\n * @example\n * var bbox = [0, 0, 10, 10];\n *\n * var poly = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [poly]\n */\nfunction bboxPolygon(bbox) {\n    var lowLeft = [bbox[0], bbox[1]];\n    var topLeft = [bbox[0], bbox[3]];\n    var topRight = [bbox[2], bbox[3]];\n    var lowRight = [bbox[2], bbox[1]];\n    var coordinates = [[lowLeft, lowRight, topRight, topLeft, lowLeft]];\n\n    return {\n        type: 'Feature',\n        bbox: bbox,\n        properties: {},\n        geometry: {\n            type: 'Polygon',\n            coordinates: coordinates\n        }\n    };\n}\n\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @private\n * @name bbox\n * @param {FeatureCollection|Feature<any>} geojson input features\n * @returns {Array<number>} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction turfBBox(geojson) {\n    var bbox = [Infinity, Infinity, -Infinity, -Infinity];\n    coordEach(geojson, function (coord) {\n        if (bbox[0] > coord[0]) bbox[0] = coord[0];\n        if (bbox[1] > coord[1]) bbox[1] = coord[1];\n        if (bbox[2] < coord[0]) bbox[2] = coord[0];\n        if (bbox[3] < coord[1]) bbox[3] = coord[1];\n    });\n    return bbox;\n}\n\nexport default geojsonRbush;\n","/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325,\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nvar unitsFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000,\n    millimetres: 1000,\n    centimeters: 100,\n    centimetres: 100,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    miles: 1 / 1609.344,\n    nauticalmiles: 1 / 1852,\n    inches: 39.370,\n    yards: 1 / 1.0936,\n    feet: 3.28084,\n    radians: 1 / earthRadius,\n    degrees: 1 / 111325,\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nvar areaFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    centimeters: 10000,\n    centimetres: 10000,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox) validateBBox(bbox);\n\n    // Main\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (length === null || length === undefined) throw new Error('length is required');\n    if (!(length >= 0)) throw new Error('length must be a positive number');\n\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) throw new Error('bbox is required');\n    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n    });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) throw new Error('id is required');\n    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nfunction degrees2radians() {\n    throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nfunction distanceToDegrees() {\n    throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nfunction distanceToRadians() {\n    throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nfunction radiansToDistance() {\n    throw new Error('method has been renamed to `radiansToLength`');\n}\n\nfunction bearingToAngle() {\n    throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nfunction convertDistance() {\n    throw new Error('method has been renamed to `convertLength`');\n}\n\nexport { earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId, radians2degrees, degrees2radians, distanceToDegrees, distanceToRadians, radiansToDistance, bearingToAngle, convertDistance };\n","import { isNumber } from '@turf/helpers';\n\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(coord) {\n    if (!coord) throw new Error('coord is required');\n    if (coord.type === 'Feature' && coord.geometry !== null && coord.geometry.type === 'Point') return coord.geometry.coordinates;\n    if (coord.type === 'Point') return coord.coordinates;\n    if (Array.isArray(coord) && coord.length >= 2 && coord[0].length === undefined && coord[1].length === undefined) return coord;\n\n    throw new Error('coord must be GeoJSON Point or an Array of numbers');\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nfunction getCoords(coords) {\n    if (!coords) throw new Error('coords is required');\n\n    // Feature\n    if (coords.type === 'Feature' && coords.geometry !== null) return coords.geometry.coordinates;\n\n    // Geometry\n    if (coords.coordinates) return coords.coordinates;\n\n    // Array of numbers\n    if (Array.isArray(coords)) return coords;\n\n    throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates) {\n    if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nfunction getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\nfunction getGeomType() {\n    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nfunction getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n\nexport { getCoord, getCoords, containsNumber, geojsonType, featureOf, collectionOf, getGeom, getGeomType, getType };\n","import { feature, isObject, lineString, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    if (geomType === 'MultiPolygon') geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature$$1.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature$$1.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        if (coordEach(feature$$1, function (currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined) {\n                previousCoords = currentCoord;\n                return;\n            }\n            var currentSegment = lineString([previousCoords, currentCoord], feature$$1.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        if (feature$$1.geometry === null) return;\n        var type = feature$$1.geometry.type;\n        var coords = feature$$1.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(lineString(coords[geometryIndex], feature$$1.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexport { coordEach, coordReduce, propEach, propReduce, featureEach, featureReduce, coordAll, geomEach, geomReduce, flattenEach, flattenReduce, segmentEach, segmentReduce, lineEach, lineReduce, findSegment, findPoint };\n","import { featureCollection, lineString } from '@turf/helpers';\nimport { getCoords } from '@turf/invariant';\nimport { flattenEach } from '@turf/meta';\n\n/**\n * Creates a {@link FeatureCollection} of 2-vertex {@link LineString} segments from a {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon}.\n *\n * @name lineSegment\n * @param {Geometry|FeatureCollection|Feature<LineString|MultiLineString|MultiPolygon|Polygon>} geojson GeoJSON Polygon or LineString\n * @returns {FeatureCollection<LineString>} 2-vertex line segments\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n * var segments = turf.lineSegment(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, segments]\n */\nfunction lineSegment(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n\n    var results = [];\n    flattenEach(geojson, function (feature) {\n        lineSegmentFeature(feature, results);\n    });\n    return featureCollection(results);\n}\n\n/**\n * Line Segment\n *\n * @private\n * @param {Feature<LineString|Polygon>} geojson Line or polygon feature\n * @param {Array} results push to results\n * @returns {void}\n */\nfunction lineSegmentFeature(geojson, results) {\n    var coords = [];\n    var geometry = geojson.geometry;\n    switch (geometry.type) {\n    case 'Polygon':\n        coords = getCoords(geometry);\n        break;\n    case 'LineString':\n        coords = [getCoords(geometry)];\n    }\n    coords.forEach(function (coord) {\n        var segments = createSegments(coord, geojson.properties);\n        segments.forEach(function (segment) {\n            segment.id = results.length;\n            results.push(segment);\n        });\n    });\n}\n\n/**\n * Create Segments from LineString coordinates\n *\n * @private\n * @param {LineString} coords LineString coordinates\n * @param {*} properties GeoJSON properties\n * @returns {Array<Feature<LineString>>} line segments\n */\nfunction createSegments(coords, properties) {\n    var segments = [];\n    coords.reduce(function (previousCoords, currentCoords) {\n        var segment = lineString([previousCoords, currentCoords], properties);\n        segment.bbox = bbox(previousCoords, currentCoords);\n        segments.push(segment);\n        return currentCoords;\n    });\n    return segments;\n}\n\n/**\n * Create BBox between two coordinates (faster than @turf/bbox)\n *\n * @private\n * @param {Array<number>} coords1 Point coordinate\n * @param {Array<number>} coords2 Point coordinate\n * @returns {BBox} [west, south, east, north]\n */\nfunction bbox(coords1, coords2) {\n    var x1 = coords1[0];\n    var y1 = coords1[1];\n    var x2 = coords2[0];\n    var y2 = coords2[1];\n    var west = (x1 < x2) ? x1 : x2;\n    var south = (y1 < y2) ? y1 : y2;\n    var east = (x1 > x2) ? x1 : x2;\n    var north = (y1 > y2) ? y1 : y2;\n    return [west, south, east, north];\n}\n\nexport default lineSegment;\n","/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n */\nvar earthRadius = 6371008.8;\n\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n */\nvar factors = {\n    meters: earthRadius,\n    metres: earthRadius,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    miles: earthRadius / 1609.344,\n    nauticalmiles: earthRadius / 1852,\n    inches: earthRadius * 39.370,\n    yards: earthRadius / 1.0936,\n    feet: earthRadius * 3.28084,\n    radians: 1,\n    degrees: earthRadius / 111325,\n};\n\n/**\n * Units of measurement factors based on 1 meter.\n */\nvar unitsFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000,\n    millimetres: 1000,\n    centimeters: 100,\n    centimetres: 100,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    miles: 1 / 1609.344,\n    nauticalmiles: 1 / 1852,\n    inches: 39.370,\n    yards: 1 / 1.0936,\n    feet: 3.28084,\n    radians: 1 / earthRadius,\n    degrees: 1 / 111325,\n};\n\n/**\n * Area of measurement factors based on 1 square meter.\n */\nvar areaFactors = {\n    meters: 1,\n    metres: 1,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    centimeters: 10000,\n    centimetres: 10000,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    acres: 0.000247105,\n    miles: 3.86e-7,\n    yards: 1.195990046,\n    feet: 10.763910417,\n    inches: 1550.003100006\n};\n\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geometry, properties, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (geometry === undefined) throw new Error('geometry is required');\n    if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var feat = {type: 'Feature'};\n    if (id) feat.id = id;\n    if (bbox) feat.bbox = bbox;\n    feat.properties = properties || {};\n    feat.geometry = geometry;\n    return feat;\n}\n\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<number>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Geometry\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = 'Point';\n * var coordinates = [110, 50];\n *\n * var geometry = turf.geometry(type, coordinates);\n *\n * //=geometry\n */\nfunction geometry(type, coordinates, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n\n    // Validation\n    if (!type) throw new Error('type is required');\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (bbox) validateBBox(bbox);\n\n    // Main\n    var geom;\n    switch (type) {\n    case 'Point': geom = point(coordinates).geometry; break;\n    case 'LineString': geom = lineString(coordinates).geometry; break;\n    case 'Polygon': geom = polygon(coordinates).geometry; break;\n    case 'MultiPoint': geom = multiPoint(coordinates).geometry; break;\n    case 'MultiLineString': geom = multiLineString(coordinates).geometry; break;\n    case 'MultiPolygon': geom = multiPolygon(coordinates).geometry; break;\n    default: throw new Error(type + ' is invalid');\n    }\n    if (bbox) geom.bbox = bbox;\n    return geom;\n}\n\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n    if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'Point',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    for (var i = 0; i < coordinates.length; i++) {\n        var ring = coordinates[i];\n        if (ring.length < 4) {\n            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (i === 0 && j === 0 && !isNumber(ring[0][0]) || !isNumber(ring[0][1])) throw new Error('coordinates must contain numbers');\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error('First and last Position are not equivalent.');\n            }\n        }\n    }\n\n    return feature({\n        type: 'Polygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (coordinates.length < 2) throw new Error('coordinates must be an array of two or more positions');\n    // Check if first point of LineString contains two numbers\n    if (!isNumber(coordinates[0][1]) || !isNumber(coordinates[0][1])) throw new Error('coordinates must contain numbers');\n\n    return feature({\n        type: 'LineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<number>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n    if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');\n\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var bbox = options.bbox;\n    var id = options.id;\n\n    // Validation\n    if (!features) throw new Error('No features passed');\n    if (!Array.isArray(features)) throw new Error('features must be an Array');\n    if (bbox) validateBBox(bbox);\n    if (id) validateId(id);\n\n    // Main\n    var fc = {type: 'FeatureCollection'};\n    if (id) fc.id = id;\n    if (bbox) fc.bbox = bbox;\n    fc.features = features;\n    return fc;\n}\n\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiLineString',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPoint',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (!coordinates) throw new Error('coordinates is required');\n\n    return feature({\n        type: 'MultiPolygon',\n        coordinates: coordinates\n    }, properties, options);\n}\n\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = {\n *     \"type\": \"Point\",\n *       \"coordinates\": [100, 0]\n *     };\n * var line = {\n *     \"type\": \"LineString\",\n *     \"coordinates\": [ [101, 0], [102, 1] ]\n *   };\n * var collection = turf.geometryCollection([pt, line]);\n *\n * //=collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (!geometries) throw new Error('geometries is required');\n    if (!Array.isArray(geometries)) throw new Error('geometries must be an Array');\n\n    return feature({\n        type: 'GeometryCollection',\n        geometries: geometries\n    }, properties, options);\n}\n\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (num === undefined || num === null || isNaN(num)) throw new Error('num is required');\n    if (precision && !(precision >= 0)) throw new Error('precision must be a positive number');\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (radians === undefined || radians === null) throw new Error('radians is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return radians * factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (distance === undefined || distance === null) throw new Error('distance is required');\n\n    if (units && typeof units !== 'string') throw new Error('units must be a string');\n    var factor = factors[units || 'kilometers'];\n    if (!factor) throw new Error(units + ' units is invalid');\n    return distance / factor;\n}\n\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    if (bearing === null || bearing === undefined) throw new Error('bearing is required');\n\n    var angle = bearing % 360;\n    if (angle < 0) angle += 360;\n    return angle;\n}\n\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    if (radians === null || radians === undefined) throw new Error('radians is required');\n\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\n\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    if (degrees === null || degrees === undefined) throw new Error('degrees is required');\n\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\n\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {string} originalUnit of the length\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (length === null || length === undefined) throw new Error('length is required');\n    if (!(length >= 0)) throw new Error('length must be a positive number');\n\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit || 'kilometers');\n}\n\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {string} [originalUnit='meters'] of the distance\n * @param {string} [finalUnit='kilometers'] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (area === null || area === undefined) throw new Error('area is required');\n    if (!(area >= 0)) throw new Error('area must be a positive number');\n\n    var startFactor = areaFactors[originalUnit || 'meters'];\n    if (!startFactor) throw new Error('invalid original units');\n\n    var finalFactor = areaFactors[finalUnit || 'kilometers'];\n    if (!finalFactor) throw new Error('invalid final units');\n\n    return (area / startFactor) * finalFactor;\n}\n\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\n\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) throw new Error('bbox is required');\n    if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');\n    if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) throw new Error('bbox must only contain numbers');\n    });\n}\n\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) throw new Error('id is required');\n    if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');\n}\n\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error('method has been renamed to `radiansToDegrees`');\n}\n\nfunction degrees2radians() {\n    throw new Error('method has been renamed to `degreesToRadians`');\n}\n\nfunction distanceToDegrees() {\n    throw new Error('method has been renamed to `lengthToDegrees`');\n}\n\nfunction distanceToRadians() {\n    throw new Error('method has been renamed to `lengthToRadians`');\n}\n\nfunction radiansToDistance() {\n    throw new Error('method has been renamed to `radiansToLength`');\n}\n\nfunction bearingToAngle() {\n    throw new Error('method has been renamed to `bearingToAzimuth`');\n}\n\nfunction convertDistance() {\n    throw new Error('method has been renamed to `convertLength`');\n}\n\nexport { earthRadius, factors, unitsFactors, areaFactors, feature, geometry, point, points, polygon, polygons, lineString, lineStrings, featureCollection, multiLineString, multiPoint, multiPolygon, geometryCollection, round, radiansToLength, lengthToRadians, lengthToDegrees, bearingToAzimuth, radiansToDegrees, degreesToRadians, convertLength, convertArea, isNumber, isObject, validateBBox, validateId, radians2degrees, degrees2radians, distanceToDegrees, distanceToRadians, radiansToDistance, bearingToAngle, convertDistance };\n","import { isNumber } from '@turf/helpers';\n\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(coord) {\n    if (!coord) throw new Error('coord is required');\n    if (coord.type === 'Feature' && coord.geometry !== null && coord.geometry.type === 'Point') return coord.geometry.coordinates;\n    if (coord.type === 'Point') return coord.coordinates;\n    if (Array.isArray(coord) && coord.length >= 2 && coord[0].length === undefined && coord[1].length === undefined) return coord;\n\n    throw new Error('coord must be GeoJSON Point or an Array of numbers');\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nfunction getCoords(coords) {\n    if (!coords) throw new Error('coords is required');\n\n    // Feature\n    if (coords.type === 'Feature' && coords.geometry !== null) return coords.geometry.coordinates;\n\n    // Geometry\n    if (coords.coordinates) return coords.coordinates;\n\n    // Array of numbers\n    if (Array.isArray(coords)) return coords;\n\n    throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates) {\n    if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nfunction getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\nfunction getGeomType() {\n    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nfunction getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n\nexport { getCoord, getCoords, containsNumber, geojsonType, featureOf, collectionOf, getGeom, getGeomType, getType };\n","import { feature, isObject, lineString, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    if (geomType === 'MultiPolygon') geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature$$1.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature$$1.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        if (coordEach(feature$$1, function (currentCoord, coordIndex, featureIndexCoord, mutliPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined) {\n                previousCoords = currentCoord;\n                return;\n            }\n            var currentSegment = lineString([previousCoords, currentCoord], feature$$1.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature$$1, featureIndex, multiFeatureIndex) {\n        if (feature$$1.geometry === null) return;\n        var type = feature$$1.geometry.type;\n        var coords = feature$$1.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature$$1, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(lineString(coords[geometryIndex], feature$$1.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexport { coordEach, coordReduce, propEach, propReduce, featureEach, featureReduce, coordAll, geomEach, geomReduce, flattenEach, flattenReduce, segmentEach, segmentReduce, lineEach, lineReduce, findSegment, findPoint };\n","import rbush from 'geojson-rbush';\nimport lineSegment from '@turf/line-segment';\nimport { getCoords } from '@turf/invariant';\nimport { featureEach } from '@turf/meta';\nimport { feature, featureCollection, point } from '@turf/helpers';\n\n/**\n * Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).\n *\n * @name lineIntersect\n * @param {Geometry|FeatureCollection|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line1 any LineString or Polygon\n * @param {Geometry|FeatureCollection|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line2 any LineString or Polygon\n * @returns {FeatureCollection<Point>} point(s) that intersect both\n * @example\n * var line1 = turf.lineString([[126, -11], [129, -21]]);\n * var line2 = turf.lineString([[123, -18], [131, -14]]);\n * var intersects = turf.lineIntersect(line1, line2);\n *\n * //addToMap\n * var addToMap = [line1, line2, intersects]\n */\nfunction lineIntersect(line1, line2) {\n    var unique = {};\n    var results = [];\n\n    // First, normalize geometries to features\n    // Then, handle simple 2-vertex segments\n    if (line1.type === 'LineString') line1 = feature(line1);\n    if (line2.type === 'LineString') line2 = feature(line2);\n    if (line1.type === 'Feature' &&\n        line2.type === 'Feature' &&\n        line1.geometry.type === 'LineString' &&\n        line2.geometry.type === 'LineString' &&\n        line1.geometry.coordinates.length === 2 &&\n        line2.geometry.coordinates.length === 2) {\n        var intersect = intersects(line1, line2);\n        if (intersect) results.push(intersect);\n        return featureCollection(results);\n    }\n\n    // Handles complex GeoJSON Geometries\n    var tree = rbush();\n    tree.load(lineSegment(line2));\n    featureEach(lineSegment(line1), function (segment) {\n        featureEach(tree.search(segment), function (match) {\n            var intersect = intersects(segment, match);\n            if (intersect) {\n                // prevent duplicate points https://github.com/Turfjs/turf/issues/688\n                var key = getCoords(intersect).join(',');\n                if (!unique[key]) {\n                    unique[key] = true;\n                    results.push(intersect);\n                }\n            }\n        });\n    });\n    return featureCollection(results);\n}\n\n/**\n * Find a point that intersects LineStrings with two coordinates each\n *\n * @private\n * @param {Feature<LineString>} line1 GeoJSON LineString (Must only contain 2 coordinates)\n * @param {Feature<LineString>} line2 GeoJSON LineString (Must only contain 2 coordinates)\n * @returns {Feature<Point>} intersecting GeoJSON Point\n */\nfunction intersects(line1, line2) {\n    var coords1 = getCoords(line1);\n    var coords2 = getCoords(line2);\n    if (coords1.length !== 2) {\n        throw new Error('<intersects> line1 must only contain 2 coordinates');\n    }\n    if (coords2.length !== 2) {\n        throw new Error('<intersects> line2 must only contain 2 coordinates');\n    }\n    var x1 = coords1[0][0];\n    var y1 = coords1[0][1];\n    var x2 = coords1[1][0];\n    var y2 = coords1[1][1];\n    var x3 = coords2[0][0];\n    var y3 = coords2[0][1];\n    var x4 = coords2[1][0];\n    var y4 = coords2[1][1];\n    var denom = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));\n    var numeA = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3));\n    var numeB = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3));\n\n    if (denom === 0) {\n        if (numeA === 0 && numeB === 0) {\n            return null;\n        }\n        return null;\n    }\n\n    var uA = numeA / denom;\n    var uB = numeB / denom;\n\n    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n        var x = x1 + (uA * (x2 - x1));\n        var y = y1 + (uA * (y2 - y1));\n        return point([x, y]);\n    }\n    return null;\n}\n\nexport default lineIntersect;\n","import bearing from '@turf/bearing';\nimport distance from '@turf/distance';\nimport destination from '@turf/destination';\nimport lineIntersects from '@turf/line-intersect';\nimport { flattenEach } from '@turf/meta';\nimport { point, lineString } from '@turf/helpers';\nimport { getCoords } from '@turf/invariant';\n\n/**\n * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the (Multi)LineString.\n *\n * @name pointOnLine\n * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to\n * @param {Geometry|Feature<Point>|number[]} pt point to snap from\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain three values: `index`: closest point was found on nth line part, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.\n * @example\n * var line = turf.lineString([\n *     [-77.031669, 38.878605],\n *     [-77.029609, 38.881946],\n *     [-77.020339, 38.884084],\n *     [-77.025661, 38.885821],\n *     [-77.021884, 38.889563],\n *     [-77.019824, 38.892368]\n * ]);\n * var pt = turf.point([-77.037076, 38.884017]);\n *\n * var snapped = turf.pointOnLine(line, pt, 'miles');\n *\n * //addToMap\n * var addToMap = [line, pt, snapped];\n * snapped.properties['marker-color'] = '#00f';\n */\nfunction pointOnLine(lines, pt, options) {\n    // Backwards compatible with v4.0\n    var units = (typeof options === 'object') ? options.units : options;\n\n    // validation\n    var type = (lines.geometry) ? lines.geometry.type : lines.type;\n    if (type !== 'LineString' && type !== 'MultiLineString') {\n        throw new Error('lines must be LineString or MultiLineString');\n    }\n\n    var closestPt = point([Infinity, Infinity], {\n        dist: Infinity\n    });\n\n    var length = 0.0;\n    flattenEach(lines, function (line) {\n        var coords = getCoords(line);\n\n        for (var i = 0; i < coords.length - 1; i++) {\n            //start\n            var start = point(coords[i]);\n            start.properties.dist = distance(pt, start, units);\n            //stop\n            var stop = point(coords[i + 1]);\n            stop.properties.dist = distance(pt, stop, units);\n            // sectionLength\n            var sectionLength = distance(start, stop, units);\n            //perpendicular\n            var heightDistance = Math.max(start.properties.dist, stop.properties.dist);\n            var direction = bearing(start, stop);\n            var perpendicularPt1 = destination(pt, heightDistance, direction + 90, units);\n            var perpendicularPt2 = destination(pt, heightDistance, direction - 90, units);\n            var intersect = lineIntersects(lineString([perpendicularPt1.geometry.coordinates, perpendicularPt2.geometry.coordinates]), lineString([start.geometry.coordinates, stop.geometry.coordinates]));\n            var intersectPt = null;\n            if (intersect.features.length > 0) {\n                intersectPt = intersect.features[0];\n                intersectPt.properties.dist = distance(pt, intersectPt, units);\n                intersectPt.properties.location = length + distance(start, intersectPt, units);\n            }\n\n            if (start.properties.dist < closestPt.properties.dist) {\n                closestPt = start;\n                closestPt.properties.index = i;\n                closestPt.properties.location = length;\n            }\n            if (stop.properties.dist < closestPt.properties.dist) {\n                closestPt = stop;\n                closestPt.properties.index = i + 1;\n                closestPt.properties.location = length + sectionLength;\n            }\n            if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {\n                closestPt = intersectPt;\n                closestPt.properties.index = i;\n            }\n            // update length\n            length += sectionLength;\n        }\n\n    });\n\n    return closestPt;\n}\n\nexport default pointOnLine;\n","import logger from 'loglevel';\nimport pointOnLine from '@turf/point-on-line';\nimport distance from '@turf/distance/';\nimport { point } from '@turf/helpers';\nimport * as _ from './lodash';\n\n\nconst turf = {\n    pointOnLine,\n    distance,\n    point,\n};\n\n\nconst CONSTS = {\n    START_INDEX: 0,\n    FIRST_STATION_INDEX: 1,\n    LAST_STATION_INDEX: 14,\n    END_INDEX: 15,\n};\n\n\nexport default class Stations {\n    constructor(points, lineString) {\n        this.points = points;\n        this.path = lineString;\n        this.pathReversed = false;\n        this.pathCircular = false;\n        this.pathStart = turf.point(this.path.geometry.coordinates[0]);\n        this.pathEnd = turf\n            .point(this.path.geometry.coordinates[this.path.geometry.coordinates.length - 1]);\n\n        this._sortPoints();\n        this._addIndexes();\n        this._updateCircularity();\n        if (!this.pathCircular) {\n            this._updateDirection();\n        }\n    }\n\n\n    _sortPoints() {\n        const path = this.path;\n        const enhancedPoints = _.map(this.points, point => {\n            point.properties.nearestOnLine = turf.pointOnLine(path, point, 'meters');\n            return point;\n        });\n\n        const sortedPoints = _.sortBy(enhancedPoints,\n            point => point.properties.nearestOnLine.properties.location);\n\n        this.points = sortedPoints;\n    }\n\n    _addIndexes() {\n        const getIndex = str => {\n            /** Regular expressions for extracting station number\n             *  from a given string (which might be represented by different types\n             *  of numbers and different delimiters)\n             */\n            const START_NAMES_REGEX = /^(wstp|wprowadzenie|pocztek|start)$/ig;\n            const END_NAMES_REGEX = /^(zakoczenie|koniec|podsumowanie)$/ig;\n            const ROMAN_NUMBERS_REGEX = /^(I|II|III|IV|V|VI|VII|VIII|IX|X|XI|XII|XIII|XIV)$/g;\n            const EUROPEAN_NUMBERS_REGEX = /^\\d+$/g;\n            const SPLITTER_REGEX = /[ ,\\._\\-:;]+/;\n            const ROMAN_EUROPEAN_MAP = {\n                I: 1,\n                II: 2,\n                III: 3,\n                IV: 4,\n                V: 5,\n                VI: 6,\n                VII: 7,\n                VIII: 8,\n                IX: 9,\n                X: 10,\n                XI: 11,\n                XII: 12,\n                XIII: 13,\n                XIV: 14,\n            };\n\n            let index = null;\n\n            logger.debug(`Checking station index for string: ${str}`);\n\n            // noname station\n            if (!str) {\n                return index;\n            }\n\n            // split\n            const parts = str.trim().split(SPLITTER_REGEX);\n\n            _.forEach(parts, part => {\n                // try roman numbers\n                // it isn't clear why there are for matches declaration\n                let matches = part.match(ROMAN_NUMBERS_REGEX);\n                if (!_.isNull(matches)) {\n                    index = ROMAN_EUROPEAN_MAP[matches[0]];\n                    return false;\n                }\n\n                // try european numbers\n                matches = part.match(EUROPEAN_NUMBERS_REGEX);\n                if (!_.isNull(matches)) {\n                    const stationNumber = parseInt(matches[0]);\n                    if (stationNumber >= CONSTS.FIRST_STATION_INDEX\n                        && stationNumber <= CONSTS.LAST_STATION_INDEX) {\n                        index = stationNumber;\n                        return false;\n                    }\n                    return true;\n                }\n\n                // try start names\n                matches = part.match(START_NAMES_REGEX);\n                if (!_.isNull(matches)) {\n                    index = CONSTS.START_INDEX;\n                    return false;\n                }\n\n                // try end names\n                matches = part.match(END_NAMES_REGEX);\n                if (!_.isNull(matches)) {\n                    index = CONSTS.END_INDEX;\n                    return false;\n                }\n            });\n\n            return index;\n        };\n\n        this.points = _.map(this.points, point => {\n            const name = point.properties.name;\n            const number = getIndex(name);\n\n            point.properties.index = number;\n            return point;\n        });\n    }\n\n    _updateDirection() {\n        const pathReversed = false;\n\n        const startPoint = _.filter(this.points,\n            point => point.properties.index === CONSTS.START_INDEX);\n        const endPoint = _.filter(this.points,\n            point => point.properties.index === CONSTS.END_INDEX);\n        const options = { units: 'kilometers' };\n\n        if (!_.isEmpty(startPoint)) {\n            logger.debug('Start point detected. Checking if it is closer to path start or path end...');\n            const startPointToPathStartDistance = turf.distance(this.pathStart,\n                startPoint[0], options);\n            const startPointToPathEndDistance = turf.distance(this.pathEnd, startPoint[0], options);\n            if (startPointToPathStartDistance > startPointToPathEndDistance) {\n                logger.debug('Reversed path detected. Start point is closer to path end.');\n                this.pathReversed = true;\n            }\n        } else if (!_.isEmpty(endPoint)) {\n            logger.debug('End point detected. Checking if it is closer to path start or path end...');\n            const endPointToPathStartDistance = turf.distance(this.pathStart, endPoint[0], options);\n            const endPointToPathEndDistance = turf.distance(this.pathEnd, endPoint[0], options);\n            if (endPointToPathEndDistance > endPointToPathStartDistance) {\n                logger.debug('Reversed path detected. Start point is closer to path end.');\n                this.pathReversed = true;\n            }\n        }\n        if (this.pathReversed) {\n            logger.debug('Reversing points.');\n            this.points = this.points.reverse();\n        }\n    }\n\n    _updateCircularity() {\n        const MAXIMUM_DISTANCE_START_END_IN_CIRCULAR_PATH = 500; // meters\n        const options = { units: 'kilometers' };\n\n        let distance = turf.distance(this.pathStart, this.pathEnd, options);\n        distance *= 1000;\n\n        if (distance <= MAXIMUM_DISTANCE_START_END_IN_CIRCULAR_PATH) {\n            logger.debug('Circular path detected. Distance between path start and end points:', distance.toFixed(2), 'meters.');\n            this.pathCircular = true;\n        }\n    }\n\n    getCount() {\n        let numberOfStations = 0;\n        for (let stationNumber = CONSTS.FIRST_STATION_INDEX;\n            stationNumber <= CONSTS.LAST_STATION_INDEX; stationNumber++) {\n            let firstStationName = '';\n            const stationsOfNumber = _.filter(this.points, station => {\n                if (station.properties.index === stationNumber) {\n                    firstStationName = station.properties.name;\n                    return true;\n                }\n                return false;\n            });\n            if (stationsOfNumber.length !== 1) {\n                logger.warn(`Station ${stationNumber} found ${stationsOfNumber.length} times.`);\n            } else {\n                logger.debug(`Station ${stationNumber} found. Station name: ${firstStationName}`);\n                numberOfStations++;\n            }\n        }\n        return numberOfStations;\n    }\n\n    isOrderCorrect() {\n        let result = true;\n        for (let i = 1; i < this.points.length; i++) {\n            const currentStationNumber = this.points[i].properties.index;\n            const previousStationNumber = this.points[i - 1].properties.index;\n            logger.debug(`Point ${i - 1}`);\n            if (currentStationNumber === null) {\n                logger.debug(`Not checking order for unrecognized point: ${this.points[i].properties.name}`);\n            } else if (previousStationNumber === null) {\n                logger.debug(`Not checking order for unrecognized point: ${this.points[i - 1].properties.name}`);\n            } else if (this.pathCircular\n                && (\n                    (previousStationNumber === CONSTS.FIRST_STATION_INDEX\n                    && currentStationNumber === CONSTS.LAST_STATION_INDEX)\n                    || (currentStationNumber === CONSTS.FIRST_STATION_INDEX\n                    && previousStationNumber === CONSTS.LAST_STATION_INDEX)\n                )\n            ) {\n                logger.debug('Not checking order for station', CONSTS.FIRST_STATION_INDEX, 'and', CONSTS.LAST_STATION_INDEX, 'when route is circular.');\n            } else if (currentStationNumber <= previousStationNumber) {\n                logger.warn(`Detected invalid order of stations. Station ${currentStationNumber} is after station ${previousStationNumber}.`);\n                result = false;\n            } else {\n                logger.debug(`Station ${currentStationNumber} is after station ${previousStationNumber}.`);\n            }\n        }\n        return result;\n    }\n\n    areAllOnThePath(maximumDistanceFromPath) {\n        let result = true;\n\n        _.forEach(this.points, (station, index) => {\n            const stationNumber = station.properties.index;\n            const distanceFromStationToPath = station.properties.nearestOnLine.properties.dist;\n            logger.debug(`Point ${index}`);\n            if (stationNumber === null) {\n                logger.debug(`Not checking distance for: ${station.properties.name}`);\n            } else if (distanceFromStationToPath > maximumDistanceFromPath) {\n                logger.warn(`Station ${stationNumber} is too far from path. Expected maximum distance from path: ${maximumDistanceFromPath} meter(s).`);\n                result = false;\n            } else {\n                logger.debug(`Station ${stationNumber} is on the path.`);\n            }\n        });\n\n        return result;\n    }\n\n    isPathReversed() {\n        return this.pathReversed;\n    }\n}\n","import logger from 'loglevel';\nimport * as _ from './lodash';\nimport helpers from './helpers';\nimport PathElevation from './PathElevation';\nimport Stations from './Stations';\n\n// Constants\nconst EXPECTED_NUMBER_OF_PATHS = 1;\nconst EXPECTED_NUMBER_OF_STATIONS = 14;\nconst MAXIMUM_DISTANCE_FROM_STATION_TO_PATH = 100; // meters\n\n\nexport default class Route {\n    constructor(geoJson) {\n        this.geoJson = geoJson;\n        this.lineString = helpers.getLineString(this.geoJson);\n        this.points = helpers.getPoints(this.geoJson);\n        this.isRouteVerifiable = true;\n\n        if (_.isEmpty(this.lineString)) {\n            logger.error('No line string in route.');\n            this.isRouteVerifiable = false;\n        }\n        if (_.isEmpty(this.points)) {\n            logger.error('No points in route.');\n            this.isRouteVerifiable = false;\n        }\n        if (this.isRouteVerifiable) {\n            this.stations = new Stations(this.points, this.lineString);\n            this.path = this.stations.isPathReversed()\n                ? helpers.reverseLineString(this.lineString)\n                : this.lineString;\n            this.numberOfPaths = helpers.getNumberOfFeatures('LineString', this.geoJson);\n        }\n    }\n\n\n    isVerifiable() {\n        return this.isRouteVerifiable;\n    }\n\n    isSinglePath() {\n        const result = _.isEqual(this.numberOfPaths, EXPECTED_NUMBER_OF_PATHS);\n        if (!result) {\n            logger.warn('No single path defined.');\n        }\n        logger.debug('isSinglePath:', result, ', numberOfPaths:', this.numberOfPaths);\n        return result;\n    }\n\n    areAllStationsPresent() {\n        const numberOfStations = this.stations.getCount();\n        const result = _.isEqual(numberOfStations, EXPECTED_NUMBER_OF_STATIONS);\n        logger.debug('areAllStationsPresent:', result, ', numberOfStations:', numberOfStations);\n        return result;\n    }\n\n    areStationsOnThePath() {\n        const result = this.stations.areAllOnThePath(MAXIMUM_DISTANCE_FROM_STATION_TO_PATH);\n        logger.debug('areStationsOnThePath:', result);\n        return result;\n    }\n\n    isStationOrderCorrect() {\n        const result = this.stations.isOrderCorrect();\n        logger.debug('isStationOrderCorrect:', result);\n        return result;\n    }\n\n    getPathLength() {\n        let result = 0;\n\n        const googleMapsPath = helpers.getGoogleMapsPath(this.path);\n        result = google.maps.geometry.spherical.computeLength(googleMapsPath);\n        result /= 1000;\n\n        logger.debug('getPathLength [km]:', result);\n        return result;\n    }\n\n    fetchPathElevationData() {\n        return helpers.getPathElevations(this.path)\n            .then(elevations => {\n                logger.debug('Path elevations:', elevations);\n                this.pathElevation = new PathElevation(elevations);\n                return this.pathElevation;\n            })\n            .catch(error => {\n                throw new Error(error);\n            });\n    }\n\n    getPathElevation() {\n        logger.debug('getPathElevation:', this.pathElevation);\n        return this.pathElevation;\n    }\n}\n","export default function () {\n    const mapCanvasElement = $('div#map-canvas');\n\n    this.routeUrl = mapCanvasElement.attr('data-what');\n    this.routeParamsUrl = mapCanvasElement.attr('data-route-params');\n    this.routeApproveUrl = mapCanvasElement.attr('data-route-approve');\n}\n","import logger from 'loglevel';\nimport * as _ from './lodash';\n\n// Constants\nconst ROUTE_TYPE_ID = 'div#routeType';\nconst SINGLE_PATH_ID = 'div#singlePath';\nconst PATH_LENGTH_ID = 'div#pathLength';\nconst ELEVATION_GAIN_ID = 'div#elevationGain';\nconst ELEVATION_LOSS_ID = 'div#elevationLoss';\nconst ELEVATION_TOTAL_CHANGE_ID = 'div#elevationTotalChange';\nconst NUMBER_OF_STATIONS_ID = 'div#numberOfStations';\nconst STATIONS_ORDER_ID = 'div#stationsOrder';\nconst STATIONS_ON_PATH_ID = 'div#stationsOnPath';\nconst DATA_CONSISTENCY_ID = 'div#dataConsistency';\nconst ELEVATION_CHART_ID = 'canvas#elevationChart';\nconst VERIFY_BUTTON_ID = 'button#verifyRoute';\nconst LOADER_ID = 'div#loader';\nconst LOADER_ELEMENT = '<div id=\"loader\" class=\"overlay\"><i class=\"fa fa-refresh fa-spin\"></i></div>';\nconst ELEVATION_CHART_ELEMENT = '<canvas id=\"elevationChart\"></canvas>';\n\n\nconst updateControlColor = (element, isValid) => {\n    const VALID_COLOR_CLASS = 'bg-green';\n    const INVALID_COLOR_CLASS = 'bg-yellow';\n    const INFO_BOX_ICON = 'span.info-box-icon';\n\n    if (_.isNull(isValid)) {\n        $(`${element} ${INFO_BOX_ICON}`).removeClass([INVALID_COLOR_CLASS, VALID_COLOR_CLASS].join(' '));\n    } else {\n        (isValid)\n            ? $(`${element} ${INFO_BOX_ICON}`).removeClass(INVALID_COLOR_CLASS).addClass(VALID_COLOR_CLASS)\n            : $(`${element} ${INFO_BOX_ICON}`).removeClass(VALID_COLOR_CLASS).addClass(INVALID_COLOR_CLASS);\n    }\n};\n\nconst updateControlValue = (element, value, unit) => {\n    const INFO_BOX_NUMBER = 'span.info-box-number';\n\n    logger.debug('Updating control element', element, 'with:', value, unit);\n    $(`${element} ${INFO_BOX_NUMBER}`).html(`${value} ${unit ? `<small>${unit}</small>` : ''}`);\n};\n\nconst removeControlChildren = element => {\n    $(ELEVATION_CHART_ID).empty();\n};\n\n\nexport default class Controls {\n    // Constructor\n\n\n    updateRouteType(isNormalRoute) {\n        const normalRouteString = $('input#normalRouteString').attr('value');\n        const inspiredRouteString = $('input#inspiredRouteString').attr('value');\n        updateControlValue(ROUTE_TYPE_ID, isNormalRoute ? normalRouteString : inspiredRouteString);\n    }\n\n    updatePathLength(isLengthValid, length) {\n        updateControlValue(PATH_LENGTH_ID, length.toFixed(2), 'km');\n        updateControlColor(PATH_LENGTH_ID, isLengthValid);\n    }\n\n    updateElevationGain(isElevationGainValid, elevationGain) {\n        updateControlValue(ELEVATION_GAIN_ID, elevationGain.toFixed(2), 'm');\n        updateControlColor(ELEVATION_GAIN_ID, isElevationGainValid);\n    }\n\n    updateElevationLoss(isElevationLossValid, elevationLoss) {\n        updateControlValue(ELEVATION_LOSS_ID, elevationLoss.toFixed(2), 'm');\n        updateControlColor(ELEVATION_LOSS_ID, isElevationLossValid);\n    }\n\n    updateElevationTotalChange(isElevationTotalChangeValid, elevationTotalChange) {\n        updateControlValue(ELEVATION_TOTAL_CHANGE_ID, elevationTotalChange.toFixed(2), 'm');\n        updateControlColor(ELEVATION_TOTAL_CHANGE_ID, isElevationTotalChangeValid);\n    }\n\n    updateNumberOfStations(areAllStationsPresent) {\n        updateControlColor(NUMBER_OF_STATIONS_ID, areAllStationsPresent);\n    }\n\n    updateStationsOrder(isStationOrderCorrect) {\n        updateControlColor(STATIONS_ORDER_ID, isStationOrderCorrect);\n    }\n\n    updateStationsOnPath(areAllStationsOnPath) {\n        updateControlColor(STATIONS_ON_PATH_ID, areAllStationsOnPath);\n    }\n\n    updateSinglePath(isSinglePath) {\n        updateControlColor(SINGLE_PATH_ID, isSinglePath);\n    }\n\n    updateDataConsistency(isDataConsistent) {\n        updateControlColor(DATA_CONSISTENCY_ID, isDataConsistent);\n    }\n\n    drawElevationChart(pathElevation) {\n        const X_AXIS_NUMBER_OF_LABELS = 10;\n        const X_AXIS_LABEL_STRING = '[km]';\n        const Y_AXIS_LABEL_STRING = '[m]';\n        const CHART_BACKGROUND_COLOR = 'rgb(32, 77, 116)';\n\n        const labelWidth = parseInt(pathElevation.data.length / X_AXIS_NUMBER_OF_LABELS);\n        const labels = _.map(pathElevation.data, elevation => elevation.distance.toFixed());\n        const data = _.map(pathElevation.data, elevation => elevation.elevation);\n\n        logger.debug('Drawing elevation chart. Input:', pathElevation);\n\n        const elevationChart = new Chart($(ELEVATION_CHART_ID), {\n            type: 'line',\n            data: {\n                labels,\n                datasets: [{\n                    label: '',\n                    data,\n                    fill: 'start',\n                    radius: 0,\n                    backgroundColor: CHART_BACKGROUND_COLOR,\n                }],\n            },\n            options: {\n                scales: {\n                    xAxes: [{\n                        scaleLabel: {\n                            display: true,\n                            labelString: X_AXIS_LABEL_STRING,\n                        },\n                        ticks: {\n                            callback: (dataLabel, index) => (index % labelWidth === 0\n                                || (index === pathElevation.data.length - 1)\n                                ? dataLabel\n                                : null)\n                            ,\n                        },\n                    }],\n                    yAxes: [{\n                        scaleLabel: {\n                            display: true,\n                            labelString: Y_AXIS_LABEL_STRING,\n                        },\n                    }],\n                },\n                legend: {\n                    display: false,\n                },\n                tooltips: {\n                    enabled: false,\n                },\n            },\n        });\n    }\n\n    resetElevationChart() {\n        const elevationChartParentElement = $(ELEVATION_CHART_ID).parent();\n        $(ELEVATION_CHART_ID).remove();\n        elevationChartParentElement.append(ELEVATION_CHART_ELEMENT);\n    }\n\n    addLoaderToButton() {\n        $(VERIFY_BUTTON_ID).append(LOADER_ELEMENT);\n    }\n\n    removeLoaderFromButton() {\n        $(`${VERIFY_BUTTON_ID} ${LOADER_ID}`).remove();\n    }\n\n    resetAll(value) {\n        const text = '';\n        const isValid = value === undefined ? null : value;\n\n        updateControlValue(ROUTE_TYPE_ID, text);\n        updateControlValue(PATH_LENGTH_ID, text);\n        updateControlColor(PATH_LENGTH_ID, isValid);\n        updateControlValue(ELEVATION_GAIN_ID, text);\n        updateControlColor(ELEVATION_GAIN_ID, isValid);\n        updateControlValue(ELEVATION_LOSS_ID, text);\n        updateControlColor(ELEVATION_LOSS_ID, isValid);\n        updateControlValue(ELEVATION_TOTAL_CHANGE_ID, text);\n        updateControlColor(ELEVATION_TOTAL_CHANGE_ID, isValid);\n        updateControlColor(NUMBER_OF_STATIONS_ID, isValid);\n        updateControlColor(STATIONS_ORDER_ID, isValid);\n        updateControlColor(STATIONS_ON_PATH_ID, isValid);\n        updateControlColor(SINGLE_PATH_ID, isValid);\n        updateControlColor(DATA_CONSISTENCY_ID, isValid);\n        this.resetElevationChart();\n    }\n}\n","import logger from 'loglevel';\nimport helpers from './helpers';\nimport Route from './Route';\nimport Context from './Context';\nimport Controls from './Controls';\n\n\n// Constants\nconst NORMAL_ROUTE_MIN_LENGTH = 40; // kilometers\nconst SHORT_NORMAL_ROUTE_MIN_LENGTH = 30; // kilometers\nconst SHORT_NORMAL_ROUTE_MIN_ELEVATION_GAIN = 500; // meters\n\n\nfunction verifyRoute() {\n    if (!window.google || !window.google.maps) {\n        logger.error('Google Maps API is not loaded.');\n        return;\n    }\n    const context = new Context();\n    const controls = new Controls();\n\n    controls.resetAll();\n    controls.addLoaderToButton();\n\n    helpers.getRoute(context.routeUrl)\n        .done(data => {\n            const geoJson = helpers.getGeoJSON(data);\n            const route = new Route(geoJson);\n\n            if (!route.isVerifiable()) {\n                logger.error('Route is unverifiable.');\n                controls.resetAll(false);\n                return;\n            }\n\n            // Path basic checks\n            const isSinglePath = route.isSinglePath();\n            controls.updateSinglePath(isSinglePath);\n\n            const routeLength = route.getPathLength();\n\n            const isPathLengthValid = true;\n            controls.updatePathLength(isPathLengthValid, routeLength);\n\n            // Station checks\n            const areAllStationsPresent = route.areAllStationsPresent();\n            controls.updateNumberOfStations(areAllStationsPresent);\n            const isStationOrderCorrect = route.isStationOrderCorrect();\n            controls.updateStationsOrder(isStationOrderCorrect);\n            const areStationsOnThePath = route.areStationsOnThePath();\n            controls.updateStationsOnPath(areStationsOnThePath);\n\n            // Elevation checks\n            route.fetchPathElevationData()\n                .then(() => {\n                    const pathElevation = route.getPathElevation();\n                    pathElevation.enrichData(routeLength);\n\n                    const isPathElevationGainValid = true;\n                    controls.updateElevationGain(isPathElevationGainValid, pathElevation.gain);\n\n                    const isNormalRoute = routeLength >= NORMAL_ROUTE_MIN_LENGTH\n                        || pathElevation.gain > SHORT_NORMAL_ROUTE_MIN_ELEVATION_GAIN\n                        && routeLength >= SHORT_NORMAL_ROUTE_MIN_LENGTH;\n                    controls.updateRouteType(isNormalRoute);\n\n                    const isPathElevationLossValid = true;\n                    controls.updateElevationLoss(isPathElevationLossValid, pathElevation.loss);\n\n                    const isPathElevationTotalChangeValid = true;\n                    controls.updateElevationTotalChange(isPathElevationTotalChangeValid,\n                        pathElevation.totalChange);\n\n                    controls.drawElevationChart(pathElevation);\n\n                    helpers.getRouteParameters(context.routeParamsUrl)\n                        .then(parameters => {\n                            const ACCEPTED_ROUTE_LENGTH_DIFF = 1; // km\n                            const ACCEPTED_ELEVATION_GAIN_DIFF = 50; // m\n                            const NORMAL_ROUTE_TYPE = 0;\n                            const INSPIRED_ROUTE_TYPE = 1;\n                            /* eslint-disable max-len */\n                            const isLengthConsistent = (routeLength - ACCEPTED_ROUTE_LENGTH_DIFF <= parameters.length\n                                && parameters.length <= routeLength + ACCEPTED_ROUTE_LENGTH_DIFF);\n                            const isElevationGainConsistent = (pathElevation.gain - ACCEPTED_ELEVATION_GAIN_DIFF <= parameters.ascent\n                                && parameters.ascent <= pathElevation.gain + ACCEPTED_ELEVATION_GAIN_DIFF);\n                            const isRouteTypeConsistent = parameters.type === (isNormalRoute ? NORMAL_ROUTE_TYPE : INSPIRED_ROUTE_TYPE);\n                            const isDataConsistent = isLengthConsistent && isElevationGainConsistent && isRouteTypeConsistent;\n\n                            logger.debug('isLengthConsistent:', isLengthConsistent,\n                                ', isElevationGainConsistent:', isElevationGainConsistent,\n                                ', isRouteTypeConsistent:', isRouteTypeConsistent);\n                            controls.updateDataConsistency(isDataConsistent);\n\n                            const canRouteBeAutomaticallyApproved = isSinglePath && isPathLengthValid\n                                && areAllStationsPresent && isStationOrderCorrect\n                                && areStationsOnThePath && isPathElevationGainValid\n                                && isPathElevationLossValid && isPathElevationTotalChangeValid\n                                && isDataConsistent;\n\n                            if (canRouteBeAutomaticallyApproved) {\n                                logger.info('Route verification success. Approving...');\n                                helpers.approveRoute(context.routeApproveUrl)\n                                    .then(() => {\n                                        logger.info('Route approved.');\n                                        const pageReloadModalElement = $('div#pageReloadModal');\n                                        const reloadTimeout = setTimeout(() => {\n                                            window.location.reload(1);\n                                        }, 5000);\n                                        pageReloadModalElement.on('hide.bs.modal', e => clearTimeout(reloadTimeout));\n                                        pageReloadModalElement.modal();\n                                    })\n                                    .catch(error => {\n                                        logger.error('Route approval error.', error);\n                                    });\n                            } else {\n                                logger.info('Route verification failed. Cannot be approved.');\n                            }\n                        })\n                        .catch(error => {\n                            logger.error('Route parameters data fetching error.', error);\n                        });\n                })\n                .catch(error => {\n                    logger.error('Path elevation data fetching error.', error);\n                    controls.updateElevationGain(false, 0);\n                    controls.updateElevationLoss(false, 0);\n                    controls.updateElevationTotalChange(false, 0);\n                    controls.updateDataConsistency(false);\n                });\n        }).fail((xhr, status) => {\n            logger.error('Route fetching error. Status:', status);\n        }).always(() => {\n            controls.removeLoaderFromButton();\n        });\n}\n\nif (process.env.NODE_ENV === 'production') {\n    logger.setLevel('warn');\n} else {\n    logger.setLevel('debug');\n}\nwindow.setLogLevel = (logLevel = 'debug') => logger.setLevel(logLevel);\n\n$('button#verifyRoute').bind('click', verifyRoute);\n"],"sourceRoot":""}